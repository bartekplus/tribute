{"version":3,"file":"tribute.min.js","sources":["../src/TributeEvents.js","../src/TributeMenuEvents.js","../src/TributeRange.js","../src/TributeSearch.js","../src/Tribute.js"],"sourcesContent":["/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\nclass TributeEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.events = this;\n  }\n\n  static keys() {\n    return [\"Tab\", \"Enter\", \"Escape\", \"ArrowUp\", \"ArrowDown\"];\n  }\n\n  static modifiers() {\n    return [\n      \"CapsLock\",\n      \"Control\",\n      \"Fn\",\n      \"Hyper\",\n      \"Meta\",\n      \"OS\",\n      \"Super\",\n      \"Symbol\",\n      \"Win\",\n    ];\n  }\n\n  bind(element) {\n    const KEY_EVENT_TIMEOUT_MS = 32;\n    element.boundKeyDown = this.tribute.debounce(\n      this.keydown.bind(element, this),\n      KEY_EVENT_TIMEOUT_MS\n    );\n    element.boundKeyUpInput = this.tribute.debounce(\n      this.input.bind(element, this),\n      KEY_EVENT_TIMEOUT_MS\n    );\n\n    element.addEventListener(\"keydown\", element.boundKeyDown, true);\n    element.addEventListener(\"keyup\", element.boundKeyUpInput, true);\n    element.addEventListener(\"input\", element.boundKeyUpInput, true);\n  }\n\n  unbind(element) {\n    element.removeEventListener(\"keydown\", element.boundKeyDown, true);\n    element.removeEventListener(\"keyup\", element.boundKeyUpInput, true);\n    element.removeEventListener(\"input\", element.boundKeyUpInput, true);\n\n    delete element.boundKeyDown;\n    delete element.boundKeyUpInput;\n  }\n\n  keydown(instance, event) {\n    let controlKeyPressed = false;\n    let keyProcessed = false;\n\n    if (event instanceof KeyboardEvent) {\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n    }\n\n    if (instance.tribute.isActive && !controlKeyPressed) {\n      TributeEvents.keys().forEach((key) => {\n        if (key === event.code) {\n          instance.callbacks()[key](event, this);\n          keyProcessed = true;\n          return;\n        }\n      });\n    }\n    if (!keyProcessed) instance.tribute.hideMenu();\n  }\n\n  input(instance, event) {\n    if (!(event instanceof CustomEvent)) {\n      instance.keyup.call(this, instance, event);\n    }\n  }\n\n  click(instance, event) {\n    const tribute = instance.tribute;\n    if (tribute.menu && tribute.menu.contains(event.target)) {\n      let li = event.target;\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      while (li.nodeName.toLowerCase() !== \"li\") {\n        li = li.parentNode;\n        if (!li || li === tribute.menu) {\n          throw new Error(\"cannot find the <li> container for the click\");\n        }\n      }\n\n      tribute.selectItemAtIndex(li.getAttribute(\"data-index\"), event);\n    } else {\n      tribute.hideMenu();\n    }\n  }\n\n  keyup(instance, event) {\n    // Check for modifiers keys\n    if (event instanceof KeyboardEvent) {\n      if (event.key && event.key.length > 1) {\n        // Not a Character exit early\n        return;\n      }\n\n      let controlKeyPressed = false;\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      // Check for control keys\n      TributeEvents.keys().forEach((key) => {\n        if (key === event.code) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      if (controlKeyPressed) return;\n    }\n\n    if (!instance.updateSelection(this)) return;\n\n    const keyCode = instance.getKeyCode(event);\n    // Exit if no keyCode\n    if (isNaN(keyCode)) {\n      return;\n    }\n\n    if (!instance.tribute.autocompleteMode) {\n      const trigger = instance.tribute.triggers().find((trigger) => {\n        return trigger.charCodeAt(0) === keyCode;\n      });\n      if (!trigger) return;\n      const collection = instance.tribute.collection.find((item) => {\n        return item.trigger === trigger;\n      });\n      if (!collection) return;\n      if (\n        collection.menuShowMinLength >\n        instance.tribute.current.mentionText.length\n      )\n        return;\n      instance.tribute.current.collection = collection;\n    } else {\n      instance.tribute.current.collection = instance.tribute.collection[0];\n    }\n\n    instance.tribute.showMenuFor(this, true);\n  }\n\n  getKeyCode(event) {\n    const keyCode = event.keyCode || event.which || event.code;\n    if (keyCode) {\n      return keyCode;\n    } else {\n      if (this.tribute.current.mentionTriggerChar)\n        return this.tribute.current.mentionTriggerChar.charCodeAt(0);\n      else if (this.tribute.current.mentionText)\n        return this.tribute.current.mentionText.charCodeAt(\n          this.tribute.current.mentionText.length - 1\n        );\n    }\n    return NaN;\n  }\n\n  updateSelection(el) {\n    this.tribute.current.element = el;\n    const info = this.tribute.range.getTriggerInfo(\n      this.tribute.allowSpaces,\n      this.tribute.autocompleteMode\n    );\n\n    if (info) {\n      this.tribute.current.mentionTriggerChar = info.mentionTriggerChar;\n      this.tribute.current.mentionText = info.mentionText;\n      this.tribute.current.mentionPosition = info.mentionPosition;\n      this.tribute.current.fullText = info.fullText;\n      this.tribute.current.nextChar = info.nextChar;\n      return true;\n    }\n\n    return false;\n  }\n\n  callbacks() {\n    return {\n      Enter: (e, _el) => {\n        // choose selection\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          this.tribute.selectItemAtIndex(this.tribute.menuSelected, e);\n        }\n      },\n      Escape: (e, _el) => {\n        if (this.tribute.isActive) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          this.tribute.hideMenu();\n        }\n      },\n      Tab: (e, el) => {\n        // choose first match\n        this.callbacks().Enter(e, el);\n      },\n      Space: (e, el) => {\n        if (this.tribute.isActive) {\n          if (this.tribute.spaceSelectsMatch) {\n            this.callbacks().Enter(e, el);\n          } else {\n            this.tribute.hideMenu();\n          }\n        }\n      },\n      ArrowUp: (e, _el) => {\n        // navigate up ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          const count = this.tribute.current.filteredItems.length,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected && selected > 0) {\n            this.setActiveLi(selected - 1);\n          } else if (selected === 0) {\n            this.setActiveLi(count - 1);\n            this.tribute.menu.scrollTop = this.tribute.menu.scrollHeight;\n          }\n        }\n      },\n      ArrowDown: (e, _el) => {\n        // navigate down ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          const count = this.tribute.current.filteredItems.length - 1,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected) {\n            this.setActiveLi(selected + 1);\n          } else if (count === selected) {\n            this.setActiveLi(0);\n            this.tribute.menu.scrollTop = 0;\n          }\n        }\n      },\n    };\n  }\n\n  setActiveLi(index) {\n    const lis = this.tribute.menu.querySelectorAll(\"li\"),\n      length = lis.length >>> 0;\n\n    this.tribute.menuSelected = index;\n\n    for (let i = 0; i < length; i++) {\n      const li = lis[i];\n      if (i === this.tribute.menuSelected) {\n        li.classList.add(this.tribute.current.collection.selectClass);\n\n        const liClientRect = li.getBoundingClientRect();\n        const menuClientRect = this.tribute.menu.getBoundingClientRect();\n\n        if (liClientRect.bottom > menuClientRect.bottom) {\n          const scrollDistance = liClientRect.bottom - menuClientRect.bottom;\n          this.tribute.menu.scrollTop += scrollDistance;\n        } else if (liClientRect.top < menuClientRect.top) {\n          const scrollDistance = menuClientRect.top - liClientRect.top;\n          this.tribute.menu.scrollTop -= scrollDistance;\n        }\n      } else {\n        li.classList.remove(this.tribute.current.collection.selectClass);\n      }\n    }\n  }\n\n  getFullHeight(elem, includeMargin) {\n    const height = elem.getBoundingClientRect().height;\n\n    if (includeMargin) {\n      const style = elem.currentStyle || window.getComputedStyle(elem);\n      return (\n        height + parseFloat(style.marginTop) + parseFloat(style.marginBottom)\n      );\n    }\n\n    return height;\n  }\n}\n\nexport default TributeEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\nclass TributeMenuEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.menuEvents = this;\n    this.menu = this.tribute.menu;\n  }\n\n  bind(_menu) {\n    this.menuClickEvent = this.tribute.events.click.bind(null, this);\n    this.menuContainerScrollEvent = this.tribute.debounce(\n      () => {\n        this.tribute.hideMenu();\n      },\n      10,\n      false\n    );\n    this.windowResizeEvent = this.tribute.debounce(\n      () => {\n        this.tribute.hideMenu();\n      },\n      10,\n      false\n    );\n\n    this.windowBlurEvent = () => {\n      this.tribute.hideMenu();\n    };\n\n    this.tribute.range\n      .getDocument()\n      .addEventListener(\"mousedown\", this.menuClickEvent, false);\n    window.addEventListener(\"resize\", this.windowResizeEvent);\n    window.addEventListener(\"blur\", this.windowBlurEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.addEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.addEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n\n  unbind(_menu) {\n    this.tribute.range\n      .getDocument()\n      .removeEventListener(\"mousedown\", this.menuClickEvent, false);\n    window.removeEventListener(\"resize\", this.windowResizeEvent);\n    window.removeEventListener(\"blur\", this.windowBlurEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.removeEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.removeEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n}\n\nexport default TributeMenuEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/jeff-collins/ment.io\n\nclass TributeRange {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.range = this;\n  }\n\n  getDocument() {\n    let iframe;\n    if (this.tribute.current.collection) {\n      iframe = this.tribute.current.collection.iframe;\n    }\n\n    if (!iframe) {\n      return document;\n    }\n\n    return iframe.contentWindow.document;\n  }\n\n  positionMenuAtCaret(scrollTo) {\n    const context = this.tribute.current;\n    let coordinates;\n\n    if (!this.tribute.positionMenu) {\n      this.tribute.menu.style.display = `block`;\n      return;\n    }\n\n    if (!this.isContentEditable(context.element)) {\n      coordinates = this.getTextAreaOrInputUnderlinePosition(\n        context.element,\n        context.mentionPosition + context.mentionText.length\n      );\n    } else {\n      coordinates = this.getContentEditableCaretPosition(\n        context.mentionPosition + context.mentionText.length\n      );\n    }\n\n    this.tribute.menu.style.top = `${coordinates.top}px`;\n    this.tribute.menu.style.left = `${coordinates.left}px`;\n    this.tribute.menu.style.right = `${coordinates.right}px`;\n    this.tribute.menu.style.bottom = `${coordinates.bottom}px`;\n    this.tribute.menu.style[\"max-heigh\"] = `${coordinates.maxHeight || 500}px`;\n    this.tribute.menu.style[\"max-width\"] = `${coordinates.maxWidth || 300}px`;\n    this.tribute.menu.style.position = `${coordinates.position || \"absolute\"}`;\n    this.tribute.menu.style.display = `block`;\n\n    if (coordinates.left === \"auto\") {\n      this.tribute.menu.style.left = \"auto\";\n    }\n\n    if (coordinates.top === \"auto\") {\n      this.tribute.menu.style.top = \"auto\";\n    }\n\n    if (scrollTo) this.scrollIntoView();\n  }\n\n  get menuContainerIsBody() {\n    return (\n      this.tribute.menuContainer === this.getDocument().body ||\n      !this.tribute.menuContainer\n    );\n  }\n\n  replaceTriggerText(text, originalEvent, item) {\n    const context = this.tribute.current;\n    const detail = {\n      item: item,\n      context: context,\n      event: originalEvent,\n      text: text,\n    };\n    const replaceEvent = new CustomEvent(\"tribute-replaced\");\n\n    if (!this.isContentEditable(context.element)) {\n      const myField = this.tribute.current.element;\n      const textSuffix =\n        typeof this.tribute.replaceTextSuffix === \"string\"\n          ? this.tribute.replaceTextSuffix\n          : \" \";\n      text = this.stripHtml(text);\n      text += textSuffix;\n      const startPos = context.mentionPosition;\n      let endPos =\n        context.mentionPosition +\n        context.mentionText.length +\n        textSuffix.length;\n      if (!this.tribute.autocompleteMode) {\n        endPos += context.mentionTriggerChar.length - 1;\n      }\n      myField.value =\n        myField.value.substring(0, startPos) +\n        text +\n        myField.value.substring(endPos, myField.value.length);\n      myField.selectionStart = startPos + text.length;\n      myField.selectionEnd = startPos + text.length;\n    } else {\n      const textSuffix =\n        typeof this.tribute.replaceTextSuffix === \"string\"\n          ? this.tribute.replaceTextSuffix\n          : \"\\xA0\";\n      text += textSuffix;\n      this.pasteContentEditable(\n        text,\n        context.mentionText.length + context.mentionTriggerChar.length\n      );\n    }\n\n    context.element.dispatchEvent(\n      new CustomEvent(\"input\", { bubbles: true, detail: detail })\n    );\n    context.element.dispatchEvent(replaceEvent);\n  }\n\n  pasteContentEditable(html, numOfCharsToRemove) {\n    const { sel, range } = this.getContentEditableSelectionStart(true);\n    if (sel) {\n      const strippedText = this.stripHtml(html);\n      const isHTML = html !== strippedText;\n      const useSimpleReplace =\n        !isHTML &&\n        sel.anchorOffset >= numOfCharsToRemove &&\n        sel.anchorOffset <= sel.anchorNode.nodeValue.length;\n      if (useSimpleReplace) {\n        this.pasteText(sel, range, strippedText, numOfCharsToRemove);\n      } else {\n        this.pasteHtml(sel, range, html, numOfCharsToRemove);\n      }\n    }\n  }\n\n  pasteText(sel, range, text, numOfCharsToRemove) {\n    const pre = sel.anchorNode.nodeValue.substring(\n      0,\n      sel.anchorOffset - numOfCharsToRemove\n    );\n    const post = sel.anchorNode.nodeValue.substring(\n      sel.anchorOffset,\n      sel.anchorNode.nodeValue.length\n    );\n    sel.anchorNode.nodeValue = pre + text + post;\n    range.setStart(sel.anchorNode, pre.length + text.length);\n    range.collapse(true);\n    sel.removeAllRanges();\n    sel.addRange(range);\n    sel.collapseToEnd();\n  }\n\n  pasteHtml(sel, _range, html, numOfCharsToRemove) {\n    for (let index = 0; index < numOfCharsToRemove; index++) {\n      sel.modify(\"extend\", \"backward\", \"character\");\n    }\n    const newRange = sel.getRangeAt(0);\n    newRange.deleteContents();\n\n    const el = this.getDocument().createElement(\"div\");\n    el.innerHTML = html;\n    const frag = this.getDocument().createDocumentFragment();\n    let node, lastNode;\n\n    while ((node = el.firstChild)) {\n      lastNode = frag.appendChild(node);\n    }\n    newRange.insertNode(frag);\n\n    // Preserve the selection\n    if (lastNode) {\n      newRange.setStart(lastNode, lastNode.length);\n      newRange.setEnd(lastNode, lastNode.length);\n      newRange.collapse(true);\n      sel.removeAllRanges();\n      sel.addRange(newRange);\n      sel.collapseToEnd();\n    }\n  }\n\n  stripHtml(html) {\n    const tmp = this.getDocument().createElement(\"DIV\");\n    tmp.innerHTML = html;\n    return tmp.textContent || tmp.innerText || \"\";\n  }\n\n  getWindowSelection() {\n    if (this.tribute.collection.iframe) {\n      return this.tribute.collection.iframe.contentWindow.getSelection();\n    }\n\n    const rootNode = this.tribute.current.element.getRootNode();\n    if (rootNode.getSelection) return rootNode.getSelection();\n    else return window.getSelection();\n  }\n\n  getContentEditableSelectionStart(moveToEndOfWord) {\n    const sel = this.getWindowSelection();\n    if (!sel.isCollapsed) {\n      return { sel: null, range: null, direction: null };\n    }\n    const direction = sel.anchorOffset <= sel.focusOffset;\n    const range = sel.getRangeAt(0);\n    const selectedElem = sel.anchorNode;\n    const workingNodeContent = selectedElem.textContent;\n    const selectStartOffset = range.startOffset;\n    let nextChar =\n      workingNodeContent.length > selectStartOffset\n        ? workingNodeContent[selectStartOffset]\n        : null;\n    if (nextChar === null) {\n      if (selectedElem.nextSibling && selectedElem.nextSibling.textContent) {\n        const nextNodeText = selectedElem.nextSibling.textContent;\n        nextChar = nextNodeText.length ? nextNodeText[0] : null;\n      }\n    }\n    const nextCharIsSeparator =\n      !this.tribute.autocompleteSeparator ||\n      (nextChar && nextChar.match(this.tribute.autocompleteSeparator));\n    sel.collapseToEnd();\n    if (nextChar && !nextCharIsSeparator && moveToEndOfWord)\n      sel.modify(\"move\", \"forward\", \"word\");\n\n    return { sel, range, direction };\n  }\n\n  getWholeWordsUpToCharIndex(str, minLen) {\n    if (this.tribute.autocompleteSeparator) {\n      let searchPos = 0;\n      const arr = str\n        .split(this.tribute.autocompleteSeparator)\n        .filter(function (e) {\n          return e.trim();\n        });\n\n      for (let i = 0, len = arr.length; i < len; i++) {\n        const idx = str.indexOf(arr[i], searchPos);\n        searchPos += arr[i].length;\n\n        if (minLen >= idx && minLen <= idx + arr[i].length) {\n          minLen = idx + arr[i].length;\n          break;\n        }\n      }\n    }\n\n    const nextChar = str.length > minLen ? str[minLen] : \"\";\n    return [str.substring(0, minLen), nextChar];\n  }\n\n  getTextForCurrentSelection() {\n    const context = this.tribute.current;\n    let effectiveRange = null;\n    let nextChar = \"\";\n\n    if (!this.isContentEditable(context.element)) {\n      const textComponent = this.tribute.current.element;\n      if (textComponent) {\n        const startPos = textComponent.selectionStart;\n        const endPos = textComponent.selectionEnd;\n\n        if (textComponent.value && startPos >= 0 && startPos === endPos) {\n          const result = this.getWholeWordsUpToCharIndex(\n            textComponent.value,\n            startPos\n          );\n          effectiveRange = result[0];\n          nextChar = result[1];\n        }\n      }\n    } else {\n      const { sel, range, direction } =\n        this.getContentEditableSelectionStart(true);\n      if (sel) {\n        const selectedElem = sel.anchorNode;\n        const workingNodeContent = selectedElem.textContent;\n        const selectStartOffset = sel.getRangeAt(0).startOffset;\n        const lastChar = workingNodeContent[Math.max(0, selectStartOffset - 1)];\n        const addWhiteSpace = lastChar && lastChar !== lastChar.trim();\n        effectiveRange = sel.toString().trim();\n        nextChar =\n          workingNodeContent.length > selectStartOffset\n            ? workingNodeContent[selectStartOffset]\n            : \"\";\n\n        for (\n          let index = 0;\n          index < this.tribute.numberOfWordsInContextText;\n          index++\n        ) {\n          sel.modify(\"extend\", \"backward\", \"word\");\n          const newText = sel.toString().trim();\n          if (\n            newText.length > effectiveRange.length &&\n            newText.endsWith(effectiveRange)\n          ) {\n            // Workarounds Firefox issue, where selection sometimes collapse or move instead of extend\n            effectiveRange = newText;\n          }\n        }\n        effectiveRange += addWhiteSpace ? \" \" : \"\";\n\n        this.restoreSelection(sel, range, direction);\n      }\n    }\n\n    return { effectiveRange, nextChar };\n  }\n\n  getLastWordInText(text) {\n    if (this.tribute.autocompleteSeparator) {\n      const wordsArray = text.split(this.tribute.autocompleteSeparator);\n      if (!wordsArray.length) return \" \";\n      return wordsArray[wordsArray.length - 1];\n    }\n    return text;\n  }\n\n  getTriggerInfo(allowSpaces, isAutocomplete) {\n    let requireLeadingSpace = true;\n    const { effectiveRange, nextChar } = this.getTextForCurrentSelection();\n    if (effectiveRange === null) return null;\n    const lastWordOfEffectiveRange = this.getLastWordInText(effectiveRange);\n\n    if (isAutocomplete) {\n      return {\n        mentionPosition:\n          effectiveRange.length - lastWordOfEffectiveRange.length,\n        mentionText: lastWordOfEffectiveRange,\n        fullText: effectiveRange,\n        nextChar: nextChar,\n        mentionTriggerChar: \"\",\n      };\n    }\n\n    if (effectiveRange !== undefined && effectiveRange !== null) {\n      let mostRecentTriggerCharPos = -1;\n      let triggerChar;\n\n      this.tribute.collection.forEach((config) => {\n        const c = config.trigger;\n        const idx = config.requireLeadingSpace\n          ? this.lastIndexWithLeadingSpace(effectiveRange, c)\n          : effectiveRange.lastIndexOf(c);\n\n        if (idx > mostRecentTriggerCharPos) {\n          mostRecentTriggerCharPos = idx;\n          triggerChar = c;\n          requireLeadingSpace = config.requireLeadingSpace;\n        }\n      });\n\n      if (\n        mostRecentTriggerCharPos >= 0 &&\n        (mostRecentTriggerCharPos === 0 ||\n          !requireLeadingSpace ||\n          /\\s/.test(\n            effectiveRange.substring(\n              mostRecentTriggerCharPos - 1,\n              mostRecentTriggerCharPos\n            )\n          ))\n      ) {\n        const currentTriggerSnippet = effectiveRange.substring(\n          mostRecentTriggerCharPos + triggerChar.length,\n          effectiveRange.length\n        );\n\n        triggerChar = effectiveRange.substring(\n          mostRecentTriggerCharPos,\n          mostRecentTriggerCharPos + triggerChar.length\n        );\n        const firstSnippetChar = currentTriggerSnippet.substring(0, 1);\n        const leadingSpace =\n          currentTriggerSnippet.length > 0 &&\n          (firstSnippetChar === \" \" || firstSnippetChar === \"\\xA0\");\n\n        const trailingSpace =\n          currentTriggerSnippet !== currentTriggerSnippet.trimEnd();\n\n        if (!leadingSpace && (allowSpaces || !trailingSpace)) {\n          return {\n            mentionPosition: mostRecentTriggerCharPos,\n            mentionText: currentTriggerSnippet,\n            mentionTriggerChar: triggerChar,\n            fullText: effectiveRange,\n            nextChar: \"\",\n          };\n        }\n      }\n    }\n  }\n\n  lastIndexWithLeadingSpace(str, trigger) {\n    const reversedStr = str.split(\"\").reverse().join(\"\");\n    let index = -1;\n\n    for (let cidx = 0, len = str.length; cidx < len; cidx++) {\n      const firstChar = cidx === str.length - 1;\n      const leadingSpace = /\\s/.test(reversedStr[cidx + 1]);\n\n      let match = true;\n      for (let triggerIdx = trigger.length - 1; triggerIdx >= 0; triggerIdx--) {\n        if (trigger[triggerIdx] !== reversedStr[cidx - triggerIdx]) {\n          match = false;\n          break;\n        }\n      }\n\n      if (match && (firstChar || leadingSpace)) {\n        index = str.length - 1 - cidx;\n        break;\n      }\n    }\n\n    return index;\n  }\n\n  isContentEditable(element) {\n    return element.nodeName !== \"INPUT\" && element.nodeName !== \"TEXTAREA\";\n  }\n\n  isMenuOffScreen(coordinates, menuDimensions) {\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    const doc = this.getDocument().documentElement;\n    const windowLeft =\n      (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n    const windowTop =\n      (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n\n    const menuTop =\n      typeof coordinates.top === \"number\"\n        ? coordinates.top\n        : coordinates.bottom - menuDimensions.height;\n    const menuRight =\n      typeof coordinates.right === \"number\"\n        ? coordinates.right\n        : coordinates.left + menuDimensions.width;\n    const menuBottom =\n      typeof coordinates.bottom === \"number\"\n        ? coordinates.bottom\n        : coordinates.top + menuDimensions.height;\n    const menuLeft =\n      typeof coordinates.left === \"number\"\n        ? coordinates.left\n        : coordinates.right - menuDimensions.width;\n\n    return {\n      top: menuTop < Math.floor(windowTop),\n      right: menuRight > Math.ceil(windowLeft + windowWidth),\n      bottom: menuBottom > Math.ceil(windowTop + windowHeight),\n      left: menuLeft < Math.floor(windowLeft),\n    };\n  }\n\n  getMenuDimensions() {\n    // Width of the menu depends of its contents and position\n    // We must check what its width would be without any obstruction\n    // This way, we can achieve good positioning for flipping the menu\n    const dimensions = {\n      width: null,\n      height: null,\n    };\n\n    this.tribute.menu.style.top = `0px`;\n    this.tribute.menu.style.left = `0px`;\n    this.tribute.menu.style.right = null;\n    this.tribute.menu.style.bottom = null;\n    this.tribute.menu.style.position = `fixed`;\n    this.tribute.menu.style.visibility = `hidden`;\n    this.tribute.menu.style.display = `block`;\n\n    dimensions.width = this.tribute.menu.offsetWidth;\n    dimensions.height = this.tribute.menu.offsetHeight;\n\n    this.tribute.menu.style.display = `none`;\n    this.tribute.menu.style.visibility = `visible`;\n\n    return dimensions;\n  }\n\n  getTextAreaOrInputUnderlinePosition(element, position, _flipped) {\n    const properties = [\n      \"direction\",\n      \"boxSizing\",\n      \"width\",\n      \"height\",\n      \"overflowX\",\n      \"overflowY\",\n      \"borderTopWidth\",\n      \"borderRightWidth\",\n      \"borderBottomWidth\",\n      \"borderLeftWidth\",\n      \"borderStyle\",\n      \"paddingTop\",\n      \"paddingRight\",\n      \"paddingBottom\",\n      \"paddingLeft\",\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSize\",\n      \"fontSizeAdjust\",\n      \"lineHeight\",\n      \"fontFamily\",\n      \"textAlign\",\n      \"textTransform\",\n      \"textIndent\",\n      \"textDecoration\",\n      \"letterSpacing\",\n      \"wordSpacing\",\n    ];\n\n    const div = this.getDocument().createElement(\"div\");\n    div.id = \"input-textarea-caret-position-mirror-div\";\n    this.getDocument().body.appendChild(div);\n\n    const style = div.style;\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n\n    style.whiteSpace = \"pre-wrap\";\n    if (element.nodeName !== \"INPUT\") {\n      style.wordWrap = \"break-word\";\n    }\n\n    // position off-screen\n    style.position = \"absolute\";\n    style.visibility = \"hidden\";\n\n    // transfer the element's properties to the div\n    properties.forEach((prop) => {\n      style[prop] = computed[prop];\n    });\n\n    const span0 = this.getDocument().createElement(\"span\");\n    span0.textContent = element.value.substring(0, position);\n    div.appendChild(span0);\n\n    if (element.nodeName === \"INPUT\") {\n      div.textContent = div.textContent.replace(/\\s/g, \" \");\n    }\n\n    //Create a span in the div that represents where the cursor\n    //should be\n    const span = this.getDocument().createElement(\"span\");\n    //we give it no content as this represents the cursor\n    div.appendChild(span);\n\n    const span2 = this.getDocument().createElement(\"span\");\n    span2.textContent = element.value.substring(position, position + 1);\n    div.appendChild(span2);\n\n    const rect = element.getBoundingClientRect();\n\n    //position the div exactly over the element\n    //so we can get the bounding client rect for the span and\n    //it should represent exactly where the cursor is\n    div.style.position = \"fixed\";\n    div.style.left = rect.left + \"px\";\n    div.style.top = rect.top + \"px\";\n    div.style.width = rect.width + \"px\";\n    div.style.height = rect.height + \"px\";\n    div.scrollTop = element.scrollTop;\n\n    const spanRect = span.getBoundingClientRect();\n    const divRect = div.getBoundingClientRect();\n    this.getDocument().body.removeChild(div);\n    const clamp = function (number, min, max) {\n      return Math.max(min, Math.min(number, max));\n    };\n    const finalRect = {\n      height: Math.min(divRect.height, spanRect.height),\n      left: clamp(spanRect.left, divRect.left, divRect.left + divRect.width),\n      top: clamp(spanRect.top, divRect.top, divRect.top + divRect.height),\n    };\n    return this.getFixedCoordinatesRelativeToRect(finalRect);\n  }\n\n  getContentEditableCaretPosition(_selectedNodePosition) {\n    const { sel, range, direction } =\n      this.getContentEditableSelectionStart(false);\n    const newRange = sel.getRangeAt(0);\n    // restore selection\n    this.restoreSelection(sel, range, direction);\n    let rect = newRange.getBoundingClientRect();\n    if (sel.anchorNode.parentNode) {\n      const parentNodeRect = sel.anchorNode.parentNode.getBoundingClientRect();\n      const clamp = function (number, min, max) {\n        return Math.max(min, Math.min(number, max));\n      };\n      rect = {\n        height: Math.min(parentNodeRect.height, rect.height),\n        left: clamp(\n          rect.left,\n          parentNodeRect.left,\n          parentNodeRect.left + parentNodeRect.width\n        ),\n        top: clamp(\n          rect.top,\n          parentNodeRect.top,\n          parentNodeRect.top + parentNodeRect.height\n        ),\n      };\n    }\n    return this.getFixedCoordinatesRelativeToRect(rect);\n  }\n\n  getFixedCoordinatesRelativeToRect(rect) {\n    const coordinates = {\n      position: \"fixed\",\n      left: rect.left,\n      top: rect.top + rect.height,\n    };\n\n    const menuDimensions = this.getMenuDimensions();\n\n    const availableSpaceOnTop = rect.top;\n    const availableSpaceOnBottom =\n      window.innerHeight - (rect.top + rect.height);\n\n    //check to see where's the right place to put the menu vertically\n    if (availableSpaceOnBottom < menuDimensions.height) {\n      if (\n        availableSpaceOnTop >= menuDimensions.height ||\n        availableSpaceOnTop > availableSpaceOnBottom\n      ) {\n        coordinates.top = \"auto\";\n        coordinates.bottom = window.innerHeight - rect.top;\n        if (availableSpaceOnBottom < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnTop;\n        }\n      } else {\n        if (availableSpaceOnTop < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnBottom;\n        }\n      }\n    }\n\n    const availableSpaceOnLeft = rect.left;\n    const availableSpaceOnRight = window.innerWidth - rect.left;\n\n    //check to see where's the right place to put the menu horizontally\n    if (availableSpaceOnRight < menuDimensions.width) {\n      if (\n        availableSpaceOnLeft >= menuDimensions.width ||\n        availableSpaceOnLeft > availableSpaceOnRight\n      ) {\n        coordinates.left = \"auto\";\n        coordinates.right = window.innerWidth - rect.left;\n        if (availableSpaceOnRight < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnLeft;\n        }\n      } else {\n        if (availableSpaceOnLeft < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnRight;\n        }\n      }\n    }\n\n    return coordinates;\n  }\n\n  scrollIntoView(_elem) {\n    const reasonableBuffer = 20;\n    const maxScrollDisplacement = 100;\n    let clientRect;\n    let e = this.menu;\n\n    if (typeof e === \"undefined\") return;\n\n    while (clientRect === undefined || clientRect.height === 0) {\n      clientRect = e.getBoundingClientRect();\n\n      if (clientRect.height === 0) {\n        e = e.childNodes[0];\n        if (e === undefined || !e.getBoundingClientRect) {\n          return;\n        }\n      }\n    }\n\n    const elemTop = clientRect.top;\n    const elemBottom = elemTop + clientRect.height;\n\n    if (elemTop < 0) {\n      window.scrollTo(\n        0,\n        window.pageYOffset + clientRect.top - reasonableBuffer\n      );\n    } else if (elemBottom > window.innerHeight) {\n      let maxY = window.pageYOffset + clientRect.top - reasonableBuffer;\n\n      if (maxY - window.pageYOffset > maxScrollDisplacement) {\n        maxY = window.pageYOffset + maxScrollDisplacement;\n      }\n\n      let targetY = window.pageYOffset - (window.innerHeight - elemBottom);\n\n      if (targetY > maxY) {\n        targetY = maxY;\n      }\n\n      window.scrollTo(0, targetY);\n    }\n  }\n\n  restoreSelection(sel, range, directionFwd = true) {\n    sel.removeAllRanges();\n\n    if (directionFwd) {\n      sel.addRange(range);\n    } else {\n      const endRange = range.cloneRange();\n      endRange.collapse(false);\n      sel.addRange(endRange);\n      sel.extend(range.startContainer, range.startOffset);\n    }\n  }\n}\n\nexport default TributeRange;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/mattyork/fuzzy\nclass TributeSearch {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.search = this;\n  }\n\n  simpleFilter(pattern, array) {\n    return array.filter((string) => {\n      return this.test(pattern, string);\n    });\n  }\n\n  test(pattern, string) {\n    return this.match(pattern, string) !== null;\n  }\n\n  match(pattern, string, opts) {\n    opts = opts || {};\n    const pre = opts.pre || \"\",\n      post = opts.post || \"\",\n      compareString = (opts.caseSensitive && string) || string.toLowerCase();\n\n    if (opts.skip) {\n      return { rendered: string, score: 0 };\n    }\n\n    pattern = (opts.caseSensitive && pattern) || pattern.toLowerCase();\n\n    const patternCache = this.traverse(compareString, pattern, 0, 0, []);\n    if (!patternCache) {\n      return null;\n    }\n    return {\n      rendered: this.render(string, patternCache.cache, pre, post),\n      score: patternCache.score,\n    };\n  }\n\n  traverse(string, pattern, stringIndex, patternIndex, patternCache) {\n    if (this.tribute.autocompleteMode && this.tribute.autocompleteSeparator) {\n      // if the pattern search at end\n      pattern = pattern.split(this.tribute.autocompleteSeparator).splice(-1)[0];\n    }\n\n    if (pattern.length === patternIndex) {\n      // calculate score and copy the cache containing the indices where it's found\n      return {\n        score: this.calculateScore(patternCache),\n        cache: patternCache.slice(),\n      };\n    }\n\n    // if string at end or remaining pattern > remaining string\n    if (\n      string.length === stringIndex ||\n      pattern.length - patternIndex > string.length - stringIndex\n    ) {\n      return undefined;\n    }\n\n    const c = pattern[patternIndex];\n    let index = string.indexOf(c, stringIndex);\n    let best;\n    let temp;\n\n    while (index > -1) {\n      patternCache.push(index);\n      temp = this.traverse(\n        string,\n        pattern,\n        index + 1,\n        patternIndex + 1,\n        patternCache\n      );\n      patternCache.pop();\n\n      // if downstream traversal failed, return best answer so far\n      if (!temp) {\n        return best;\n      }\n\n      if (!best || best.score < temp.score) {\n        best = temp;\n      }\n\n      index = string.indexOf(c, index + 1);\n    }\n\n    return best;\n  }\n\n  calculateScore(patternCache) {\n    let score = 0;\n    let temp = 1;\n\n    patternCache.forEach((index, i) => {\n      if (i > 0) {\n        if (patternCache[i - 1] + 1 === index) {\n          temp += temp + 1;\n        } else {\n          temp = 1;\n        }\n      }\n\n      score += temp;\n    });\n\n    return score;\n  }\n\n  render(string, indices, pre, post) {\n    let rendered = string.substring(0, indices[0]);\n\n    indices.forEach((index, i) => {\n      rendered +=\n        pre +\n        string[index] +\n        post +\n        string.substring(\n          index + 1,\n          indices[i + 1] ? indices[i + 1] : string.length\n        );\n    });\n\n    return rendered;\n  }\n\n  filter(pattern, arr, opts) {\n    opts = opts || {};\n    return arr\n      .reduce((prev, element, idx, _arr) => {\n        let str = element;\n\n        if (opts.extract) {\n          str = opts.extract(element);\n\n          if (!str) {\n            // take care of undefineds / nulls / etc.\n            str = \"\";\n          }\n        }\n\n        const rendered = this.match(pattern, str, opts);\n\n        if (rendered !== null) {\n          prev[prev.length] = {\n            string: rendered.rendered,\n            score: rendered.score,\n            index: idx,\n            original: element,\n          };\n        }\n\n        return prev;\n      }, [])\n\n      .sort((a, b) => {\n        const compare = b.score - a.score;\n        if (compare) return compare;\n        return a.index - b.index;\n      });\n  }\n}\n\nexport default TributeSearch;\n","import TributeEvents from \"./TributeEvents\";\nimport TributeMenuEvents from \"./TributeMenuEvents\";\nimport TributeRange from \"./TributeRange\";\nimport TributeSearch from \"./TributeSearch\";\n\nclass Tribute {\n  constructor({\n    values = null,\n    loadingItemTemplate = null,\n    iframe = null,\n    selectClass = \"highlight\",\n    containerClass = \"tribute-container\",\n    itemClass = \"\",\n    trigger = \"@\",\n    autocompleteMode = false,\n    autocompleteSeparator = RegExp(/\\s+/),\n    selectTemplate = null,\n    menuItemTemplate = null,\n    lookup = \"key\",\n    fillAttr = \"value\",\n    collection = null,\n    menuContainer = null,\n    noMatchTemplate = null,\n    requireLeadingSpace = true,\n    allowSpaces = false,\n    replaceTextSuffix = null,\n    positionMenu = true,\n    spaceSelectsMatch = false,\n    searchOpts = {},\n    menuItemLimit = null,\n    menuShowMinLength = 0,\n    keys = null,\n    numberOfWordsInContextText = 5,\n  }) {\n    this.autocompleteMode = autocompleteMode;\n    this.autocompleteSeparator = autocompleteSeparator;\n    this.menuSelected = 0;\n    this.current = {};\n    this.isActive = false;\n    this.activationPending = false;\n    this.menuContainer = menuContainer;\n    this.allowSpaces = allowSpaces;\n    this.replaceTextSuffix = replaceTextSuffix;\n    this.positionMenu = positionMenu;\n    this.spaceSelectsMatch = spaceSelectsMatch;\n    this.numberOfWordsInContextText = numberOfWordsInContextText;\n    if (keys) {\n      TributeEvents.keys = keys;\n    }\n\n    if (this.autocompleteMode) {\n      trigger = \"\";\n      allowSpaces = false;\n    }\n\n    if (values) {\n      this.collection = [\n        {\n          // symbol that starts the lookup\n          trigger: trigger,\n\n          // is it wrapped in an iframe\n          iframe: iframe,\n\n          // class applied to selected item\n          selectClass: selectClass,\n\n          // class applied to the Container\n          containerClass: containerClass,\n\n          // class applied to each item\n          itemClass: itemClass,\n\n          // function called on select that retuns the content to insert\n          selectTemplate: (\n            selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n\n          // function called that returns content for an item\n          menuItemTemplate: (\n            menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n\n          // column to search against in the object\n          lookup: lookup,\n\n          // column that contains the content to insert by default\n          fillAttr: fillAttr,\n\n          // array of objects or a function returning an array of objects\n          values: values,\n\n          // useful for when values is an async function\n          loadingItemTemplate: loadingItemTemplate,\n\n          requireLeadingSpace: requireLeadingSpace,\n\n          searchOpts: searchOpts,\n\n          menuItemLimit: menuItemLimit,\n\n          menuShowMinLength: menuShowMinLength,\n        },\n      ];\n    } else if (collection) {\n      if (this.autocompleteMode)\n        console.warn(\n          \"Tribute in autocomplete mode does not work for collections\"\n        );\n      this.collection = collection.map((item) => {\n        return {\n          trigger: item.trigger || trigger,\n          iframe: item.iframe || iframe,\n          selectClass: item.selectClass || selectClass,\n          containerClass: item.containerClass || containerClass,\n          itemClass: item.itemClass || itemClass,\n          selectTemplate: (\n            item.selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n          menuItemTemplate: (\n            item.menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n          lookup: item.lookup || lookup,\n          fillAttr: item.fillAttr || fillAttr,\n          values: item.values,\n          loadingItemTemplate: item.loadingItemTemplate,\n          requireLeadingSpace: item.requireLeadingSpace,\n          searchOpts: item.searchOpts || searchOpts,\n          menuItemLimit: item.menuItemLimit || menuItemLimit,\n          menuShowMinLength: item.menuShowMinLength || menuShowMinLength,\n        };\n      });\n    } else {\n      throw new Error(\"[Tribute] No collection specified.\");\n    }\n\n    new TributeRange(this);\n    new TributeEvents(this);\n    new TributeMenuEvents(this);\n    new TributeSearch(this);\n  }\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  set isActive(val) {\n    if (this._isActive !== val) {\n      this._isActive = val;\n      if (this.current.element) {\n        const noMatchEvent = new CustomEvent(`tribute-active-${val}`);\n        this.current.element.dispatchEvent(noMatchEvent);\n      }\n    }\n  }\n\n  static defaultSelectTemplate(item) {\n    if (typeof item === \"undefined\")\n      return `${this.current.collection.trigger}${this.current.mentionText}`;\n    if (this.range.isContentEditable(this.current.element)) {\n      return (\n        '<span class=\"tribute-mention\">' +\n        (this.current.collection.trigger +\n          item.original[this.current.collection.fillAttr]) +\n        \"</span>\"\n      );\n    }\n\n    return (\n      this.current.collection.trigger +\n      item.original[this.current.collection.fillAttr]\n    );\n  }\n\n  static defaultMenuItemTemplate(matchItem) {\n    return matchItem.string;\n  }\n\n  static inputTypes() {\n    return [\"TEXTAREA\", \"INPUT\"];\n  }\n\n  triggers() {\n    return this.collection.map((config) => {\n      return config.trigger;\n    });\n  }\n\n  attach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    /* global jQuery */\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._attach(el[i]);\n      }\n    } else {\n      this._attach(el);\n    }\n  }\n\n  _attach(el) {\n    if (el.hasAttribute(\"data-tribute\")) {\n      console.warn(\"Tribute was already bound to \" + el.nodeName);\n    }\n\n    this.ensureEditable(el);\n    this.events.bind(el);\n    el.setAttribute(\"data-tribute\", true);\n  }\n\n  ensureEditable(element) {\n    if (Tribute.inputTypes().indexOf(element.nodeName) === -1) {\n      if (element.contentEditable) {\n        element.contentEditable = true;\n      } else {\n        throw new Error(\"[Tribute] Cannot bind to \" + element.nodeName);\n      }\n    }\n  }\n\n  createMenu(containerClass, element) {\n    const properties = [\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSizeAdjust\",\n      \"fontFamily\",\n    ];\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n    const wrapper = this.range.getDocument().createElement(\"div\"),\n      ul = this.range.getDocument().createElement(\"ul\");\n    wrapper.className = containerClass;\n    wrapper.setAttribute(\"tabindex\", \"0\");\n    wrapper.appendChild(ul);\n    wrapper.style.fontSize =\n      Math.round(parseInt(computed.fontSize) * 0.9) + \"px\";\n    wrapper.style.display = \"none\";\n\n    properties.forEach((prop) => {\n      wrapper.style[prop] = computed[prop];\n    });\n\n    if (this.menuContainer) {\n      return this.menuContainer.appendChild(wrapper);\n    }\n\n    return this.range.getDocument().body.appendChild(wrapper);\n  }\n\n  showMenuFor(element, scrollTo) {\n    // Only proceed if menu isn't already shown for the current element & mentionText\n    if (\n      this.isActive &&\n      this.current.element === element &&\n      this.current.mentionText === this.currentMentionTextSnapshot\n    ) {\n      return;\n    }\n    this.currentMentionTextSnapshot = this.current.mentionText;\n\n    // create the menu if it doesn't exist.\n    if (!this.menu) {\n      this.menu = this.createMenu(\n        this.current.collection.containerClass,\n        element\n      );\n      element.tributeMenu = this.menu;\n      this.menuEvents.bind(this.menu);\n    }\n\n    this.activationPending = true;\n    this.menuSelected = 0;\n\n    if (!this.current.mentionText) {\n      this.current.mentionText = \"\";\n    }\n\n    const processValues = (values, forceReplace) => {\n      // Tribute may not be active any more by the time the value callback returns\n      if (!this.activationPending) {\n        return;\n      }\n      this.activationPending = false;\n      // Element is no longer in focus - don't show menu\n      if (this.range.getDocument().activeElement !== this.current.element) {\n        return;\n      }\n\n      if (forceReplace) {\n        // Do force replace - don't show menu\n        this.current.mentionPosition -= forceReplace.length;\n        this.current.mentionText =\n          \" \".repeat(forceReplace.length) + this.current.mentionText;\n        this.replaceText(forceReplace.text, null, null);\n        return;\n      }\n\n      let items = this.search.filter(this.current.mentionText, values, {\n        pre: this.current.collection.searchOpts.pre || \"<span>\",\n        post: this.current.collection.searchOpts.post || \"</span>\",\n        skip: this.current.collection.searchOpts.skip || false,\n        caseSensitive:\n          this.current.collection.searchOpts.caseSensitive || false,\n        extract: (el) => {\n          if (typeof this.current.collection.lookup === \"string\") {\n            return el[this.current.collection.lookup];\n          } else if (typeof this.current.collection.lookup === \"function\") {\n            return this.current.collection.lookup(el, this.current.mentionText);\n          } else {\n            throw new Error(\n              \"Invalid lookup attribute, lookup must be string or function.\"\n            );\n          }\n        },\n      });\n\n      if (this.current.collection.menuItemLimit) {\n        items = items.slice(0, this.current.collection.menuItemLimit);\n      }\n\n      this.current.filteredItems = items;\n\n      const ul = this.menu.querySelector(\"ul\");\n      let showMenu = false;\n\n      if (!items.length) {\n        const noMatchEvent = new CustomEvent(\"tribute-no-match\", {\n          detail: this.menu,\n        });\n        this.current.element.dispatchEvent(noMatchEvent);\n        if (\n          (typeof this.current.collection.noMatchTemplate === \"function\" &&\n            !this.current.collection.noMatchTemplate()) ||\n          !this.current.collection.noMatchTemplate\n        ) {\n          showMenu = false;\n        } else {\n          typeof this.current.collection.noMatchTemplate === \"function\"\n            ? (ul.innerHTML = this.current.collection.noMatchTemplate())\n            : (ul.innerHTML = this.current.collection.noMatchTemplate);\n          showMenu = true;\n        }\n      } else {\n        ul.innerHTML = \"\";\n        const fragment = this.range.getDocument().createDocumentFragment();\n\n        items.forEach((item, index) => {\n          const li = this.range.getDocument().createElement(\"li\");\n          li.setAttribute(\"data-index\", index);\n          li.className = this.current.collection.itemClass;\n          li.addEventListener(\n            \"mouseover\",\n            function (index) {\n              this.events.setActiveLi(index);\n            }.bind(this, index)\n          );\n\n          if (this.menuSelected === index) {\n            li.classList.add(this.current.collection.selectClass);\n          }\n          li.innerHTML = this.current.collection.menuItemTemplate(item);\n          fragment.appendChild(li);\n        });\n        ul.appendChild(fragment);\n        showMenu = true;\n      }\n      if (showMenu) {\n        this.isActive = true;\n        this.range.positionMenuAtCaret(scrollTo);\n      }\n    };\n\n    if (typeof this.current.collection.values === \"function\") {\n      if (this.current.collection.loadingItemTemplate) {\n        this.menu.querySelector(\"ul\").innerHTML =\n          this.current.collection.loadingItemTemplate;\n        this.range.positionMenuAtCaret(scrollTo);\n      }\n\n      this.current.collection.values(\n        this.current.mentionText,\n        processValues,\n        this.current.fullText,\n        this.current.nextChar\n      );\n    } else {\n      processValues(this.current.collection.values);\n    }\n  }\n\n  showMenuForCollection(element, collectionIndex) {\n    if (!this.events.updateSelection(element)) return;\n    if (element !== this.range.getDocument().activeElement) {\n      this.placeCaretAtEnd(element);\n      if (element.isContentEditable)\n        this.insertTextAtCursor(this.current.collection.trigger);\n      else this.insertAtCaret(element, this.current.collection.trigger);\n    }\n\n    this.current.collection = this.collection[collectionIndex || 0];\n    this.current.element = element;\n\n    this.showMenuFor(element);\n  }\n\n  // TODO: make sure this works for inputs/textareas\n  placeCaretAtEnd(el) {\n    el.focus();\n    if (\n      typeof window.getSelection !== \"undefined\" &&\n      typeof this.range.getDocument().createRange !== \"undefined\"\n    ) {\n      const range = this.range.getDocument().createRange();\n      range.selectNodeContents(el);\n      range.collapse(false);\n      const sel = window.getSelection();\n      sel.removeAllRanges();\n      sel.addRange(range);\n    } else if (\n      typeof this.range.getDocument().body.createTextRange !== \"undefined\"\n    ) {\n      const textRange = this.range.getDocument().body.createTextRange();\n      textRange.moveToElementText(el);\n      textRange.collapse(false);\n      textRange.select();\n    }\n  }\n\n  // for contenteditable\n  insertTextAtCursor(text) {\n    const sel = window.getSelection();\n    const range = sel.getRangeAt(0);\n    range.deleteContents();\n    const textNode = this.range.getDocument().createTextNode(text);\n    range.insertNode(textNode);\n    range.selectNodeContents(textNode);\n    range.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n\n  // for regular inputs\n  insertAtCaret(textarea, text) {\n    const scrollPos = textarea.scrollTop;\n    let caretPos = textarea.selectionStart;\n\n    const front = textarea.value.substring(0, caretPos);\n    const back = textarea.value.substring(\n      textarea.selectionEnd,\n      textarea.value.length\n    );\n    textarea.value = front + text + back;\n    caretPos = caretPos + text.length;\n    textarea.selectionStart = caretPos;\n    textarea.selectionEnd = caretPos;\n    textarea.focus();\n    textarea.scrollTop = scrollPos;\n  }\n\n  hideMenu() {\n    if (this.menu) {\n      this.menu.remove();\n      this.menu = null;\n    }\n    this.isActive = false;\n    this.activationPending = false;\n    this.current = {};\n  }\n\n  selectItemAtIndex(index, originalEvent) {\n    index = parseInt(index);\n    if (!(typeof index !== \"number\" || isNaN(index) || !originalEvent.target)) {\n      const item = this.current.filteredItems[index];\n      const content = this.current.collection.selectTemplate(item);\n      if (content !== null) this.replaceText(content, originalEvent, item);\n    }\n    this.hideMenu();\n  }\n\n  replaceText(content, originalEvent, item) {\n    this.range.replaceTriggerText(content, originalEvent, item);\n  }\n\n  _append(collection, newValues, replace) {\n    if (typeof collection.values === \"function\") {\n      throw new Error(\"Unable to append to values, as it is a function.\");\n    } else if (!replace) {\n      collection.values = collection.values.concat(newValues);\n    } else {\n      collection.values = newValues;\n    }\n  }\n\n  append(collectionIndex, newValues, replace) {\n    const index = parseInt(collectionIndex);\n    if (typeof index !== \"number\")\n      throw new Error(\"please provide an index for the collection to update.\");\n\n    const collection = this.collection[index];\n\n    this._append(collection, newValues, replace);\n  }\n\n  appendCurrent(newValues, replace) {\n    if (this.isActive) {\n      this._append(this.current.collection, newValues, replace);\n    } else {\n      throw new Error(\n        \"No active state. Please use append instead and pass an index.\"\n      );\n    }\n  }\n\n  detach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._detach(el[i]);\n      }\n    } else {\n      this._detach(el);\n    }\n  }\n\n  _detach(el) {\n    this.events.unbind(el);\n    if (el.tributeMenu) {\n      this.menuEvents.unbind(el.tributeMenu);\n    }\n\n    setTimeout(() => {\n      el.removeAttribute(\"data-tribute\");\n      this.isActive = false;\n      if (el.tributeMenu) {\n        el.tributeMenu.remove();\n      }\n    });\n  }\n\n  debounce(func, wait, option = { leading: true, trailing: true }) {\n    let timer = null;\n    return (...args) => {\n      const timerExpired = (callFunc) => {\n        timer = null;\n        if (callFunc) func.apply(this, args);\n      };\n      const callNow = option.leading && timer === null;\n      const timeoutFn = timerExpired.bind(this, !callNow && option.trailing);\n      clearTimeout(timer);\n      timer = setTimeout(timeoutFn, wait);\n      if (callNow) func.apply(this, args);\n    };\n  }\n}\n\nexport default Tribute;\n"],"names":["TributeEvents","constructor","tribute","events","this","bind","element","boundKeyDown","debounce","keydown","boundKeyUpInput","input","addEventListener","unbind","removeEventListener","instance","event","controlKeyPressed","keyProcessed","KeyboardEvent","modifiers","forEach","o","getModifierState","isActive","keys","key","code","callbacks","hideMenu","CustomEvent","keyup","call","click","menu","contains","target","li","preventDefault","stopImmediatePropagation","nodeName","toLowerCase","parentNode","Error","selectItemAtIndex","getAttribute","length","updateSelection","keyCode","getKeyCode","isNaN","autocompleteMode","current","collection","trigger","triggers","find","charCodeAt","item","menuShowMinLength","mentionText","showMenuFor","which","mentionTriggerChar","NaN","el","info","range","getTriggerInfo","allowSpaces","mentionPosition","fullText","nextChar","Enter","e","_el","filteredItems","menuSelected","Escape","Tab","Space","spaceSelectsMatch","ArrowUp","count","selected","setActiveLi","scrollTop","scrollHeight","ArrowDown","index","lis","querySelectorAll","i","classList","add","selectClass","liClientRect","getBoundingClientRect","menuClientRect","bottom","scrollDistance","top","remove","getFullHeight","elem","includeMargin","height","style","currentStyle","window","getComputedStyle","parseFloat","marginTop","marginBottom","TributeMenuEvents","menuEvents","_menu","menuClickEvent","menuContainerScrollEvent","windowResizeEvent","windowBlurEvent","getDocument","menuContainer","TributeRange","iframe","contentWindow","document","positionMenuAtCaret","scrollTo","context","coordinates","positionMenu","isContentEditable","getContentEditableCaretPosition","getTextAreaOrInputUnderlinePosition","left","right","maxHeight","maxWidth","position","display","scrollIntoView","body","replaceTriggerText","text","originalEvent","detail","replaceEvent","replaceTextSuffix","pasteContentEditable","myField","textSuffix","stripHtml","startPos","endPos","value","substring","selectionStart","selectionEnd","dispatchEvent","bubbles","html","numOfCharsToRemove","sel","getContentEditableSelectionStart","strippedText","anchorOffset","anchorNode","nodeValue","pasteText","pasteHtml","pre","post","setStart","collapse","removeAllRanges","addRange","collapseToEnd","_range","modify","newRange","getRangeAt","deleteContents","createElement","innerHTML","frag","createDocumentFragment","node","lastNode","firstChild","appendChild","insertNode","setEnd","tmp","textContent","innerText","getWindowSelection","getSelection","rootNode","getRootNode","moveToEndOfWord","isCollapsed","direction","focusOffset","selectedElem","workingNodeContent","selectStartOffset","startOffset","nextSibling","nextNodeText","nextCharIsSeparator","autocompleteSeparator","match","getWholeWordsUpToCharIndex","str","minLen","searchPos","arr","split","filter","trim","len","idx","indexOf","getTextForCurrentSelection","effectiveRange","lastChar","Math","max","addWhiteSpace","toString","numberOfWordsInContextText","newText","endsWith","restoreSelection","textComponent","result","getLastWordInText","wordsArray","isAutocomplete","requireLeadingSpace","lastWordOfEffectiveRange","triggerChar","mostRecentTriggerCharPos","config","c","lastIndexWithLeadingSpace","lastIndexOf","test","currentTriggerSnippet","firstSnippetChar","leadingSpace","trailingSpace","trimEnd","reversedStr","reverse","join","cidx","firstChar","triggerIdx","isMenuOffScreen","menuDimensions","windowWidth","innerWidth","windowHeight","innerHeight","doc","documentElement","windowLeft","pageXOffset","scrollLeft","clientLeft","windowTop","pageYOffset","clientTop","menuTop","menuRight","width","menuBottom","menuLeft","floor","ceil","getMenuDimensions","dimensions","visibility","offsetWidth","offsetHeight","_flipped","div","id","computed","whiteSpace","wordWrap","prop","span0","replace","span","span2","rect","spanRect","divRect","removeChild","clamp","number","min","finalRect","getFixedCoordinatesRelativeToRect","_selectedNodePosition","parentNodeRect","availableSpaceOnTop","availableSpaceOnBottom","availableSpaceOnLeft","availableSpaceOnRight","_elem","clientRect","undefined","childNodes","elemTop","elemBottom","maxY","targetY","directionFwd","endRange","cloneRange","extend","startContainer","TributeSearch","search","simpleFilter","pattern","array","string","opts","compareString","caseSensitive","skip","rendered","score","patternCache","traverse","render","cache","stringIndex","patternIndex","splice","calculateScore","slice","best","temp","push","pop","indices","reduce","prev","_arr","extract","original","sort","a","b","compare","Tribute","values","loadingItemTemplate","containerClass","itemClass","RegExp","selectTemplate","menuItemTemplate","lookup","fillAttr","noMatchTemplate","searchOpts","menuItemLimit","activationPending","defaultSelectTemplate","defaultMenuItemTemplate","t","console","warn","map","_isActive","val","noMatchEvent","matchItem","attach","jQuery","get","NodeList","HTMLCollection","Array","_attach","hasAttribute","ensureEditable","setAttribute","inputTypes","contentEditable","createMenu","wrapper","ul","className","fontSize","round","parseInt","currentMentionTextSnapshot","tributeMenu","processValues","forceReplace","activeElement","repeat","replaceText","items","querySelector","showMenu","fragment","showMenuForCollection","collectionIndex","placeCaretAtEnd","insertTextAtCursor","insertAtCaret","focus","createRange","selectNodeContents","createTextRange","textRange","moveToElementText","select","textNode","createTextNode","textarea","scrollPos","caretPos","front","back","content","_append","newValues","concat","append","appendCurrent","detach","_detach","setTimeout","removeAttribute","func","wait","option","leading","trailing","timer","args","callNow","timeoutFn","callFunc","apply","clearTimeout"],"mappings":"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"}