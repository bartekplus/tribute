{"version":3,"file":"tribute.min.js","sources":["../src/utils.js","../src/TributeEvents.js","../src/TributeMenuEvents.js","../src/TributeRange.js","../src/TributeSearch.js","../src/Tribute.js"],"sourcesContent":["if (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, \"find\", {\n    value: function (predicate) {\n      // 1. Let O be ? ToObject(this value).\n      if (this === null) {\n        throw TypeError('\"this\" is null or not defined');\n      }\n\n      const o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      const len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== \"function\") {\n        throw TypeError(\"predicate must be a function\");\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      const thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      let k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n        // d. If testResult is true, return kValue.\n        const kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return undefined.\n      return undefined;\n    },\n    configurable: true,\n    writable: true,\n  });\n}\n\nfunction CustomEvent(event, params) {\n  params = params || {\n    bubbles: false,\n    cancelable: false,\n    detail: undefined,\n  };\n  const evt = document.createEvent(\"CustomEvent\");\n  evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n  return evt;\n}\n\nif (typeof window !== \"undefined\" && typeof window.CustomEvent !== \"function\") {\n  if (typeof window.Event !== \"undefined\") {\n    CustomEvent.prototype = window.Event.prototype;\n  }\n\n  window.CustomEvent = CustomEvent;\n}\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\nclass TributeEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.events = this;\n  }\n\n  static keys() {\n    return [\"Tab\", \"Enter\", \"Escape\", \"ArrowUp\", \"ArrowDown\"];\n  }\n\n  static modifiers() {\n    return [\n      \"CapsLock\",\n      \"Control\",\n      \"Fn\",\n      \"Hyper\",\n      \"Meta\",\n      \"OS\",\n      \"Super\",\n      \"Symbol\",\n      \"Win\",\n    ];\n  }\n\n  bind(element) {\n    element.boundKeyDown = this.keydown.bind(element, this);\n    element.boundKeyUpInput = this.tribute.debounce(\n      this.input.bind(element, this),\n      16\n    );\n\n    element.addEventListener(\"keydown\", element.boundKeyDown, true);\n    element.addEventListener(\"keyup\", element.boundKeyUpInput, true);\n    element.addEventListener(\"input\", element.boundKeyUpInput, true);\n  }\n\n  unbind(element) {\n    element.removeEventListener(\"keydown\", element.boundKeyDown, true);\n    element.removeEventListener(\"keyup\", element.boundKeyUpInput, true);\n    element.removeEventListener(\"input\", element.boundKeyUpInput, true);\n\n    delete element.boundKeyDown;\n    delete element.boundKeyUpInput;\n  }\n\n  keydown(instance, event) {\n    if (instance.shouldDeactivate(event)) {\n      instance.tribute.hideMenu();\n    }\n    if (event instanceof KeyboardEvent) {\n      let controlKeyPressed = false;\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      if (controlKeyPressed) return;\n    }\n\n    if (instance.tribute.isActive) {\n      TributeEvents.keys().forEach((key) => {\n        if (key === event.code) {\n          instance.callbacks()[key](event, this);\n        }\n      });\n    }\n  }\n\n  input(instance, event) {\n    if (!(event instanceof CustomEvent)) {\n      instance.keyup.call(this, instance, event);\n    }\n  }\n\n  click(instance, event) {\n    const tribute = instance.tribute;\n    if (tribute.menu && tribute.menu.contains(event.target)) {\n      let li = event.target;\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      while (li.nodeName.toLowerCase() !== \"li\") {\n        li = li.parentNode;\n        if (!li || li === tribute.menu) {\n          throw new Error(\"cannot find the <li> container for the click\");\n        }\n      }\n\n      tribute.selectItemAtIndex(li.getAttribute(\"data-index\"), event);\n    } else {\n      tribute.hideMenu();\n    }\n  }\n\n  keyup(instance, event) {\n    // Check for modifiers keys\n    if (event instanceof KeyboardEvent) {\n      if (event.key && event.key.length > 1) {\n        // Not a Character exit early\n        return;\n      }\n\n      let controlKeyPressed = false;\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      // Check for control keys\n      TributeEvents.keys().forEach((key) => {\n        if (key === event.code) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      if (controlKeyPressed) return;\n    }\n\n    if (!instance.updateSelection(this)) return;\n\n    if (!instance.tribute.allowSpaces && instance.tribute.hasTrailingSpace) {\n      instance.tribute.hasTrailingSpace = false;\n      instance.callbacks().Space(event, this);\n      return;\n    }\n\n    const keyCode = instance.getKeyCode(event);\n    // Exit if no keyCode\n    if (isNaN(keyCode)) {\n      return;\n    }\n\n    if (!instance.tribute.autocompleteMode) {\n      const trigger = instance.tribute.triggers().find((trigger) => {\n        return trigger.charCodeAt(0) === keyCode;\n      });\n      if (!trigger) return;\n      const collection = instance.tribute.collection.find((item) => {\n        return item.trigger === trigger;\n      });\n      if (!collection) return;\n      if (\n        collection.menuShowMinLength >\n        instance.tribute.current.mentionText.length\n      )\n        return;\n      instance.tribute.current.collection = collection;\n    } else {\n      instance.tribute.current.collection = instance.tribute.collection[0];\n    }\n\n    instance.tribute.showMenuFor(this, true);\n  }\n\n  shouldDeactivate(event) {\n    let controlKeyPressed = false;\n    TributeEvents.keys().forEach((key) => {\n      if (key === event.code) {\n        controlKeyPressed = true;\n        return;\n      }\n    });\n\n    if (controlKeyPressed) return false;\n    if (this.tribute.isActive) return true;\n\n    return false;\n  }\n\n  getKeyCode(event) {\n    const keyCode = event.keyCode || event.which || event.code;\n    if (keyCode) {\n      return keyCode;\n    } else {\n      if (this.tribute.current.mentionTriggerChar)\n        return this.tribute.current.mentionTriggerChar.charCodeAt(0);\n      else if (this.tribute.current.mentionText)\n        return this.tribute.current.mentionText.charCodeAt(\n          this.tribute.current.mentionText.length - 1\n        );\n    }\n    return NaN;\n  }\n\n  updateSelection(el) {\n    this.tribute.current.element = el;\n    const info = this.tribute.range.getTriggerInfo(\n      false,\n      this.tribute.hasTrailingSpace,\n      true,\n      this.tribute.allowSpaces,\n      this.tribute.autocompleteMode\n    );\n\n    if (info) {\n      this.tribute.current.mentionTriggerChar = info.mentionTriggerChar;\n      this.tribute.current.mentionText = info.mentionText;\n      this.tribute.current.mentionPosition = info.mentionPosition;\n      this.tribute.current.fullText = info.fullText;\n      return true;\n    }\n\n    return false;\n  }\n\n  callbacks() {\n    return {\n      Enter: (e, _el) => {\n        // choose selection\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          this.tribute.selectItemAtIndex(this.tribute.menuSelected, e);\n        }\n      },\n      Escape: (e, _el) => {\n        if (this.tribute.isActive) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          this.tribute.hideMenu();\n        }\n      },\n      Tab: (e, el) => {\n        // choose first match\n        this.callbacks().Enter(e, el);\n      },\n      Space: (e, el) => {\n        if (this.tribute.isActive) {\n          if (this.tribute.spaceSelectsMatch) {\n            this.callbacks().Enter(e, el);\n          } else if (!this.tribute.allowSpaces) {\n            e.stopImmediatePropagation();\n            setTimeout(() => {\n              this.tribute.hideMenu();\n            }, 0);\n          }\n        }\n      },\n      ArrowUp: (e, _el) => {\n        // navigate up ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          const count = this.tribute.current.filteredItems.length,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected && selected > 0) {\n            this.tribute.menuSelected--;\n            this.setActiveLi();\n          } else if (selected === 0) {\n            this.tribute.menuSelected = count - 1;\n            this.setActiveLi();\n            this.tribute.menu.scrollTop = this.tribute.menu.scrollHeight;\n          }\n        }\n      },\n      ArrowDown: (e, _el) => {\n        // navigate down ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          const count = this.tribute.current.filteredItems.length - 1,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected) {\n            this.tribute.menuSelected++;\n            this.setActiveLi();\n          } else if (count === selected) {\n            this.tribute.menuSelected = 0;\n            this.setActiveLi();\n            this.tribute.menu.scrollTop = 0;\n          }\n        }\n      },\n      Delete: (e, el) => {\n        if (\n          this.tribute.isActive &&\n          this.tribute.current.mentionText.length < 1\n        ) {\n          this.tribute.hideMenu();\n        } else if (this.tribute.isActive) {\n          this.tribute.showMenuFor(el);\n        }\n      },\n    };\n  }\n\n  setActiveLi(index) {\n    const lis = this.tribute.menu.querySelectorAll(\"li\"),\n      length = lis.length >>> 0;\n\n    if (index) this.tribute.menuSelected = parseInt(index);\n\n    for (let i = 0; i < length; i++) {\n      const li = lis[i];\n      if (i === this.tribute.menuSelected) {\n        li.classList.add(this.tribute.current.collection.selectClass);\n\n        const liClientRect = li.getBoundingClientRect();\n        const menuClientRect = this.tribute.menu.getBoundingClientRect();\n\n        if (liClientRect.bottom > menuClientRect.bottom) {\n          const scrollDistance = liClientRect.bottom - menuClientRect.bottom;\n          this.tribute.menu.scrollTop += scrollDistance;\n        } else if (liClientRect.top < menuClientRect.top) {\n          const scrollDistance = menuClientRect.top - liClientRect.top;\n          this.tribute.menu.scrollTop -= scrollDistance;\n        }\n      } else {\n        li.classList.remove(this.tribute.current.collection.selectClass);\n      }\n    }\n  }\n\n  getFullHeight(elem, includeMargin) {\n    const height = elem.getBoundingClientRect().height;\n\n    if (includeMargin) {\n      const style = elem.currentStyle || window.getComputedStyle(elem);\n      return (\n        height + parseFloat(style.marginTop) + parseFloat(style.marginBottom)\n      );\n    }\n\n    return height;\n  }\n}\n\nexport default TributeEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\nclass TributeMenuEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.menuEvents = this;\n    this.menu = this.tribute.menu;\n  }\n\n  bind(_menu) {\n    this.menuClickEvent = this.tribute.events.click.bind(null, this);\n    this.menuContainerScrollEvent = this.tribute.debounce(\n      () => {\n        this.tribute.hideMenu();\n      },\n      10,\n      false\n    );\n    this.windowResizeEvent = this.tribute.debounce(\n      () => {\n        this.tribute.hideMenu();\n      },\n      10,\n      false\n    );\n\n    this.windowBlurEvent = () => {\n      this.tribute.hideMenu();\n    };\n\n    // fixes IE11 issues with mousedown\n    this.tribute.range\n      .getDocument()\n      .addEventListener(\"MSPointerDown\", this.menuClickEvent, false);\n    this.tribute.range\n      .getDocument()\n      .addEventListener(\"mousedown\", this.menuClickEvent, false);\n    window.addEventListener(\"resize\", this.windowResizeEvent);\n    window.addEventListener(\"blur\", this.windowBlurEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.addEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.addEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n\n  unbind(_menu) {\n    this.tribute.range\n      .getDocument()\n      .removeEventListener(\"mousedown\", this.menuClickEvent, false);\n    this.tribute.range\n      .getDocument()\n      .removeEventListener(\"MSPointerDown\", this.menuClickEvent, false);\n    window.removeEventListener(\"resize\", this.windowResizeEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.removeEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.removeEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n}\n\nexport default TributeMenuEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/jeff-collins/ment.io\nimport \"./utils\";\n\nclass TributeRange {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.range = this;\n  }\n\n  getDocument() {\n    let iframe;\n    if (this.tribute.current.collection) {\n      iframe = this.tribute.current.collection.iframe;\n    }\n\n    if (!iframe) {\n      return document;\n    }\n\n    return iframe.contentWindow.document;\n  }\n\n  positionMenuAtCaret(scrollTo) {\n    const context = this.tribute.current;\n    let coordinates;\n\n    if (!this.tribute.positionMenu) {\n      this.tribute.menu.style.display = `block`;\n      return;\n    }\n\n    if (!this.isContentEditable(context.element)) {\n      coordinates = this.getTextAreaOrInputUnderlinePosition(\n        context.element,\n        context.mentionPosition + context.mentionText.length\n      );\n    } else {\n      coordinates = this.getContentEditableCaretPosition(\n        context.mentionPosition + context.mentionText.length\n      );\n    }\n\n    this.tribute.menu.style.top = `${coordinates.top}px`;\n    this.tribute.menu.style.left = `${coordinates.left}px`;\n    this.tribute.menu.style.right = `${coordinates.right}px`;\n    this.tribute.menu.style.bottom = `${coordinates.bottom}px`;\n    this.tribute.menu.style[\"max-heigh\"] = `${coordinates.maxHeight || 500}px`;\n    this.tribute.menu.style[\"max-width\"] = `${coordinates.maxWidth || 300}px`;\n    this.tribute.menu.style.position = `${coordinates.position || \"absolute\"}`;\n    this.tribute.menu.style.display = `block`;\n\n    if (coordinates.left === \"auto\") {\n      this.tribute.menu.style.left = \"auto\";\n    }\n\n    if (coordinates.top === \"auto\") {\n      this.tribute.menu.style.top = \"auto\";\n    }\n\n    if (scrollTo) this.scrollIntoView();\n  }\n\n  get menuContainerIsBody() {\n    return (\n      this.tribute.menuContainer === this.getDocument().body ||\n      !this.tribute.menuContainer\n    );\n  }\n\n  replaceTriggerText(text, originalEvent, item) {\n    const context = this.tribute.current;\n    const detail = {\n      item: item,\n      context: context,\n      event: originalEvent,\n      text: text,\n    };\n    const replaceEvent = new CustomEvent(\"tribute-replaced\");\n\n    if (!this.isContentEditable(context.element)) {\n      const textEndsWithSpace = text !== text.trimEnd();\n      const myField = this.tribute.current.element;\n      const textSuffix =\n        typeof this.tribute.replaceTextSuffix === \"string\"\n          ? this.tribute.replaceTextSuffix\n          : \" \";\n      text = this.stripHtml(text);\n      text += textSuffix;\n      const startPos = context.mentionPosition;\n      let endPos =\n        context.mentionPosition +\n        context.mentionText.length +\n        textSuffix.length +\n        textEndsWithSpace;\n      if (!this.tribute.autocompleteMode) {\n        endPos += context.mentionTriggerChar.length - 1;\n      }\n      myField.value =\n        myField.value.substring(0, startPos) +\n        text +\n        myField.value.substring(endPos, myField.value.length);\n      myField.selectionStart = startPos + text.length;\n      myField.selectionEnd = startPos + text.length;\n    } else {\n      const textSuffix =\n        typeof this.tribute.replaceTextSuffix === \"string\"\n          ? this.tribute.replaceTextSuffix\n          : \"\\xA0\";\n      text += textSuffix;\n      const strippedText = this.stripHtml(text);\n      const isHTML = text !== strippedText;\n      if (isHTML)\n        this.pasteHtml(\n          text,\n          context.mentionText.length + context.mentionTriggerChar.length\n        );\n      else\n        this.pasteText(\n          strippedText,\n          context.mentionText.length + context.mentionTriggerChar.length\n        );\n    }\n\n    context.element.dispatchEvent(\n      new CustomEvent(\"input\", { bubbles: true, detail: detail })\n    );\n    context.element.dispatchEvent(replaceEvent);\n  }\n\n  pasteText(text, numOfCharsToRemove) {\n    const { sel, range } = this.getContentEditableSelectionStart(true);\n    const pre = sel.anchorNode.nodeValue.substring(\n      0,\n      sel.anchorOffset - numOfCharsToRemove\n    );\n    const post = sel.anchorNode.nodeValue.substring(\n      sel.anchorOffset,\n      sel.anchorNode.nodeValue.length\n    );\n    sel.anchorNode.nodeValue = pre + text + post;\n    range.setStart(sel.anchorNode, pre.length + text.length);\n    range.collapse(true);\n    sel.removeAllRanges();\n    sel.addRange(range);\n    sel.collapseToEnd();\n  }\n\n  pasteHtml(html, numOfCharsToRemove) {\n    const { sel } = this.getContentEditableSelectionStart(true);\n    if (sel) {\n      let range = null;\n      for (let index = 0; index < numOfCharsToRemove; index++) {\n        sel.modify(\"extend\", \"backward\", \"character\");\n      }\n      range = sel.getRangeAt(0);\n      range.deleteContents();\n\n      const el = this.getDocument().createElement(\"div\");\n      el.innerHTML = html;\n      const frag = this.getDocument().createDocumentFragment();\n      let node, lastNode;\n\n      while ((node = el.firstChild)) {\n        lastNode = frag.appendChild(node);\n      }\n      range.insertNode(frag);\n\n      // Preserve the selection\n      if (lastNode) {\n        range.setStart(lastNode, lastNode.length);\n        range.setEnd(lastNode, lastNode.length);\n        range.collapse(true);\n        sel.removeAllRanges();\n        sel.addRange(range);\n        sel.collapseToEnd();\n      }\n    }\n  }\n\n  stripHtml(html) {\n    const tmp = this.getDocument().createElement(\"DIV\");\n    tmp.innerHTML = html;\n    return tmp.textContent || tmp.innerText || \"\";\n  }\n\n  getWindowSelection() {\n    if (this.tribute.collection.iframe) {\n      return this.tribute.collection.iframe.contentWindow.getSelection();\n    }\n\n    const rootNode = this.tribute.current.element.getRootNode();\n    if (rootNode.getSelection) return rootNode.getSelection();\n    else return window.getSelection();\n  }\n\n  getContentEditableSelectionStart(moveToEndOfWord) {\n    const sel = this.getWindowSelection();\n    if (!sel.isCollapsed) {\n      return { sel: null, range: null, direction: null };\n    }\n    const direction = sel.anchorOffset <= sel.focusOffset;\n    const range = sel.getRangeAt(0);\n    const selectedElem = sel.anchorNode;\n    const workingNodeContent = selectedElem.textContent;\n    const selectStartOffset = range.startOffset;\n    let nextChar =\n      workingNodeContent.length > selectStartOffset\n        ? workingNodeContent[selectStartOffset]\n        : null;\n    if (nextChar === null) {\n      if (selectedElem.nextSibling && selectedElem.nextSibling.textContent) {\n        const nextNodeText = selectedElem.nextSibling.textContent;\n        nextChar = nextNodeText.length ? nextNodeText[0] : null;\n      }\n    }\n    const nextCharIsSeparator =\n      nextChar && nextChar.match(this.tribute.autocompleteSeparator);\n    sel.collapseToEnd();\n    if (nextChar && !nextCharIsSeparator && moveToEndOfWord)\n      sel.modify(\"move\", \"forward\", \"word\");\n\n    return { sel, range, direction };\n  }\n\n  getWholeWordsUpToCharIndex(str, minLen) {\n    let pos = 0;\n    const arr = str\n      .split(this.tribute.autocompleteSeparator)\n      .filter(function (e) {\n        return e.trim();\n      });\n    const text = str;\n    for (let i = 0, len = arr.length; i < len; i++) {\n      const idx = str.indexOf(arr[i]);\n      pos = pos + idx;\n      str = str.slice(idx);\n      if (minLen >= pos && minLen <= pos + arr[i].length) {\n        minLen = pos + arr[i].length;\n        break;\n      }\n    }\n\n    return text.substring(0, minLen);\n  }\n  getTextPrecedingCurrentSelection() {\n    const context = this.tribute.current;\n    let text = null;\n\n    if (!this.isContentEditable(context.element)) {\n      const textComponent = this.tribute.current.element;\n      if (textComponent) {\n        const startPos = textComponent.selectionStart;\n        const endPos = textComponent.selectionEnd;\n\n        if (textComponent.value && startPos >= 0 && startPos === endPos) {\n          text = textComponent.value.substring(0);\n          text = this.getWholeWordsUpToCharIndex(text, startPos);\n        }\n      }\n    } else {\n      const { sel, range, direction } =\n        this.getContentEditableSelectionStart(true);\n      if (sel) {\n        const selectedElem = sel.anchorNode;\n        const workingNodeContent = selectedElem.textContent;\n        const selectStartOffset = sel.getRangeAt(0).startOffset;\n        const lastChar = workingNodeContent[Math.max(0, selectStartOffset - 1)];\n        const addWhiteSpace = lastChar && lastChar !== lastChar.trim();\n        text = sel.toString().trim();\n\n        for (\n          let index = 0;\n          index < this.tribute.numberOfWordsInContextText;\n          index++\n        ) {\n          sel.modify(\"extend\", \"backward\", \"word\");\n          const newText = sel.toString().trim();\n          if (newText.length > text.length && newText.endsWith(text)) {\n            // Workarounds Firefox issue, where selection sometimes collapse or move instead of extend\n            text = newText;\n          }\n        }\n        text += addWhiteSpace ? \" \" : \"\";\n\n        this.restoreSelection(sel, range, direction);\n      }\n    }\n\n    return text;\n  }\n\n  getLastWordInText(text) {\n    const separator = this.tribute.autocompleteSeparator\n      ? this.tribute.autocompleteSeparator\n      : /\\s+/;\n    const wordsArray = text.split(separator);\n\n    if (!wordsArray.length) return \" \";\n    return wordsArray[wordsArray.length - 1];\n  }\n\n  getTriggerInfo(\n    menuAlreadyActive,\n    hasTrailingSpace,\n    requireLeadingSpace,\n    allowSpaces,\n    isAutocomplete\n  ) {\n    const effectiveRange = this.getTextPrecedingCurrentSelection();\n    if (effectiveRange === null) return null;\n    const lastWordOfEffectiveRange = this.getLastWordInText(effectiveRange);\n\n    if (isAutocomplete) {\n      return {\n        mentionPosition:\n          effectiveRange.length - lastWordOfEffectiveRange.length,\n        mentionText: lastWordOfEffectiveRange,\n        fullText: effectiveRange,\n        mentionTriggerChar: \"\",\n      };\n    }\n\n    if (effectiveRange !== undefined && effectiveRange !== null) {\n      let mostRecentTriggerCharPos = -1;\n      let triggerChar;\n\n      this.tribute.collection.forEach((config) => {\n        const c = config.trigger;\n        const idx = config.requireLeadingSpace\n          ? this.lastIndexWithLeadingSpace(effectiveRange, c)\n          : effectiveRange.lastIndexOf(c);\n\n        if (idx > mostRecentTriggerCharPos) {\n          mostRecentTriggerCharPos = idx;\n          triggerChar = c;\n          requireLeadingSpace = config.requireLeadingSpace;\n        }\n      });\n\n      if (\n        mostRecentTriggerCharPos >= 0 &&\n        (mostRecentTriggerCharPos === 0 ||\n          !requireLeadingSpace ||\n          /\\s/.test(\n            effectiveRange.substring(\n              mostRecentTriggerCharPos - 1,\n              mostRecentTriggerCharPos\n            )\n          ))\n      ) {\n        let currentTriggerSnippet = effectiveRange.substring(\n          mostRecentTriggerCharPos + triggerChar.length,\n          effectiveRange.length\n        );\n\n        triggerChar = effectiveRange.substring(\n          mostRecentTriggerCharPos,\n          mostRecentTriggerCharPos + triggerChar.length\n        );\n        const firstSnippetChar = currentTriggerSnippet.substring(0, 1);\n        const leadingSpace =\n          currentTriggerSnippet.length > 0 &&\n          (firstSnippetChar === \" \" || firstSnippetChar === \"\\xA0\");\n        if (hasTrailingSpace) {\n          currentTriggerSnippet = currentTriggerSnippet.trim();\n        }\n\n        const regex = allowSpaces ? /[^\\S ]/g : /[\\xA0\\s]/g;\n\n        this.tribute.hasTrailingSpace = regex.test(currentTriggerSnippet);\n\n        if (\n          !leadingSpace &&\n          (menuAlreadyActive || !regex.test(currentTriggerSnippet))\n        ) {\n          return {\n            mentionPosition: mostRecentTriggerCharPos,\n            mentionText: currentTriggerSnippet,\n            mentionTriggerChar: triggerChar,\n            fullText: effectiveRange,\n          };\n        }\n      }\n    }\n  }\n\n  lastIndexWithLeadingSpace(str, trigger) {\n    const reversedStr = str.split(\"\").reverse().join(\"\");\n    let index = -1;\n\n    for (let cidx = 0, len = str.length; cidx < len; cidx++) {\n      const firstChar = cidx === str.length - 1;\n      const leadingSpace = /\\s/.test(reversedStr[cidx + 1]);\n\n      let match = true;\n      for (let triggerIdx = trigger.length - 1; triggerIdx >= 0; triggerIdx--) {\n        if (trigger[triggerIdx] !== reversedStr[cidx - triggerIdx]) {\n          match = false;\n          break;\n        }\n      }\n\n      if (match && (firstChar || leadingSpace)) {\n        index = str.length - 1 - cidx;\n        break;\n      }\n    }\n\n    return index;\n  }\n\n  isContentEditable(element) {\n    return element.nodeName !== \"INPUT\" && element.nodeName !== \"TEXTAREA\";\n  }\n\n  isMenuOffScreen(coordinates, menuDimensions) {\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    const doc = this.getDocument().documentElement;\n    const windowLeft =\n      (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n    const windowTop =\n      (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n\n    const menuTop =\n      typeof coordinates.top === \"number\"\n        ? coordinates.top\n        : coordinates.bottom - menuDimensions.height;\n    const menuRight =\n      typeof coordinates.right === \"number\"\n        ? coordinates.right\n        : coordinates.left + menuDimensions.width;\n    const menuBottom =\n      typeof coordinates.bottom === \"number\"\n        ? coordinates.bottom\n        : coordinates.top + menuDimensions.height;\n    const menuLeft =\n      typeof coordinates.left === \"number\"\n        ? coordinates.left\n        : coordinates.right - menuDimensions.width;\n\n    return {\n      top: menuTop < Math.floor(windowTop),\n      right: menuRight > Math.ceil(windowLeft + windowWidth),\n      bottom: menuBottom > Math.ceil(windowTop + windowHeight),\n      left: menuLeft < Math.floor(windowLeft),\n    };\n  }\n\n  getMenuDimensions() {\n    // Width of the menu depends of its contents and position\n    // We must check what its width would be without any obstruction\n    // This way, we can achieve good positioning for flipping the menu\n    const dimensions = {\n      width: null,\n      height: null,\n    };\n\n    this.tribute.menu.style.top = `0px`;\n    this.tribute.menu.style.left = `0px`;\n    this.tribute.menu.style.right = null;\n    this.tribute.menu.style.bottom = null;\n    this.tribute.menu.style.position = `fixed`;\n    this.tribute.menu.style.visibility = `hidden`;\n    this.tribute.menu.style.display = `block`;\n\n    dimensions.width = this.tribute.menu.offsetWidth;\n    dimensions.height = this.tribute.menu.offsetHeight;\n\n    this.tribute.menu.style.display = `none`;\n    this.tribute.menu.style.visibility = `visible`;\n\n    return dimensions;\n  }\n\n  getTextAreaOrInputUnderlinePosition(element, position, _flipped) {\n    const properties = [\n      \"direction\",\n      \"boxSizing\",\n      \"width\",\n      \"height\",\n      \"overflowX\",\n      \"overflowY\",\n      \"borderTopWidth\",\n      \"borderRightWidth\",\n      \"borderBottomWidth\",\n      \"borderLeftWidth\",\n      \"borderStyle\",\n      \"paddingTop\",\n      \"paddingRight\",\n      \"paddingBottom\",\n      \"paddingLeft\",\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSize\",\n      \"fontSizeAdjust\",\n      \"lineHeight\",\n      \"fontFamily\",\n      \"textAlign\",\n      \"textTransform\",\n      \"textIndent\",\n      \"textDecoration\",\n      \"letterSpacing\",\n      \"wordSpacing\",\n    ];\n\n    const div = this.getDocument().createElement(\"div\");\n    div.id = \"input-textarea-caret-position-mirror-div\";\n    this.getDocument().body.appendChild(div);\n\n    const style = div.style;\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n\n    style.whiteSpace = \"pre-wrap\";\n    if (element.nodeName !== \"INPUT\") {\n      style.wordWrap = \"break-word\";\n    }\n\n    // position off-screen\n    style.position = \"absolute\";\n    style.visibility = \"hidden\";\n\n    // transfer the element's properties to the div\n    properties.forEach((prop) => {\n      style[prop] = computed[prop];\n    });\n\n    const span0 = this.getDocument().createElement(\"span\");\n    span0.textContent = element.value.substring(0, position);\n    div.appendChild(span0);\n\n    if (element.nodeName === \"INPUT\") {\n      div.textContent = div.textContent.replace(/\\s/g, \" \");\n    }\n\n    //Create a span in the div that represents where the cursor\n    //should be\n    const span = this.getDocument().createElement(\"span\");\n    //we give it no content as this represents the cursor\n    div.appendChild(span);\n\n    const span2 = this.getDocument().createElement(\"span\");\n    span2.textContent = element.value.substring(position, position + 1);\n    div.appendChild(span2);\n\n    const rect = element.getBoundingClientRect();\n\n    //position the div exactly over the element\n    //so we can get the bounding client rect for the span and\n    //it should represent exactly where the cursor is\n    div.style.position = \"fixed\";\n    div.style.left = rect.left + \"px\";\n    div.style.top = rect.top + \"px\";\n    div.style.width = rect.width + \"px\";\n    div.style.height = rect.height + \"px\";\n    div.scrollTop = element.scrollTop;\n\n    const spanRect = span.getBoundingClientRect();\n    const divRect = div.getBoundingClientRect();\n    this.getDocument().body.removeChild(div);\n    const clamp = function (number, min, max) {\n      return Math.max(min, Math.min(number, max));\n    };\n    const finalRect = {\n      height: Math.min(divRect.height, spanRect.height),\n      left: clamp(spanRect.left, divRect.left, divRect.left + divRect.width),\n      top: clamp(spanRect.top, divRect.top, divRect.top + divRect.height),\n    };\n    return this.getFixedCoordinatesRelativeToRect(finalRect);\n  }\n\n  getContentEditableCaretPosition(_selectedNodePosition) {\n    const { sel, range, direction } =\n      this.getContentEditableSelectionStart(false);\n    const newRange = sel.getRangeAt(0);\n    // restore selection\n    this.restoreSelection(sel, range, direction);\n    let rect = newRange.getBoundingClientRect();\n    if (sel.anchorNode.parentNode) {\n      const parentNodeRect = sel.anchorNode.parentNode.getBoundingClientRect();\n      const clamp = function (number, min, max) {\n        return Math.max(min, Math.min(number, max));\n      };\n      rect = {\n        height: Math.min(parentNodeRect.height, rect.height),\n        left: clamp(\n          rect.left,\n          parentNodeRect.left,\n          parentNodeRect.left + parentNodeRect.width\n        ),\n        top: clamp(\n          rect.top,\n          parentNodeRect.top,\n          parentNodeRect.top + parentNodeRect.height\n        ),\n      };\n    }\n    return this.getFixedCoordinatesRelativeToRect(rect);\n  }\n\n  getFixedCoordinatesRelativeToRect(rect) {\n    const coordinates = {\n      position: \"fixed\",\n      left: rect.left,\n      top: rect.top + rect.height,\n    };\n\n    const menuDimensions = this.getMenuDimensions();\n\n    const availableSpaceOnTop = rect.top;\n    const availableSpaceOnBottom =\n      window.innerHeight - (rect.top + rect.height);\n\n    //check to see where's the right place to put the menu vertically\n    if (availableSpaceOnBottom < menuDimensions.height) {\n      if (\n        availableSpaceOnTop >= menuDimensions.height ||\n        availableSpaceOnTop > availableSpaceOnBottom\n      ) {\n        coordinates.top = \"auto\";\n        coordinates.bottom = window.innerHeight - rect.top;\n        if (availableSpaceOnBottom < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnTop;\n        }\n      } else {\n        if (availableSpaceOnTop < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnBottom;\n        }\n      }\n    }\n\n    const availableSpaceOnLeft = rect.left;\n    const availableSpaceOnRight = window.innerWidth - rect.left;\n\n    //check to see where's the right place to put the menu horizontally\n    if (availableSpaceOnRight < menuDimensions.width) {\n      if (\n        availableSpaceOnLeft >= menuDimensions.width ||\n        availableSpaceOnLeft > availableSpaceOnRight\n      ) {\n        coordinates.left = \"auto\";\n        coordinates.right = window.innerWidth - rect.left;\n        if (availableSpaceOnRight < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnLeft;\n        }\n      } else {\n        if (availableSpaceOnLeft < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnRight;\n        }\n      }\n    }\n\n    return coordinates;\n  }\n\n  scrollIntoView(_elem) {\n    const reasonableBuffer = 20;\n    const maxScrollDisplacement = 100;\n    let clientRect;\n    let e = this.menu;\n\n    if (typeof e === \"undefined\") return;\n\n    while (clientRect === undefined || clientRect.height === 0) {\n      clientRect = e.getBoundingClientRect();\n\n      if (clientRect.height === 0) {\n        e = e.childNodes[0];\n        if (e === undefined || !e.getBoundingClientRect) {\n          return;\n        }\n      }\n    }\n\n    const elemTop = clientRect.top;\n    const elemBottom = elemTop + clientRect.height;\n\n    if (elemTop < 0) {\n      window.scrollTo(\n        0,\n        window.pageYOffset + clientRect.top - reasonableBuffer\n      );\n    } else if (elemBottom > window.innerHeight) {\n      let maxY = window.pageYOffset + clientRect.top - reasonableBuffer;\n\n      if (maxY - window.pageYOffset > maxScrollDisplacement) {\n        maxY = window.pageYOffset + maxScrollDisplacement;\n      }\n\n      let targetY = window.pageYOffset - (window.innerHeight - elemBottom);\n\n      if (targetY > maxY) {\n        targetY = maxY;\n      }\n\n      window.scrollTo(0, targetY);\n    }\n  }\n\n  restoreSelection(sel, range, directionFwd = true) {\n    sel.removeAllRanges();\n\n    if (directionFwd) {\n      sel.addRange(range);\n    } else {\n      const endRange = range.cloneRange();\n      endRange.collapse(false);\n      sel.addRange(endRange);\n      sel.extend(range.startContainer, range.startOffset);\n    }\n  }\n}\n\nexport default TributeRange;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/mattyork/fuzzy\nclass TributeSearch {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.search = this;\n  }\n\n  simpleFilter(pattern, array) {\n    return array.filter((string) => {\n      return this.test(pattern, string);\n    });\n  }\n\n  test(pattern, string) {\n    return this.match(pattern, string) !== null;\n  }\n\n  match(pattern, string, opts) {\n    opts = opts || {};\n    const pre = opts.pre || \"\",\n      post = opts.post || \"\",\n      compareString = (opts.caseSensitive && string) || string.toLowerCase();\n\n    if (opts.skip) {\n      return { rendered: string, score: 0 };\n    }\n\n    pattern = (opts.caseSensitive && pattern) || pattern.toLowerCase();\n\n    const patternCache = this.traverse(compareString, pattern, 0, 0, []);\n    if (!patternCache) {\n      return null;\n    }\n    return {\n      rendered: this.render(string, patternCache.cache, pre, post),\n      score: patternCache.score,\n    };\n  }\n\n  traverse(string, pattern, stringIndex, patternIndex, patternCache) {\n    if (this.tribute.autocompleteSeparator) {\n      // if the pattern search at end\n      pattern = pattern.split(this.tribute.autocompleteSeparator).splice(-1)[0];\n    }\n\n    if (pattern.length === patternIndex) {\n      // calculate score and copy the cache containing the indices where it's found\n      return {\n        score: this.calculateScore(patternCache),\n        cache: patternCache.slice(),\n      };\n    }\n\n    // if string at end or remaining pattern > remaining string\n    if (\n      string.length === stringIndex ||\n      pattern.length - patternIndex > string.length - stringIndex\n    ) {\n      return undefined;\n    }\n\n    const c = pattern[patternIndex];\n    let index = string.indexOf(c, stringIndex);\n    let best;\n    let temp;\n\n    while (index > -1) {\n      patternCache.push(index);\n      temp = this.traverse(\n        string,\n        pattern,\n        index + 1,\n        patternIndex + 1,\n        patternCache\n      );\n      patternCache.pop();\n\n      // if downstream traversal failed, return best answer so far\n      if (!temp) {\n        return best;\n      }\n\n      if (!best || best.score < temp.score) {\n        best = temp;\n      }\n\n      index = string.indexOf(c, index + 1);\n    }\n\n    return best;\n  }\n\n  calculateScore(patternCache) {\n    let score = 0;\n    let temp = 1;\n\n    patternCache.forEach((index, i) => {\n      if (i > 0) {\n        if (patternCache[i - 1] + 1 === index) {\n          temp += temp + 1;\n        } else {\n          temp = 1;\n        }\n      }\n\n      score += temp;\n    });\n\n    return score;\n  }\n\n  render(string, indices, pre, post) {\n    let rendered = string.substring(0, indices[0]);\n\n    indices.forEach((index, i) => {\n      rendered +=\n        pre +\n        string[index] +\n        post +\n        string.substring(\n          index + 1,\n          indices[i + 1] ? indices[i + 1] : string.length\n        );\n    });\n\n    return rendered;\n  }\n\n  filter(pattern, arr, opts) {\n    opts = opts || {};\n    return arr\n      .reduce((prev, element, idx, _arr) => {\n        let str = element;\n\n        if (opts.extract) {\n          str = opts.extract(element);\n\n          if (!str) {\n            // take care of undefineds / nulls / etc.\n            str = \"\";\n          }\n        }\n\n        const rendered = this.match(pattern, str, opts);\n\n        if (rendered !== null) {\n          prev[prev.length] = {\n            string: rendered.rendered,\n            score: rendered.score,\n            index: idx,\n            original: element,\n          };\n        }\n\n        return prev;\n      }, [])\n\n      .sort((a, b) => {\n        const compare = b.score - a.score;\n        if (compare) return compare;\n        return a.index - b.index;\n      });\n  }\n}\n\nexport default TributeSearch;\n","import \"./utils\";\nimport TributeEvents from \"./TributeEvents\";\nimport TributeMenuEvents from \"./TributeMenuEvents\";\nimport TributeRange from \"./TributeRange\";\nimport TributeSearch from \"./TributeSearch\";\n\nclass Tribute {\n  constructor({\n    values = null,\n    loadingItemTemplate = null,\n    iframe = null,\n    selectClass = \"highlight\",\n    containerClass = \"tribute-container\",\n    itemClass = \"\",\n    trigger = \"@\",\n    autocompleteMode = false,\n    autocompleteSeparator = null,\n    selectTemplate = null,\n    menuItemTemplate = null,\n    lookup = \"key\",\n    fillAttr = \"value\",\n    collection = null,\n    menuContainer = null,\n    noMatchTemplate = null,\n    requireLeadingSpace = true,\n    allowSpaces = false,\n    replaceTextSuffix = null,\n    positionMenu = true,\n    spaceSelectsMatch = false,\n    searchOpts = {},\n    menuItemLimit = null,\n    menuShowMinLength = 0,\n    keys = null,\n    numberOfWordsInContextText = 5,\n  }) {\n    this.autocompleteMode = autocompleteMode;\n    this.autocompleteSeparator = autocompleteSeparator;\n    this.menuSelected = 0;\n    this.current = {};\n    this.isActive = false;\n    this.activationPending = false;\n    this.menuContainer = menuContainer;\n    this.allowSpaces = allowSpaces;\n    this.replaceTextSuffix = replaceTextSuffix;\n    this.positionMenu = positionMenu;\n    this.hasTrailingSpace = false;\n    this.spaceSelectsMatch = spaceSelectsMatch;\n    this.numberOfWordsInContextText = numberOfWordsInContextText;\n    if (keys) {\n      TributeEvents.keys = keys;\n    }\n\n    if (this.autocompleteMode) {\n      trigger = \"\";\n      allowSpaces = false;\n    }\n\n    if (values) {\n      this.collection = [\n        {\n          // symbol that starts the lookup\n          trigger: trigger,\n\n          // is it wrapped in an iframe\n          iframe: iframe,\n\n          // class applied to selected item\n          selectClass: selectClass,\n\n          // class applied to the Container\n          containerClass: containerClass,\n\n          // class applied to each item\n          itemClass: itemClass,\n\n          // function called on select that retuns the content to insert\n          selectTemplate: (\n            selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n\n          // function called that returns content for an item\n          menuItemTemplate: (\n            menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n\n          // column to search against in the object\n          lookup: lookup,\n\n          // column that contains the content to insert by default\n          fillAttr: fillAttr,\n\n          // array of objects or a function returning an array of objects\n          values: values,\n\n          // useful for when values is an async function\n          loadingItemTemplate: loadingItemTemplate,\n\n          requireLeadingSpace: requireLeadingSpace,\n\n          searchOpts: searchOpts,\n\n          menuItemLimit: menuItemLimit,\n\n          menuShowMinLength: menuShowMinLength,\n        },\n      ];\n    } else if (collection) {\n      if (this.autocompleteMode)\n        console.warn(\n          \"Tribute in autocomplete mode does not work for collections\"\n        );\n      this.collection = collection.map((item) => {\n        return {\n          trigger: item.trigger || trigger,\n          iframe: item.iframe || iframe,\n          selectClass: item.selectClass || selectClass,\n          containerClass: item.containerClass || containerClass,\n          itemClass: item.itemClass || itemClass,\n          selectTemplate: (\n            item.selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n          menuItemTemplate: (\n            item.menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n          lookup: item.lookup || lookup,\n          fillAttr: item.fillAttr || fillAttr,\n          values: item.values,\n          loadingItemTemplate: item.loadingItemTemplate,\n          requireLeadingSpace: item.requireLeadingSpace,\n          searchOpts: item.searchOpts || searchOpts,\n          menuItemLimit: item.menuItemLimit || menuItemLimit,\n          menuShowMinLength: item.menuShowMinLength || menuShowMinLength,\n        };\n      });\n    } else {\n      throw new Error(\"[Tribute] No collection specified.\");\n    }\n\n    new TributeRange(this);\n    new TributeEvents(this);\n    new TributeMenuEvents(this);\n    new TributeSearch(this);\n  }\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  set isActive(val) {\n    if (this._isActive !== val) {\n      this._isActive = val;\n      if (this.current.element) {\n        const noMatchEvent = new CustomEvent(`tribute-active-${val}`);\n        this.current.element.dispatchEvent(noMatchEvent);\n      }\n    }\n  }\n\n  static defaultSelectTemplate(item) {\n    if (typeof item === \"undefined\")\n      return `${this.current.collection.trigger}${this.current.mentionText}`;\n    if (this.range.isContentEditable(this.current.element)) {\n      return (\n        '<span class=\"tribute-mention\">' +\n        (this.current.collection.trigger +\n          item.original[this.current.collection.fillAttr]) +\n        \"</span>\"\n      );\n    }\n\n    return (\n      this.current.collection.trigger +\n      item.original[this.current.collection.fillAttr]\n    );\n  }\n\n  static defaultMenuItemTemplate(matchItem) {\n    return matchItem.string;\n  }\n\n  static inputTypes() {\n    return [\"TEXTAREA\", \"INPUT\"];\n  }\n\n  triggers() {\n    return this.collection.map((config) => {\n      return config.trigger;\n    });\n  }\n\n  attach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    /* global jQuery */\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._attach(el[i]);\n      }\n    } else {\n      this._attach(el);\n    }\n  }\n\n  _attach(el) {\n    if (el.hasAttribute(\"data-tribute\")) {\n      console.warn(\"Tribute was already bound to \" + el.nodeName);\n    }\n\n    this.ensureEditable(el);\n    this.events.bind(el);\n    el.setAttribute(\"data-tribute\", true);\n  }\n\n  ensureEditable(element) {\n    if (Tribute.inputTypes().indexOf(element.nodeName) === -1) {\n      if (element.contentEditable) {\n        element.contentEditable = true;\n      } else {\n        throw new Error(\"[Tribute] Cannot bind to \" + element.nodeName);\n      }\n    }\n  }\n\n  createMenu(containerClass, element) {\n    const properties = [\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSizeAdjust\",\n      \"fontFamily\",\n    ];\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n    const wrapper = this.range.getDocument().createElement(\"div\"),\n      ul = this.range.getDocument().createElement(\"ul\");\n    wrapper.className = containerClass;\n    wrapper.setAttribute(\"tabindex\", \"0\");\n    wrapper.appendChild(ul);\n    wrapper.style.fontSize =\n      Math.round(parseInt(computed.fontSize) * 0.9) + \"px\";\n    wrapper.style.display = \"none\";\n\n    properties.forEach((prop) => {\n      wrapper.style[prop] = computed[prop];\n    });\n\n    if (this.menuContainer) {\n      return this.menuContainer.appendChild(wrapper);\n    }\n\n    return this.range.getDocument().body.appendChild(wrapper);\n  }\n\n  showMenuFor(element, scrollTo) {\n    // Only proceed if menu isn't already shown for the current element & mentionText\n    if (\n      this.isActive &&\n      this.current.element === element &&\n      this.current.mentionText === this.currentMentionTextSnapshot\n    ) {\n      return;\n    }\n    this.currentMentionTextSnapshot = this.current.mentionText;\n\n    // create the menu if it doesn't exist.\n    if (!this.menu) {\n      this.menu = this.createMenu(\n        this.current.collection.containerClass,\n        element\n      );\n      element.tributeMenu = this.menu;\n      this.menuEvents.bind(this.menu);\n    }\n\n    this.activationPending = true;\n    this.menuSelected = 0;\n\n    if (!this.current.mentionText) {\n      this.current.mentionText = \"\";\n    }\n\n    const processValues = (values, forceReplace) => {\n      // Tribute may not be active any more by the time the value callback returns\n      if (!this.activationPending) {\n        return;\n      }\n      this.activationPending = false;\n      // Element is no longer in focus - don't show menu\n      if (this.range.getDocument().activeElement !== this.current.element) {\n        return;\n      }\n\n      if (forceReplace) {\n        // Do force replace - don't show menu\n        this.current.mentionPosition -= forceReplace.length;\n        this.current.mentionText =\n          \" \".repeat(forceReplace.length) + this.current.mentionText;\n        this.replaceText(forceReplace.text, null, null);\n        return;\n      }\n\n      let items = this.search.filter(this.current.mentionText, values, {\n        pre: this.current.collection.searchOpts.pre || \"<span>\",\n        post: this.current.collection.searchOpts.post || \"</span>\",\n        skip: this.current.collection.searchOpts.skip,\n        extract: (el) => {\n          if (typeof this.current.collection.lookup === \"string\") {\n            return el[this.current.collection.lookup];\n          } else if (typeof this.current.collection.lookup === \"function\") {\n            return this.current.collection.lookup(el, this.current.mentionText);\n          } else {\n            throw new Error(\n              \"Invalid lookup attribute, lookup must be string or function.\"\n            );\n          }\n        },\n      });\n\n      if (this.current.collection.menuItemLimit) {\n        items = items.slice(0, this.current.collection.menuItemLimit);\n      }\n\n      this.current.filteredItems = items;\n\n      const ul = this.menu.querySelector(\"ul\");\n      let showMenu = false;\n\n      if (!items.length) {\n        const noMatchEvent = new CustomEvent(\"tribute-no-match\", {\n          detail: this.menu,\n        });\n        this.current.element.dispatchEvent(noMatchEvent);\n        if (\n          (typeof this.current.collection.noMatchTemplate === \"function\" &&\n            !this.current.collection.noMatchTemplate()) ||\n          !this.current.collection.noMatchTemplate\n        ) {\n          showMenu = false;\n        } else {\n          typeof this.current.collection.noMatchTemplate === \"function\"\n            ? (ul.innerHTML = this.current.collection.noMatchTemplate())\n            : (ul.innerHTML = this.current.collection.noMatchTemplate);\n          showMenu = true;\n        }\n      } else {\n        ul.innerHTML = \"\";\n        const fragment = this.range.getDocument().createDocumentFragment();\n\n        items.forEach((item, index) => {\n          const li = this.range.getDocument().createElement(\"li\");\n          li.setAttribute(\"data-index\", index);\n          li.className = this.current.collection.itemClass;\n          li.addEventListener(\"mousemove\", (e) => {\n            const [, index] = this._findLiTarget(e.target);\n            if (e.movementY !== 0) {\n              this.events.setActiveLi(index);\n            }\n          });\n          if (this.menuSelected === index) {\n            li.classList.add(this.current.collection.selectClass);\n          }\n          li.innerHTML = this.current.collection.menuItemTemplate(item);\n          fragment.appendChild(li);\n        });\n        ul.appendChild(fragment);\n        showMenu = true;\n      }\n      if (showMenu) {\n        this.isActive = true;\n        this.range.positionMenuAtCaret(scrollTo);\n      }\n    };\n\n    if (typeof this.current.collection.values === \"function\") {\n      if (this.current.collection.loadingItemTemplate) {\n        this.menu.querySelector(\"ul\").innerHTML =\n          this.current.collection.loadingItemTemplate;\n        this.range.positionMenuAtCaret(scrollTo);\n      }\n\n      this.current.collection.values(\n        this.current.mentionText,\n        processValues,\n        this.current.fullText\n      );\n    } else {\n      processValues(this.current.collection.values);\n    }\n  }\n\n  _findLiTarget(el) {\n    if (!el) return [];\n    const index = el.getAttribute(\"data-index\");\n    return !index ? this._findLiTarget(el.parentNode) : [el, index];\n  }\n\n  showMenuForCollection(element, collectionIndex) {\n    if (!this.events.updateSelection(element)) return;\n    if (element !== this.range.getDocument().activeElement) {\n      this.placeCaretAtEnd(element);\n      if (element.isContentEditable)\n        this.insertTextAtCursor(this.current.collection.trigger);\n      else this.insertAtCaret(element, this.current.collection.trigger);\n    }\n\n    this.current.collection = this.collection[collectionIndex || 0];\n    this.current.element = element;\n\n    this.showMenuFor(element);\n  }\n\n  // TODO: make sure this works for inputs/textareas\n  placeCaretAtEnd(el) {\n    el.focus();\n    if (\n      typeof window.getSelection !== \"undefined\" &&\n      typeof this.range.getDocument().createRange !== \"undefined\"\n    ) {\n      const range = this.range.getDocument().createRange();\n      range.selectNodeContents(el);\n      range.collapse(false);\n      const sel = window.getSelection();\n      sel.removeAllRanges();\n      sel.addRange(range);\n    } else if (\n      typeof this.range.getDocument().body.createTextRange !== \"undefined\"\n    ) {\n      const textRange = this.range.getDocument().body.createTextRange();\n      textRange.moveToElementText(el);\n      textRange.collapse(false);\n      textRange.select();\n    }\n  }\n\n  // for contenteditable\n  insertTextAtCursor(text) {\n    const sel = window.getSelection();\n    const range = sel.getRangeAt(0);\n    range.deleteContents();\n    const textNode = this.range.getDocument().createTextNode(text);\n    range.insertNode(textNode);\n    range.selectNodeContents(textNode);\n    range.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n\n  // for regular inputs\n  insertAtCaret(textarea, text) {\n    const scrollPos = textarea.scrollTop;\n    let caretPos = textarea.selectionStart;\n\n    const front = textarea.value.substring(0, caretPos);\n    const back = textarea.value.substring(\n      textarea.selectionEnd,\n      textarea.value.length\n    );\n    textarea.value = front + text + back;\n    caretPos = caretPos + text.length;\n    textarea.selectionStart = caretPos;\n    textarea.selectionEnd = caretPos;\n    textarea.focus();\n    textarea.scrollTop = scrollPos;\n  }\n\n  hideMenu() {\n    if (this.menu) {\n      this.menu.remove();\n      this.menu = null;\n    }\n    this.isActive = false;\n    this.activationPending = false;\n    this.current = {};\n  }\n\n  selectItemAtIndex(index, originalEvent) {\n    index = parseInt(index);\n    if (!(typeof index !== \"number\" || isNaN(index) || !originalEvent.target)) {\n      const item = this.current.filteredItems[index];\n      const content = this.current.collection.selectTemplate(item);\n      if (content !== null) this.replaceText(content, originalEvent, item);\n    }\n    this.hideMenu();\n  }\n\n  replaceText(content, originalEvent, item) {\n    this.range.replaceTriggerText(content, originalEvent, item);\n  }\n\n  _append(collection, newValues, replace) {\n    if (typeof collection.values === \"function\") {\n      throw new Error(\"Unable to append to values, as it is a function.\");\n    } else if (!replace) {\n      collection.values = collection.values.concat(newValues);\n    } else {\n      collection.values = newValues;\n    }\n  }\n\n  append(collectionIndex, newValues, replace) {\n    const index = parseInt(collectionIndex);\n    if (typeof index !== \"number\")\n      throw new Error(\"please provide an index for the collection to update.\");\n\n    const collection = this.collection[index];\n\n    this._append(collection, newValues, replace);\n  }\n\n  appendCurrent(newValues, replace) {\n    if (this.isActive) {\n      this._append(this.current.collection, newValues, replace);\n    } else {\n      throw new Error(\n        \"No active state. Please use append instead and pass an index.\"\n      );\n    }\n  }\n\n  detach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._detach(el[i]);\n      }\n    } else {\n      this._detach(el);\n    }\n  }\n\n  _detach(el) {\n    this.events.unbind(el);\n    if (el.tributeMenu) {\n      this.menuEvents.unbind(el.tributeMenu);\n    }\n\n    setTimeout(() => {\n      el.removeAttribute(\"data-tribute\");\n      this.isActive = false;\n      if (el.tributeMenu) {\n        el.tributeMenu.remove();\n      }\n    });\n  }\n\n  debounce(func, timeout) {\n    let timer;\n    return (...args) => {\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        func.apply(this, args);\n      }, timeout);\n    };\n  }\n}\n\nexport default Tribute;\n"],"names":["CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","Array","prototype","find","Object","defineProperty","value","predicate","this","TypeError","o","len","length","thisArg","arguments","k","kValue","call","configurable","writable","window","Event","TributeEvents","constructor","tribute","events","bind","element","boundKeyDown","keydown","boundKeyUpInput","debounce","input","addEventListener","unbind","removeEventListener","instance","shouldDeactivate","hideMenu","KeyboardEvent","controlKeyPressed","modifiers","forEach","getModifierState","isActive","keys","key","code","callbacks","keyup","click","menu","contains","target","li","preventDefault","stopImmediatePropagation","nodeName","toLowerCase","parentNode","Error","selectItemAtIndex","getAttribute","updateSelection","allowSpaces","hasTrailingSpace","Space","keyCode","getKeyCode","isNaN","autocompleteMode","current","collection","trigger","triggers","charCodeAt","item","menuShowMinLength","mentionText","showMenuFor","which","mentionTriggerChar","NaN","el","info","range","getTriggerInfo","mentionPosition","fullText","Enter","e","_el","filteredItems","menuSelected","Escape","Tab","spaceSelectsMatch","setTimeout","ArrowUp","count","selected","setActiveLi","scrollTop","scrollHeight","ArrowDown","Delete","index","lis","querySelectorAll","parseInt","i","classList","add","selectClass","liClientRect","getBoundingClientRect","menuClientRect","bottom","scrollDistance","top","remove","getFullHeight","elem","includeMargin","height","style","currentStyle","getComputedStyle","parseFloat","marginTop","marginBottom","TributeMenuEvents","menuEvents","_menu","menuClickEvent","menuContainerScrollEvent","windowResizeEvent","windowBlurEvent","getDocument","menuContainer","TributeRange","iframe","contentWindow","positionMenuAtCaret","scrollTo","context","coordinates","positionMenu","isContentEditable","getContentEditableCaretPosition","getTextAreaOrInputUnderlinePosition","left","right","maxHeight","maxWidth","position","display","scrollIntoView","body","replaceTriggerText","text","originalEvent","replaceEvent","replaceTextSuffix","strippedText","stripHtml","pasteHtml","pasteText","textEndsWithSpace","trimEnd","myField","textSuffix","startPos","endPos","substring","selectionStart","selectionEnd","dispatchEvent","numOfCharsToRemove","sel","getContentEditableSelectionStart","pre","anchorNode","nodeValue","anchorOffset","post","setStart","collapse","removeAllRanges","addRange","collapseToEnd","html","modify","getRangeAt","deleteContents","createElement","innerHTML","frag","createDocumentFragment","node","lastNode","firstChild","appendChild","insertNode","setEnd","tmp","textContent","innerText","getWindowSelection","getSelection","rootNode","getRootNode","moveToEndOfWord","isCollapsed","direction","focusOffset","selectedElem","workingNodeContent","selectStartOffset","startOffset","nextChar","nextSibling","nextNodeText","nextCharIsSeparator","match","autocompleteSeparator","getWholeWordsUpToCharIndex","str","minLen","pos","arr","split","filter","trim","idx","indexOf","slice","getTextPrecedingCurrentSelection","lastChar","Math","max","addWhiteSpace","toString","numberOfWordsInContextText","newText","endsWith","restoreSelection","textComponent","getLastWordInText","separator","wordsArray","menuAlreadyActive","requireLeadingSpace","isAutocomplete","effectiveRange","lastWordOfEffectiveRange","triggerChar","mostRecentTriggerCharPos","config","c","lastIndexWithLeadingSpace","lastIndexOf","test","currentTriggerSnippet","firstSnippetChar","leadingSpace","regex","reversedStr","reverse","join","cidx","firstChar","triggerIdx","isMenuOffScreen","menuDimensions","windowWidth","innerWidth","windowHeight","innerHeight","doc","documentElement","windowLeft","pageXOffset","scrollLeft","clientLeft","windowTop","pageYOffset","clientTop","menuTop","menuRight","width","menuBottom","menuLeft","floor","ceil","getMenuDimensions","dimensions","visibility","offsetWidth","offsetHeight","_flipped","div","id","computed","whiteSpace","wordWrap","prop","span0","replace","span","span2","rect","spanRect","divRect","removeChild","clamp","number","min","finalRect","getFixedCoordinatesRelativeToRect","_selectedNodePosition","newRange","parentNodeRect","availableSpaceOnTop","availableSpaceOnBottom","availableSpaceOnLeft","availableSpaceOnRight","_elem","clientRect","childNodes","elemTop","elemBottom","maxY","targetY","directionFwd","endRange","cloneRange","extend","startContainer","TributeSearch","search","simpleFilter","pattern","array","string","opts","compareString","caseSensitive","skip","rendered","score","patternCache","traverse","render","cache","stringIndex","patternIndex","splice","calculateScore","best","temp","push","pop","indices","reduce","prev","_arr","extract","original","sort","a","b","compare","Tribute","values","loadingItemTemplate","containerClass","itemClass","selectTemplate","menuItemTemplate","lookup","fillAttr","noMatchTemplate","searchOpts","menuItemLimit","activationPending","defaultSelectTemplate","defaultMenuItemTemplate","t","console","warn","map","_isActive","val","noMatchEvent","matchItem","attach","jQuery","get","NodeList","HTMLCollection","_attach","hasAttribute","ensureEditable","setAttribute","inputTypes","contentEditable","createMenu","wrapper","ul","className","fontSize","round","currentMentionTextSnapshot","tributeMenu","processValues","forceReplace","activeElement","repeat","replaceText","items","querySelector","showMenu","fragment","_findLiTarget","movementY","showMenuForCollection","collectionIndex","placeCaretAtEnd","insertTextAtCursor","insertAtCaret","focus","createRange","selectNodeContents","createTextRange","textRange","moveToElementText","select","textNode","createTextNode","textarea","scrollPos","caretPos","front","back","content","_append","newValues","concat","append","appendCurrent","detach","_detach","removeAttribute","func","timeout","timer","args","clearTimeout","apply"],"mappings":"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"}