{"version":3,"file":"tribute.min.js","sources":["../src/utils.js","../src/TributeEvents.js","../src/TributeMenuEvents.js","../src/TributeRange.js","../src/TributeSearch.js","../src/Tribute.js"],"sourcesContent":["if (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, \"find\", {\n    value: function (predicate) {\n      // 1. Let O be ? ToObject(this value).\n      if (this === null) {\n        throw TypeError('\"this\" is null or not defined');\n      }\n\n      const o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      const len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== \"function\") {\n        throw TypeError(\"predicate must be a function\");\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      const thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      let k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n        // d. If testResult is true, return kValue.\n        const kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return undefined.\n      return undefined;\n    },\n    configurable: true,\n    writable: true,\n  });\n}\n\nfunction CustomEvent(event, params) {\n  params = params || {\n    bubbles: false,\n    cancelable: false,\n    detail: undefined,\n  };\n  const evt = document.createEvent(\"CustomEvent\");\n  evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n  return evt;\n}\n\nif (typeof window !== \"undefined\" && typeof window.CustomEvent !== \"function\") {\n  if (typeof window.Event !== \"undefined\") {\n    CustomEvent.prototype = window.Event.prototype;\n  }\n\n  window.CustomEvent = CustomEvent;\n}\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\nclass TributeEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.events = this;\n  }\n\n  static keys() {\n    return [\n      {\n        key: 9,\n        value: \"TAB\",\n      },\n      {\n        key: 13,\n        value: \"ENTER\",\n      },\n      {\n        key: 27,\n        value: \"ESCAPE\",\n      },\n      {\n        key: 38,\n        value: \"UP\",\n      },\n      {\n        key: 40,\n        value: \"DOWN\",\n      },\n    ];\n  }\n\n  static modifiers() {\n    return [\n      \"CapsLock\",\n      \"Control\",\n      \"Fn\",\n      \"Hyper\",\n      \"Meta\",\n      \"OS\",\n      \"Super\",\n      \"Symbol\",\n      \"Win\",\n    ];\n  }\n\n  bind(element) {\n    element.boundKeyDown = this.keydown.bind(element, this);\n    element.boundKeyUp = this.keyup.bind(element, this);\n    element.boundInput = this.input.bind(element, this);\n\n    element.addEventListener(\"keydown\", element.boundKeyDown, true);\n    element.addEventListener(\"keyup\", element.boundKeyUp, true);\n    element.addEventListener(\"input\", element.boundInput, true);\n  }\n\n  unbind(element) {\n    element.removeEventListener(\"keydown\", element.boundKeyDown, true);\n    element.removeEventListener(\"keyup\", element.boundKeyUp, true);\n    element.removeEventListener(\"input\", element.boundInput, true);\n\n    delete element.boundKeyDown;\n    delete element.boundKeyUp;\n    delete element.boundInput;\n  }\n\n  keydown(instance, event) {\n    if (instance.shouldDeactivate(event)) {\n      instance.tribute.hideMenu();\n    }\n    if (event instanceof KeyboardEvent) {\n      let controlKeyPressed = false;\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      if (controlKeyPressed) return;\n    }\n\n    if (instance.tribute.isActive) {\n      TributeEvents.keys().forEach((o) => {\n        if (o.key === event.keyCode) {\n          instance.callbacks()[o.value.toLowerCase()](event, this);\n        }\n      });\n    }\n  }\n\n  input(instance, event) {\n    if (event instanceof CustomEvent) {\n      const str = event.detail.text;\n      event.keyCode = str.charCodeAt(str.length - 1);\n      setTimeout(instance.keyup.bind(this, instance, event), 0);\n    } else instance.keyup.call(this, instance, event);\n  }\n\n  click(instance, event) {\n    const tribute = instance.tribute;\n    if (tribute.menu && tribute.menu.contains(event.target)) {\n      let li = event.target;\n      event.preventDefault();\n      event.stopPropagation();\n      while (li.nodeName.toLowerCase() !== \"li\") {\n        li = li.parentNode;\n        if (!li || li === tribute.menu) {\n          throw new Error(\"cannot find the <li> container for the click\");\n        }\n      }\n\n      tribute.selectItemAtIndex(li.getAttribute(\"data-index\"), event);\n      // TODO: should fire with externalTrigger and target is outside of menu\n    } else if (tribute.current.element && !tribute.current.externalTrigger) {\n      tribute.current.externalTrigger = false;\n      tribute.hideMenu();\n    }\n  }\n\n  keyup(instance, event) {\n    if (!instance.updateSelection(this)) return;\n    const keyCode = instance.getKeyCode(instance, this, event);\n    // Check for modifiers keys\n    if (event instanceof KeyboardEvent) {\n      let controlKeyPressed = false;\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      // Check for control keys\n      TributeEvents.keys().forEach((o) => {\n        if (o.key === keyCode) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      if (controlKeyPressed) return;\n    }\n\n    if (!instance.tribute.allowSpaces && instance.tribute.hasTrailingSpace) {\n      instance.tribute.hasTrailingSpace = false;\n      instance.callbacks()[\"space\"](event, this);\n      return;\n    }\n\n    // Get and validate trigger char\n    if (keyCode && !isNaN(keyCode)) {\n      if (\n        instance.tribute.autocompleteMode &&\n        String.fromCharCode(keyCode).match(/(\\w|\\s)/g)\n      ) {\n        instance.tribute.current.trigger = \"\";\n      } else {\n        instance.tribute.current.trigger = instance.tribute\n          .triggers()\n          .find((trigger) => {\n            return trigger.charCodeAt(0) === keyCode;\n          });\n      }\n    } else if (\n      instance.tribute.autocompleteMode &&\n      event instanceof InputEvent\n    ) {\n      instance.tribute.current.trigger = \"\";\n    }\n    if (\n      !(\n        instance.tribute.current.trigger ||\n        (instance.tribute.current.trigger === \"\" &&\n          instance.tribute.autocompleteMode)\n      )\n    )\n      return;\n\n    // Get and validate collection\n    instance.tribute.current.collection = instance.tribute.collection.find(\n      (item) => {\n        return item.trigger === instance.tribute.current.trigger;\n      }\n    );\n    if (\n      !instance.tribute.current.collection ||\n      instance.tribute.current.collection.menuShowMinLength >\n        instance.tribute.current.mentionText.length\n    ) {\n      return;\n    }\n\n    instance.tribute.showMenuFor(this, true);\n  }\n\n  shouldDeactivate(event) {\n    let controlKeyPressed = false;\n    TributeEvents.keys().forEach((o) => {\n      if (event.keyCode === o.key) {\n        controlKeyPressed = true;\n        return;\n      }\n    });\n\n    if (controlKeyPressed) return false;\n    if (this.tribute.isActive) return true;\n\n    return false;\n  }\n\n  getKeyCode(instance, el, event) {\n    const tribute = instance.tribute;\n    const info = tribute.range.getTriggerInfo(\n      false,\n      tribute.hasTrailingSpace,\n      true,\n      tribute.allowSpaces,\n      tribute.autocompleteMode\n    );\n\n    if (event.keyCode || event.which || event.code) {\n      return event.keyCode || event.which || event.code;\n    } else if (info) {\n      if (info.mentionTriggerChar) return info.mentionTriggerChar.charCodeAt(0);\n      else return info.mentionText.charCodeAt(info.mentionText.length - 1);\n    } else {\n      return NaN;\n    }\n  }\n\n  updateSelection(el) {\n    let success = false;\n    this.tribute.current.element = el;\n    const info = this.tribute.range.getTriggerInfo(\n      false,\n      this.tribute.hasTrailingSpace,\n      true,\n      this.tribute.allowSpaces,\n      this.tribute.autocompleteMode\n    );\n\n    if (info) {\n      this.tribute.current.selectedPath = info.mentionSelectedPath;\n      this.tribute.current.mentionText = info.mentionText;\n      this.tribute.current.fullText = info.fullText;\n      this.tribute.current.selectedOffset = info.mentionSelectedOffset;\n      this.tribute.current.info = info;\n      success = true;\n    } else {\n      this.tribute.current = {};\n    }\n    return success;\n  }\n\n  callbacks() {\n    return {\n      enter: (e, _el) => {\n        // choose selection\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopPropagation();\n          this.tribute.selectItemAtIndex(this.tribute.menuSelected, e);\n        }\n      },\n      escape: (e, _el) => {\n        if (this.tribute.isActive) {\n          e.preventDefault();\n          e.stopPropagation();\n          this.tribute.hideMenu();\n        }\n      },\n      tab: (e, el) => {\n        // choose first match\n        this.callbacks().enter(e, el);\n      },\n      space: (e, el) => {\n        if (this.tribute.isActive) {\n          if (this.tribute.spaceSelectsMatch) {\n            this.callbacks().enter(e, el);\n          } else if (!this.tribute.allowSpaces) {\n            e.stopPropagation();\n            setTimeout(() => {\n              this.tribute.hideMenu();\n            }, 0);\n          }\n        }\n      },\n      up: (e, _el) => {\n        // navigate up ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopPropagation();\n          const count = this.tribute.current.filteredItems.length,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected && selected > 0) {\n            this.tribute.menuSelected--;\n            this.setActiveLi();\n          } else if (selected === 0) {\n            this.tribute.menuSelected = count - 1;\n            this.setActiveLi();\n            this.tribute.menu.scrollTop = this.tribute.menu.scrollHeight;\n          }\n        }\n      },\n      down: (e, _el) => {\n        // navigate down ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopPropagation();\n          const count = this.tribute.current.filteredItems.length - 1,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected) {\n            this.tribute.menuSelected++;\n            this.setActiveLi();\n          } else if (count === selected) {\n            this.tribute.menuSelected = 0;\n            this.setActiveLi();\n            this.tribute.menu.scrollTop = 0;\n          }\n        }\n      },\n      delete: (e, el) => {\n        if (\n          this.tribute.isActive &&\n          this.tribute.current.mentionText.length < 1\n        ) {\n          this.tribute.hideMenu();\n        } else if (this.tribute.isActive) {\n          this.tribute.showMenuFor(el);\n        }\n      },\n    };\n  }\n\n  setActiveLi(index) {\n    const lis = this.tribute.menu.querySelectorAll(\"li\"),\n      length = lis.length >>> 0;\n\n    if (index) this.tribute.menuSelected = parseInt(index);\n\n    for (let i = 0; i < length; i++) {\n      const li = lis[i];\n      if (i === this.tribute.menuSelected) {\n        li.classList.add(this.tribute.current.collection.selectClass);\n\n        const liClientRect = li.getBoundingClientRect();\n        const menuClientRect = this.tribute.menu.getBoundingClientRect();\n\n        if (liClientRect.bottom > menuClientRect.bottom) {\n          const scrollDistance = liClientRect.bottom - menuClientRect.bottom;\n          this.tribute.menu.scrollTop += scrollDistance;\n        } else if (liClientRect.top < menuClientRect.top) {\n          const scrollDistance = menuClientRect.top - liClientRect.top;\n          this.tribute.menu.scrollTop -= scrollDistance;\n        }\n      } else {\n        li.classList.remove(this.tribute.current.collection.selectClass);\n      }\n    }\n  }\n\n  getFullHeight(elem, includeMargin) {\n    const height = elem.getBoundingClientRect().height;\n\n    if (includeMargin) {\n      const style = elem.currentStyle || window.getComputedStyle(elem);\n      return (\n        height + parseFloat(style.marginTop) + parseFloat(style.marginBottom)\n      );\n    }\n\n    return height;\n  }\n}\n\nexport default TributeEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\nclass TributeMenuEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.menuEvents = this;\n    this.menu = this.tribute.menu;\n  }\n\n  bind(_menu) {\n    this.menuClickEvent = this.tribute.events.click.bind(null, this);\n    this.menuContainerScrollEvent = this.debounce(\n      () => {\n        this.tribute.hideMenu();\n      },\n      10,\n      false\n    );\n    this.windowResizeEvent = this.debounce(\n      () => {\n        this.tribute.hideMenu();\n      },\n      10,\n      false\n    );\n\n    this.windowBlurEvent = () => {\n      this.tribute.hideMenu();\n    };\n\n    // fixes IE11 issues with mousedown\n    this.tribute.range\n      .getDocument()\n      .addEventListener(\"MSPointerDown\", this.menuClickEvent, false);\n    this.tribute.range\n      .getDocument()\n      .addEventListener(\"mousedown\", this.menuClickEvent, false);\n    window.addEventListener(\"resize\", this.windowResizeEvent);\n    window.addEventListener(\"blur\", this.windowBlurEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.addEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.addEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n\n  unbind(_menu) {\n    this.tribute.range\n      .getDocument()\n      .removeEventListener(\"mousedown\", this.menuClickEvent, false);\n    this.tribute.range\n      .getDocument()\n      .removeEventListener(\"MSPointerDown\", this.menuClickEvent, false);\n    window.removeEventListener(\"resize\", this.windowResizeEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.removeEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.removeEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n\n  debounce(func, wait, immediate) {\n    let timeout;\n    return () => {\n      const context = this,\n        args = arguments;\n      const later = () => {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      const callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n    };\n  }\n}\n\nexport default TributeMenuEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/jeff-collins/ment.io\nimport \"./utils\";\n\nclass TributeRange {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.range = this;\n  }\n\n  getDocument() {\n    let iframe;\n    if (this.tribute.current.collection) {\n      iframe = this.tribute.current.collection.iframe;\n    }\n\n    if (!iframe) {\n      return document;\n    }\n\n    return iframe.contentWindow.document;\n  }\n\n  positionMenuAtCaret(scrollTo) {\n    const context = this.tribute.current;\n    let coordinates;\n\n    const info = this.getTriggerInfo(\n      false,\n      this.tribute.hasTrailingSpace,\n      true,\n      this.tribute.allowSpaces,\n      this.tribute.autocompleteMode\n    );\n\n    if (typeof info !== \"undefined\") {\n      if (!this.tribute.positionMenu) {\n        this.tribute.menu.style.display = `block`;\n        return;\n      }\n\n      if (!this.isContentEditable(context.element)) {\n        coordinates = this.getTextAreaOrInputUnderlinePosition(\n          this.tribute.current.element,\n          info.mentionPosition + info.mentionText.length\n        );\n      } else {\n        coordinates = this.getContentEditableCaretPosition(\n          info.mentionPosition + info.mentionText.length\n        );\n      }\n\n      this.tribute.menu.style.top = `${coordinates.top}px`;\n      this.tribute.menu.style.left = `${coordinates.left}px`;\n      this.tribute.menu.style.right = `${coordinates.right}px`;\n      this.tribute.menu.style.bottom = `${coordinates.bottom}px`;\n      this.tribute.menu.style[\"max-heigh\"] = `${\n        coordinates.maxHeight || 500\n      }px`;\n      this.tribute.menu.style[\"max-width\"] = `${coordinates.maxWidth || 300}px`;\n      this.tribute.menu.style.position = `${\n        coordinates.position || \"absolute\"\n      }`;\n      this.tribute.menu.style.display = `block`;\n\n      if (coordinates.left === \"auto\") {\n        this.tribute.menu.style.left = \"auto\";\n      }\n\n      if (coordinates.top === \"auto\") {\n        this.tribute.menu.style.top = \"auto\";\n      }\n\n      if (scrollTo) this.scrollIntoView();\n    } else {\n      this.tribute.menu.style.display = \"none\";\n    }\n  }\n\n  get menuContainerIsBody() {\n    return (\n      this.tribute.menuContainer === document.body ||\n      !this.tribute.menuContainer\n    );\n  }\n\n  selectElement(targetElement, path, offset) {\n    let elem = targetElement;\n\n    if (path) {\n      for (let i = 0; i < path.length; i++) {\n        elem = elem.childNodes[path[i]];\n        if (elem === undefined) {\n          return;\n        }\n        while (elem.length < offset) {\n          offset -= elem.length;\n          elem = elem.nextSibling;\n        }\n        if (elem.childNodes.length === 0 && !elem.length) {\n          elem = elem.previousSibling;\n        }\n      }\n    }\n    const sel = this.getWindowSelection();\n    const range = this.getDocument().createRange();\n    range.setStart(elem, offset);\n    range.setEnd(elem, offset);\n    range.collapse(true);\n\n    try {\n      sel.removeAllRanges();\n    } catch (error) {\n      console.error(error);\n    }\n\n    sel.addRange(range);\n    targetElement.focus();\n  }\n\n  replaceTriggerText(\n    text,\n    requireLeadingSpace,\n    hasTrailingSpace,\n    originalEvent,\n    item\n  ) {\n    const info = this.tribute.current.info; //this.getTriggerInfo(true, hasTrailingSpace, requireLeadingSpace, this.tribute.allowSpaces, this.tribute.autocompleteMode)\n\n    if (info !== undefined) {\n      const context = this.tribute.current;\n      const detail = {\n        item: item,\n        instance: context,\n        context: info,\n        event: originalEvent,\n        text: text,\n      };\n      const replaceEvent = new CustomEvent(\"tribute-replaced\", {\n        detail: detail,\n      });\n\n      if (!this.isContentEditable(context.element)) {\n        const textEndsWithSpace = text !== text.trimEnd();\n        const myField = this.tribute.current.element;\n        const textSuffix =\n          typeof this.tribute.replaceTextSuffix === \"string\"\n            ? this.tribute.replaceTextSuffix\n            : \" \";\n        text = this.stripHtml(text);\n        text += textSuffix;\n        const startPos = info.mentionPosition;\n        let endPos =\n          info.mentionPosition +\n          info.mentionText.length +\n          textSuffix.length +\n          textEndsWithSpace;\n        if (!this.tribute.autocompleteMode) {\n          endPos += info.mentionTriggerChar.length - 1;\n        }\n        myField.value =\n          myField.value.substring(0, startPos) +\n          text +\n          myField.value.substring(endPos, myField.value.length);\n        myField.selectionStart = startPos + text.length;\n        myField.selectionEnd = startPos + text.length;\n      } else {\n        // add a space to the end of the pasted text\n        const textEndsWithSpace = text !== text.trimEnd();\n        const textSuffix =\n          typeof this.tribute.replaceTextSuffix === \"string\"\n            ? this.tribute.replaceTextSuffix\n            : \"\\xA0\";\n        text += textSuffix;\n        let endPos =\n          info.mentionPosition + info.mentionText.length + textEndsWithSpace;\n        if (!this.tribute.autocompleteMode) {\n          endPos += info.mentionTriggerChar.length;\n        }\n        this.tribute.useHTML\n          ? this.pasteHtml(text, info.mentionPosition, endPos)\n          : this.pasteText(text, info.mentionPosition, endPos);\n      }\n\n      context.element.dispatchEvent(\n        new CustomEvent(\"input\", { bubbles: true, detail: detail })\n      );\n      context.element.dispatchEvent(replaceEvent);\n    }\n  }\n\n  pasteHtml(html, startPos, endPos) {\n    const sel = this.getWindowSelection();\n    const range = this.getDocument().createRange();\n    range.setStart(sel.anchorNode, startPos);\n    range.setEnd(sel.anchorNode, Math.min(endPos, sel.anchorNode.length));\n    range.deleteContents();\n\n    const el = this.getDocument().createElement(\"div\");\n    el.innerHTML = html;\n    const frag = this.getDocument().createDocumentFragment();\n    let node, lastNode;\n\n    while ((node = el.firstChild)) {\n      lastNode = frag.appendChild(node);\n    }\n    range.insertNode(frag);\n\n    // Preserve the selection\n    if (lastNode) {\n      const newRange = this.getDocument().createRange();\n      newRange.setStart(lastNode, lastNode.length);\n      newRange.collapse(true);\n      sel.removeAllRanges();\n      sel.addRange(newRange);\n      sel.collapseToEnd();\n    }\n  }\n\n  stripHtml(html) {\n    const tmp = document.createElement(\"DIV\");\n    tmp.innerHTML = html;\n    return tmp.textContent || tmp.innerText || \"\";\n  }\n\n  pasteText(html, startPos, endPos) {\n    const text = this.stripHtml(html);\n    const range = this.getDocument().createRange();\n    const sel = this.getWindowSelection();\n    sel.anchorNode.nodeValue =\n      sel.anchorNode.nodeValue.substring(0, startPos) +\n      text +\n      sel.anchorNode.nodeValue.substring(\n        endPos,\n        sel.anchorNode.nodeValue.length\n      );\n    range.setStart(sel.anchorNode, startPos + text.length);\n    range.collapse(true);\n    sel.removeAllRanges();\n    sel.addRange(range);\n    sel.collapseToEnd();\n  }\n\n  getWindowSelection() {\n    if (this.tribute.collection.iframe) {\n      return this.tribute.collection.iframe.contentWindow.getSelection();\n    }\n\n    const rootNode = this.tribute.current.element.getRootNode();\n    if (rootNode.getSelection) return rootNode.getSelection();\n    else return window.getSelection();\n  }\n\n  getNodePositionInParent(element) {\n    if (element.parentNode === null) {\n      return 0;\n    }\n\n    for (let i = 0; i < element.parentNode.childNodes.length; i++) {\n      const node = element.parentNode.childNodes[i];\n\n      if (node === element) {\n        return i;\n      }\n    }\n  }\n\n  getContentEditableSelectedPath(_ctx) {\n    const sel = this.getWindowSelection();\n    let selected = sel.anchorNode;\n    const path = [];\n    let offset;\n\n    if (selected !== null) {\n      let i;\n      let ce = selected.contentEditable;\n      while (selected !== null && ce !== \"true\") {\n        i = this.getNodePositionInParent(selected);\n        path.push(i);\n        selected = selected.parentNode;\n        if (selected !== null) {\n          ce = selected.contentEditable;\n        }\n      }\n      path.reverse();\n\n      // getRangeAt may not exist, need alternative\n      offset = sel.getRangeAt(0).startOffset;\n\n      return {\n        selected: selected,\n        path: path,\n        offset: offset,\n      };\n    }\n  }\n\n  getWholeWordsUpToCharIndex(str, minLen) {\n    let pos = 0;\n    const arr = str\n      .split(this.tribute.autocompleteSeparator)\n      .filter(function (e) {\n        return e.trim();\n      });\n    const text = str;\n    for (let i = 0, len = arr.length; i < len; i++) {\n      const idx = str.indexOf(arr[i]);\n      pos = pos + idx;\n      str = str.slice(idx);\n      if (minLen >= pos && minLen <= pos + arr[i].length) {\n        minLen = pos + arr[i].length;\n        break;\n      }\n    }\n\n    return text.substring(0, minLen);\n  }\n  getTextPrecedingCurrentSelection() {\n    const context = this.tribute.current;\n    let text = \"\";\n\n    if (!this.isContentEditable(context.element)) {\n      const textComponent = this.tribute.current.element;\n      if (textComponent) {\n        const startPos = textComponent.selectionStart;\n        if (textComponent.value && startPos >= 0) {\n          text = textComponent.value.substring(0);\n          text = this.getWholeWordsUpToCharIndex(text, startPos);\n        }\n      }\n    } else {\n      const selectedElem = this.getWindowSelection().anchorNode;\n\n      if (selectedElem !== null) {\n        const workingNodeContent = selectedElem.textContent;\n        const selectStartOffset =\n          this.getWindowSelection().getRangeAt(0).startOffset;\n\n        if (workingNodeContent && selectStartOffset >= 0) {\n          text = workingNodeContent.substring(0);\n          text = this.getWholeWordsUpToCharIndex(text, selectStartOffset);\n        }\n      }\n    }\n\n    return text;\n  }\n\n  getLastWordInText(text) {\n    const separator = this.tribute.autocompleteSeparator\n      ? this.tribute.autocompleteSeparator\n      : /\\s+/;\n    const wordsArray = text.split(separator);\n\n    if (!wordsArray.length) return \" \";\n    return wordsArray[wordsArray.length - 1];\n  }\n\n  getTriggerInfo(\n    menuAlreadyActive,\n    hasTrailingSpace,\n    requireLeadingSpace,\n    allowSpaces,\n    isAutocomplete\n  ) {\n    const ctx = this.tribute.current;\n    let selected, path, offset;\n\n    if (!this.isContentEditable(ctx.element)) {\n      selected = this.tribute.current.element;\n    } else {\n      const selectionInfo = this.getContentEditableSelectedPath(ctx);\n\n      if (selectionInfo) {\n        selected = selectionInfo.selected;\n        path = selectionInfo.path;\n        offset = selectionInfo.offset;\n      }\n    }\n\n    const effectiveRange = this.getTextPrecedingCurrentSelection();\n    const lastWordOfEffectiveRange = this.getLastWordInText(effectiveRange);\n\n    if (isAutocomplete) {\n      return {\n        mentionPosition:\n          effectiveRange.length - lastWordOfEffectiveRange.length,\n        mentionText: lastWordOfEffectiveRange,\n        fullText: effectiveRange,\n        mentionSelectedElement: selected,\n        mentionSelectedPath: path,\n        mentionSelectedOffset: offset,\n      };\n    }\n\n    if (effectiveRange !== undefined && effectiveRange !== null) {\n      let mostRecentTriggerCharPos = -1;\n      let triggerChar;\n\n      this.tribute.collection.forEach((config) => {\n        const c = config.trigger;\n        const idx = config.requireLeadingSpace\n          ? this.lastIndexWithLeadingSpace(effectiveRange, c)\n          : effectiveRange.lastIndexOf(c);\n\n        if (idx > mostRecentTriggerCharPos) {\n          mostRecentTriggerCharPos = idx;\n          triggerChar = c;\n          requireLeadingSpace = config.requireLeadingSpace;\n        }\n      });\n\n      if (\n        mostRecentTriggerCharPos >= 0 &&\n        (mostRecentTriggerCharPos === 0 ||\n          !requireLeadingSpace ||\n          /\\s/.test(\n            effectiveRange.substring(\n              mostRecentTriggerCharPos - 1,\n              mostRecentTriggerCharPos\n            )\n          ))\n      ) {\n        let currentTriggerSnippet = effectiveRange.substring(\n          mostRecentTriggerCharPos + triggerChar.length,\n          effectiveRange.length\n        );\n\n        triggerChar = effectiveRange.substring(\n          mostRecentTriggerCharPos,\n          mostRecentTriggerCharPos + triggerChar.length\n        );\n        const firstSnippetChar = currentTriggerSnippet.substring(0, 1);\n        const leadingSpace =\n          currentTriggerSnippet.length > 0 &&\n          (firstSnippetChar === \" \" || firstSnippetChar === \"\\xA0\");\n        if (hasTrailingSpace) {\n          currentTriggerSnippet = currentTriggerSnippet.trim();\n        }\n\n        const regex = allowSpaces ? /[^\\S ]/g : /[\\xA0\\s]/g;\n\n        this.tribute.hasTrailingSpace = regex.test(currentTriggerSnippet);\n\n        if (\n          !leadingSpace &&\n          (menuAlreadyActive || !regex.test(currentTriggerSnippet))\n        ) {\n          return {\n            mentionPosition: mostRecentTriggerCharPos,\n            mentionText: currentTriggerSnippet,\n            mentionSelectedElement: selected,\n            mentionSelectedPath: path,\n            mentionSelectedOffset: offset,\n            mentionTriggerChar: triggerChar,\n          };\n        }\n      }\n    }\n  }\n\n  lastIndexWithLeadingSpace(str, trigger) {\n    const reversedStr = str.split(\"\").reverse().join(\"\");\n    let index = -1;\n\n    for (let cidx = 0, len = str.length; cidx < len; cidx++) {\n      const firstChar = cidx === str.length - 1;\n      const leadingSpace = /\\s/.test(reversedStr[cidx + 1]);\n\n      let match = true;\n      for (let triggerIdx = trigger.length - 1; triggerIdx >= 0; triggerIdx--) {\n        if (trigger[triggerIdx] !== reversedStr[cidx - triggerIdx]) {\n          match = false;\n          break;\n        }\n      }\n\n      if (match && (firstChar || leadingSpace)) {\n        index = str.length - 1 - cidx;\n        break;\n      }\n    }\n\n    return index;\n  }\n\n  isContentEditable(element) {\n    return element.nodeName !== \"INPUT\" && element.nodeName !== \"TEXTAREA\";\n  }\n\n  isMenuOffScreen(coordinates, menuDimensions) {\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    const doc = document.documentElement;\n    const windowLeft =\n      (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n    const windowTop =\n      (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n\n    const menuTop =\n      typeof coordinates.top === \"number\"\n        ? coordinates.top\n        : coordinates.bottom - menuDimensions.height;\n    const menuRight =\n      typeof coordinates.right === \"number\"\n        ? coordinates.right\n        : coordinates.left + menuDimensions.width;\n    const menuBottom =\n      typeof coordinates.bottom === \"number\"\n        ? coordinates.bottom\n        : coordinates.top + menuDimensions.height;\n    const menuLeft =\n      typeof coordinates.left === \"number\"\n        ? coordinates.left\n        : coordinates.right - menuDimensions.width;\n\n    return {\n      top: menuTop < Math.floor(windowTop),\n      right: menuRight > Math.ceil(windowLeft + windowWidth),\n      bottom: menuBottom > Math.ceil(windowTop + windowHeight),\n      left: menuLeft < Math.floor(windowLeft),\n    };\n  }\n\n  getMenuDimensions() {\n    // Width of the menu depends of its contents and position\n    // We must check what its width would be without any obstruction\n    // This way, we can achieve good positioning for flipping the menu\n    const dimensions = {\n      width: null,\n      height: null,\n    };\n\n    this.tribute.menu.style.top = `0px`;\n    this.tribute.menu.style.left = `0px`;\n    this.tribute.menu.style.right = null;\n    this.tribute.menu.style.bottom = null;\n    this.tribute.menu.style.position = `fixed`;\n    this.tribute.menu.style.visibility = `hidden`;\n    this.tribute.menu.style.display = `block`;\n\n    dimensions.width = this.tribute.menu.offsetWidth;\n    dimensions.height = this.tribute.menu.offsetHeight;\n\n    this.tribute.menu.style.display = `none`;\n    this.tribute.menu.style.visibility = `visible`;\n\n    return dimensions;\n  }\n\n  getTextAreaOrInputUnderlinePosition(element, position, _flipped) {\n    const properties = [\n      \"direction\",\n      \"boxSizing\",\n      \"width\",\n      \"height\",\n      \"overflowX\",\n      \"overflowY\",\n      \"borderTopWidth\",\n      \"borderRightWidth\",\n      \"borderBottomWidth\",\n      \"borderLeftWidth\",\n      \"borderStyle\",\n      \"paddingTop\",\n      \"paddingRight\",\n      \"paddingBottom\",\n      \"paddingLeft\",\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSize\",\n      \"fontSizeAdjust\",\n      \"lineHeight\",\n      \"fontFamily\",\n      \"textAlign\",\n      \"textTransform\",\n      \"textIndent\",\n      \"textDecoration\",\n      \"letterSpacing\",\n      \"wordSpacing\",\n    ];\n\n    const div = this.getDocument().createElement(\"div\");\n    div.id = \"input-textarea-caret-position-mirror-div\";\n    this.getDocument().body.appendChild(div);\n\n    const style = div.style;\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n\n    style.whiteSpace = \"pre-wrap\";\n    if (element.nodeName !== \"INPUT\") {\n      style.wordWrap = \"break-word\";\n    }\n\n    // position off-screen\n    style.position = \"absolute\";\n    style.visibility = \"hidden\";\n\n    // transfer the element's properties to the div\n    properties.forEach((prop) => {\n      style[prop] = computed[prop];\n    });\n\n    //NOT SURE WHY THIS IS HERE AND IT DOESNT SEEM HELPFUL\n    // if (isFirefox) {\n    //     style.width = `${(parseInt(computed.width) - 2)}px`\n    //     if (element.scrollHeight > parseInt(computed.height))\n    //         style.overflowY = 'scroll'\n    // } else {\n    //     style.overflow = 'hidden'\n    // }\n\n    const span0 = document.createElement(\"span\");\n    span0.textContent = element.value.substring(0, position);\n    div.appendChild(span0);\n\n    if (element.nodeName === \"INPUT\") {\n      div.textContent = div.textContent.replace(/\\s/g, \" \");\n    }\n\n    //Create a span in the div that represents where the cursor\n    //should be\n    const span = this.getDocument().createElement(\"span\");\n    //we give it no content as this represents the cursor\n    div.appendChild(span);\n\n    const span2 = this.getDocument().createElement(\"span\");\n    span2.textContent = element.value.substring(position, position + 1);\n    div.appendChild(span2);\n\n    const rect = element.getBoundingClientRect();\n\n    //position the div exactly over the element\n    //so we can get the bounding client rect for the span and\n    //it should represent exactly where the cursor is\n    div.style.position = \"fixed\";\n    div.style.left = rect.left + \"px\";\n    div.style.top = rect.top + \"px\";\n    div.style.width = rect.width + \"px\";\n    div.style.height = rect.height + \"px\";\n    div.scrollTop = element.scrollTop;\n\n    const spanRect = span.getBoundingClientRect();\n    const divRect = div.getBoundingClientRect();\n    this.getDocument().body.removeChild(div);\n    const clamp = function (number, min, max) {\n      return Math.max(min, Math.min(number, max));\n    };\n    const finalRect = {\n      height: Math.min(divRect.height, spanRect.height),\n      left: clamp(spanRect.left, divRect.left, divRect.left + divRect.width),\n      top: clamp(spanRect.top, divRect.top, divRect.top + divRect.height),\n    };\n    return this.getFixedCoordinatesRelativeToRect(finalRect);\n  }\n\n  getContentEditableCaretPosition(selectedNodePosition) {\n    const sel = this.getWindowSelection();\n    const range = this.getDocument().createRange();\n    const textNode =\n      sel.anchorNode.nodeType === Node.TEXT_NODE\n        ? sel.anchorNode\n        : sel.anchorNode.childNodes[0];\n    range.setStart(textNode, selectedNodePosition);\n    range.setEnd(textNode, selectedNodePosition);\n\n    range.collapse(false);\n\n    const rect = range.getBoundingClientRect();\n\n    return this.getFixedCoordinatesRelativeToRect(rect);\n  }\n\n  getFixedCoordinatesRelativeToRect(rect) {\n    const coordinates = {\n      position: \"fixed\",\n      left: rect.left,\n      top: rect.top + rect.height,\n    };\n\n    const menuDimensions = this.getMenuDimensions();\n\n    const availableSpaceOnTop = rect.top;\n    const availableSpaceOnBottom =\n      window.innerHeight - (rect.top + rect.height);\n\n    //check to see where's the right place to put the menu vertically\n    if (availableSpaceOnBottom < menuDimensions.height) {\n      if (\n        availableSpaceOnTop >= menuDimensions.height ||\n        availableSpaceOnTop > availableSpaceOnBottom\n      ) {\n        coordinates.top = \"auto\";\n        coordinates.bottom = window.innerHeight - rect.top;\n        if (availableSpaceOnBottom < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnTop;\n        }\n      } else {\n        if (availableSpaceOnTop < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnBottom;\n        }\n      }\n    }\n\n    const availableSpaceOnLeft = rect.left;\n    const availableSpaceOnRight = window.innerWidth - rect.left;\n\n    //check to see where's the right place to put the menu horizontally\n    if (availableSpaceOnRight < menuDimensions.width) {\n      if (\n        availableSpaceOnLeft >= menuDimensions.width ||\n        availableSpaceOnLeft > availableSpaceOnRight\n      ) {\n        coordinates.left = \"auto\";\n        coordinates.right = window.innerWidth - rect.left;\n        if (availableSpaceOnRight < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnLeft;\n        }\n      } else {\n        if (availableSpaceOnLeft < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnRight;\n        }\n      }\n    }\n\n    return coordinates;\n  }\n\n  scrollIntoView(_elem) {\n    const reasonableBuffer = 20;\n    const maxScrollDisplacement = 100;\n    let clientRect;\n    let e = this.menu;\n\n    if (typeof e === \"undefined\") return;\n\n    while (clientRect === undefined || clientRect.height === 0) {\n      clientRect = e.getBoundingClientRect();\n\n      if (clientRect.height === 0) {\n        e = e.childNodes[0];\n        if (e === undefined || !e.getBoundingClientRect) {\n          return;\n        }\n      }\n    }\n\n    const elemTop = clientRect.top;\n    const elemBottom = elemTop + clientRect.height;\n\n    if (elemTop < 0) {\n      window.scrollTo(\n        0,\n        window.pageYOffset + clientRect.top - reasonableBuffer\n      );\n    } else if (elemBottom > window.innerHeight) {\n      let maxY = window.pageYOffset + clientRect.top - reasonableBuffer;\n\n      if (maxY - window.pageYOffset > maxScrollDisplacement) {\n        maxY = window.pageYOffset + maxScrollDisplacement;\n      }\n\n      let targetY = window.pageYOffset - (window.innerHeight - elemBottom);\n\n      if (targetY > maxY) {\n        targetY = maxY;\n      }\n\n      window.scrollTo(0, targetY);\n    }\n  }\n}\n\nexport default TributeRange;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/mattyork/fuzzy\nclass TributeSearch {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.search = this;\n  }\n\n  simpleFilter(pattern, array) {\n    return array.filter((string) => {\n      return this.test(pattern, string);\n    });\n  }\n\n  test(pattern, string) {\n    return this.match(pattern, string) !== null;\n  }\n\n  match(pattern, string, opts) {\n    opts = opts || {};\n    const pre = opts.pre || \"\",\n      post = opts.post || \"\",\n      compareString = (opts.caseSensitive && string) || string.toLowerCase();\n\n    if (opts.skip) {\n      return { rendered: string, score: 0 };\n    }\n\n    pattern = (opts.caseSensitive && pattern) || pattern.toLowerCase();\n\n    const patternCache = this.traverse(compareString, pattern, 0, 0, []);\n    if (!patternCache) {\n      return null;\n    }\n    return {\n      rendered: this.render(string, patternCache.cache, pre, post),\n      score: patternCache.score,\n    };\n  }\n\n  traverse(string, pattern, stringIndex, patternIndex, patternCache) {\n    if (this.tribute.autocompleteSeparator) {\n      // if the pattern search at end\n      pattern = pattern.split(this.tribute.autocompleteSeparator).splice(-1)[0];\n    }\n\n    if (pattern.length === patternIndex) {\n      // calculate score and copy the cache containing the indices where it's found\n      return {\n        score: this.calculateScore(patternCache),\n        cache: patternCache.slice(),\n      };\n    }\n\n    // if string at end or remaining pattern > remaining string\n    if (\n      string.length === stringIndex ||\n      pattern.length - patternIndex > string.length - stringIndex\n    ) {\n      return undefined;\n    }\n\n    const c = pattern[patternIndex];\n    let index = string.indexOf(c, stringIndex);\n    let best;\n    let temp;\n\n    while (index > -1) {\n      patternCache.push(index);\n      temp = this.traverse(\n        string,\n        pattern,\n        index + 1,\n        patternIndex + 1,\n        patternCache\n      );\n      patternCache.pop();\n\n      // if downstream traversal failed, return best answer so far\n      if (!temp) {\n        return best;\n      }\n\n      if (!best || best.score < temp.score) {\n        best = temp;\n      }\n\n      index = string.indexOf(c, index + 1);\n    }\n\n    return best;\n  }\n\n  calculateScore(patternCache) {\n    let score = 0;\n    let temp = 1;\n\n    patternCache.forEach((index, i) => {\n      if (i > 0) {\n        if (patternCache[i - 1] + 1 === index) {\n          temp += temp + 1;\n        } else {\n          temp = 1;\n        }\n      }\n\n      score += temp;\n    });\n\n    return score;\n  }\n\n  render(string, indices, pre, post) {\n    let rendered = string.substring(0, indices[0]);\n\n    indices.forEach((index, i) => {\n      rendered +=\n        pre +\n        string[index] +\n        post +\n        string.substring(\n          index + 1,\n          indices[i + 1] ? indices[i + 1] : string.length\n        );\n    });\n\n    return rendered;\n  }\n\n  filter(pattern, arr, opts) {\n    opts = opts || {};\n    return arr\n      .reduce((prev, element, idx, _arr) => {\n        let str = element;\n\n        if (opts.extract) {\n          str = opts.extract(element);\n\n          if (!str) {\n            // take care of undefineds / nulls / etc.\n            str = \"\";\n          }\n        }\n\n        const rendered = this.match(pattern, str, opts);\n\n        if (rendered !== null) {\n          prev[prev.length] = {\n            string: rendered.rendered,\n            score: rendered.score,\n            index: idx,\n            original: element,\n          };\n        }\n\n        return prev;\n      }, [])\n\n      .sort((a, b) => {\n        const compare = b.score - a.score;\n        if (compare) return compare;\n        return a.index - b.index;\n      });\n  }\n}\n\nexport default TributeSearch;\n","import \"./utils\";\nimport TributeEvents from \"./TributeEvents\";\nimport TributeMenuEvents from \"./TributeMenuEvents\";\nimport TributeRange from \"./TributeRange\";\nimport TributeSearch from \"./TributeSearch\";\n\nclass Tribute {\n  constructor({\n    values = null,\n    loadingItemTemplate = null,\n    iframe = null,\n    selectClass = \"highlight\",\n    containerClass = \"tribute-container\",\n    itemClass = \"\",\n    trigger = \"@\",\n    autocompleteMode = false,\n    autocompleteSeparator = null,\n    selectTemplate = null,\n    menuItemTemplate = null,\n    lookup = \"key\",\n    fillAttr = \"value\",\n    collection = null,\n    menuContainer = null,\n    noMatchTemplate = null,\n    requireLeadingSpace = true,\n    allowSpaces = false,\n    replaceTextSuffix = null,\n    positionMenu = true,\n    spaceSelectsMatch = false,\n    searchOpts = {},\n    menuItemLimit = null,\n    menuShowMinLength = 0,\n    keys = null,\n    useHTML = true,\n  }) {\n    this.autocompleteMode = autocompleteMode;\n    this.autocompleteSeparator = autocompleteSeparator;\n    this.menuSelected = 0;\n    this.current = {};\n    this.isActive = false;\n    this.activationPending = false;\n    this.menuContainer = menuContainer;\n    this.allowSpaces = allowSpaces;\n    this.replaceTextSuffix = replaceTextSuffix;\n    this.positionMenu = positionMenu;\n    this.hasTrailingSpace = false;\n    this.spaceSelectsMatch = spaceSelectsMatch;\n    this.useHTML = useHTML;\n    if (keys) {\n      TributeEvents.keys = keys;\n    }\n\n    if (this.autocompleteMode) {\n      trigger = \"\";\n      allowSpaces = false;\n    }\n\n    if (values) {\n      this.collection = [\n        {\n          // symbol that starts the lookup\n          trigger: trigger,\n\n          // is it wrapped in an iframe\n          iframe: iframe,\n\n          // class applied to selected item\n          selectClass: selectClass,\n\n          // class applied to the Container\n          containerClass: containerClass,\n\n          // class applied to each item\n          itemClass: itemClass,\n\n          // function called on select that retuns the content to insert\n          selectTemplate: (\n            selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n\n          // function called that returns content for an item\n          menuItemTemplate: (\n            menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n\n          // column to search against in the object\n          lookup: lookup,\n\n          // column that contains the content to insert by default\n          fillAttr: fillAttr,\n\n          // array of objects or a function returning an array of objects\n          values: values,\n\n          // useful for when values is an async function\n          loadingItemTemplate: loadingItemTemplate,\n\n          requireLeadingSpace: requireLeadingSpace,\n\n          searchOpts: searchOpts,\n\n          menuItemLimit: menuItemLimit,\n\n          menuShowMinLength: menuShowMinLength,\n        },\n      ];\n    } else if (collection) {\n      if (this.autocompleteMode)\n        console.warn(\n          \"Tribute in autocomplete mode does not work for collections\"\n        );\n      this.collection = collection.map((item) => {\n        return {\n          trigger: item.trigger || trigger,\n          iframe: item.iframe || iframe,\n          selectClass: item.selectClass || selectClass,\n          containerClass: item.containerClass || containerClass,\n          itemClass: item.itemClass || itemClass,\n          selectTemplate: (\n            item.selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n          menuItemTemplate: (\n            item.menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n          lookup: item.lookup || lookup,\n          fillAttr: item.fillAttr || fillAttr,\n          values: item.values,\n          loadingItemTemplate: item.loadingItemTemplate,\n          requireLeadingSpace: item.requireLeadingSpace,\n          searchOpts: item.searchOpts || searchOpts,\n          menuItemLimit: item.menuItemLimit || menuItemLimit,\n          menuShowMinLength: item.menuShowMinLength || menuShowMinLength,\n        };\n      });\n    } else {\n      throw new Error(\"[Tribute] No collection specified.\");\n    }\n\n    new TributeRange(this);\n    new TributeEvents(this);\n    new TributeMenuEvents(this);\n    new TributeSearch(this);\n  }\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  set isActive(val) {\n    if (this._isActive !== val) {\n      this._isActive = val;\n      if (this.current.element) {\n        const noMatchEvent = new CustomEvent(`tribute-active-${val}`);\n        this.current.element.dispatchEvent(noMatchEvent);\n      }\n    }\n  }\n\n  static defaultSelectTemplate(item) {\n    if (typeof item === \"undefined\")\n      return `${this.current.collection.trigger}${this.current.mentionText}`;\n    if (this.range.isContentEditable(this.current.element)) {\n      return (\n        '<span class=\"tribute-mention\">' +\n        (this.current.collection.trigger +\n          item.original[this.current.collection.fillAttr]) +\n        \"</span>\"\n      );\n    }\n\n    return (\n      this.current.collection.trigger +\n      item.original[this.current.collection.fillAttr]\n    );\n  }\n\n  static defaultMenuItemTemplate(matchItem) {\n    return matchItem.string;\n  }\n\n  static inputTypes() {\n    return [\"TEXTAREA\", \"INPUT\"];\n  }\n\n  triggers() {\n    return this.collection.map((config) => {\n      return config.trigger;\n    });\n  }\n\n  attach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    /* global jQuery */\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._attach(el[i]);\n      }\n    } else {\n      this._attach(el);\n    }\n  }\n\n  _attach(el) {\n    if (el.hasAttribute(\"data-tribute\")) {\n      console.warn(\"Tribute was already bound to \" + el.nodeName);\n    }\n\n    this.ensureEditable(el);\n    this.events.bind(el);\n    el.setAttribute(\"data-tribute\", true);\n  }\n\n  ensureEditable(element) {\n    if (Tribute.inputTypes().indexOf(element.nodeName) === -1) {\n      if (element.contentEditable) {\n        element.contentEditable = true;\n      } else {\n        throw new Error(\"[Tribute] Cannot bind to \" + element.nodeName);\n      }\n    }\n  }\n\n  createMenu(containerClass, element) {\n    const properties = [\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSizeAdjust\",\n      \"fontFamily\",\n    ];\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n    const wrapper = this.range.getDocument().createElement(\"div\"),\n      ul = this.range.getDocument().createElement(\"ul\");\n    wrapper.className = containerClass;\n    wrapper.setAttribute(\"tabindex\", \"0\");\n    wrapper.appendChild(ul);\n    wrapper.style.fontSize =\n      Math.round(parseInt(computed.fontSize) * 0.9) + \"px\";\n    wrapper.style.display = \"none\";\n\n    properties.forEach((prop) => {\n      wrapper.style[prop] = computed[prop];\n    });\n\n    if (this.menuContainer) {\n      return this.menuContainer.appendChild(wrapper);\n    }\n\n    return this.range.getDocument().body.appendChild(wrapper);\n  }\n\n  showMenuFor(element, scrollTo) {\n    // Only proceed if menu isn't already shown for the current element & mentionText\n    if (\n      this.isActive &&\n      this.current.element === element &&\n      this.current.mentionText === this.currentMentionTextSnapshot\n    ) {\n      return;\n    }\n    this.currentMentionTextSnapshot = this.current.mentionText;\n\n    // create the menu if it doesn't exist.\n    if (!this.menu) {\n      this.menu = this.createMenu(\n        this.current.collection.containerClass,\n        element\n      );\n      element.tributeMenu = this.menu;\n      this.menuEvents.bind(this.menu);\n    }\n\n    this.activationPending = true;\n    this.menuSelected = 0;\n\n    if (!this.current.mentionText) {\n      this.current.mentionText = \"\";\n    }\n\n    const processValues = (values, forceReplace) => {\n      // Tribute may not be active any more by the time the value callback returns\n      if (!this.activationPending) {\n        return;\n      }\n      this.activationPending = false;\n      // Element is no longer in focus - don't show menu\n      if (document.activeElement !== this.current.element) {\n        return;\n      }\n\n      if (forceReplace) {\n        // Do force replace - don't show menu\n        this.current.info.mentionPosition -= forceReplace.length;\n        this.current.info.mentionText =\n          \" \".repeat(forceReplace.length) + this.current.info.mentionText;\n        this.replaceText(forceReplace.text, null, null);\n        return;\n      }\n\n      let items = this.search.filter(this.current.mentionText, values, {\n        pre: this.current.collection.searchOpts.pre || \"<span>\",\n        post: this.current.collection.searchOpts.post || \"</span>\",\n        skip: this.current.collection.searchOpts.skip,\n        extract: (el) => {\n          if (typeof this.current.collection.lookup === \"string\") {\n            return el[this.current.collection.lookup];\n          } else if (typeof this.current.collection.lookup === \"function\") {\n            return this.current.collection.lookup(el, this.current.mentionText);\n          } else {\n            throw new Error(\n              \"Invalid lookup attribute, lookup must be string or function.\"\n            );\n          }\n        },\n      });\n\n      if (this.current.collection.menuItemLimit) {\n        items = items.slice(0, this.current.collection.menuItemLimit);\n      }\n\n      this.current.filteredItems = items;\n\n      const ul = this.menu.querySelector(\"ul\");\n      let showMenu = false;\n\n      if (!items.length) {\n        const noMatchEvent = new CustomEvent(\"tribute-no-match\", {\n          detail: this.menu,\n        });\n        this.current.element.dispatchEvent(noMatchEvent);\n        if (\n          (typeof this.current.collection.noMatchTemplate === \"function\" &&\n            !this.current.collection.noMatchTemplate()) ||\n          !this.current.collection.noMatchTemplate\n        ) {\n          showMenu = false;\n        } else {\n          typeof this.current.collection.noMatchTemplate === \"function\"\n            ? (ul.innerHTML = this.current.collection.noMatchTemplate())\n            : (ul.innerHTML = this.current.collection.noMatchTemplate);\n          showMenu = true;\n        }\n      } else {\n        ul.innerHTML = \"\";\n        const fragment = this.range.getDocument().createDocumentFragment();\n\n        items.forEach((item, index) => {\n          const li = this.range.getDocument().createElement(\"li\");\n          li.setAttribute(\"data-index\", index);\n          li.className = this.current.collection.itemClass;\n          li.addEventListener(\"mousemove\", (e) => {\n            const [, index] = this._findLiTarget(e.target);\n            if (e.movementY !== 0) {\n              this.events.setActiveLi(index);\n            }\n          });\n          if (this.menuSelected === index) {\n            li.classList.add(this.current.collection.selectClass);\n          }\n          li.innerHTML = this.current.collection.menuItemTemplate(item);\n          fragment.appendChild(li);\n        });\n        ul.appendChild(fragment);\n        showMenu = true;\n      }\n      if (showMenu) {\n        this.isActive = true;\n        this.range.positionMenuAtCaret(scrollTo);\n      }\n    };\n\n    if (typeof this.current.collection.values === \"function\") {\n      if (this.current.collection.loadingItemTemplate) {\n        this.menu.querySelector(\"ul\").innerHTML =\n          this.current.collection.loadingItemTemplate;\n        this.range.positionMenuAtCaret(scrollTo);\n      }\n\n      this.current.collection.values(this.current.fullText, processValues);\n    } else {\n      processValues(this.current.collection.values);\n    }\n  }\n\n  _findLiTarget(el) {\n    if (!el) return [];\n    const index = el.getAttribute(\"data-index\");\n    return !index ? this._findLiTarget(el.parentNode) : [el, index];\n  }\n\n  showMenuForCollection(element, collectionIndex) {\n    if (element !== document.activeElement) {\n      this.placeCaretAtEnd(element);\n    }\n\n    this.current.collection = this.collection[collectionIndex || 0];\n    this.current.externalTrigger = true;\n    this.current.element = element;\n\n    if (element.isContentEditable)\n      this.insertTextAtCursor(this.current.collection.trigger);\n    else this.insertAtCaret(element, this.current.collection.trigger);\n\n    this.showMenuFor(element);\n  }\n\n  // TODO: make sure this works for inputs/textareas\n  placeCaretAtEnd(el) {\n    el.focus();\n    if (\n      typeof window.getSelection !== \"undefined\" &&\n      typeof document.createRange !== \"undefined\"\n    ) {\n      const range = document.createRange();\n      range.selectNodeContents(el);\n      range.collapse(false);\n      const sel = window.getSelection();\n      sel.removeAllRanges();\n      sel.addRange(range);\n    } else if (typeof document.body.createTextRange !== \"undefined\") {\n      const textRange = document.body.createTextRange();\n      textRange.moveToElementText(el);\n      textRange.collapse(false);\n      textRange.select();\n    }\n  }\n\n  // for contenteditable\n  insertTextAtCursor(text) {\n    const sel = window.getSelection();\n    const range = sel.getRangeAt(0);\n    range.deleteContents();\n    const textNode = document.createTextNode(text);\n    range.insertNode(textNode);\n    range.selectNodeContents(textNode);\n    range.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n\n  // for regular inputs\n  insertAtCaret(textarea, text) {\n    const scrollPos = textarea.scrollTop;\n    let caretPos = textarea.selectionStart;\n\n    const front = textarea.value.substring(0, caretPos);\n    const back = textarea.value.substring(\n      textarea.selectionEnd,\n      textarea.value.length\n    );\n    textarea.value = front + text + back;\n    caretPos = caretPos + text.length;\n    textarea.selectionStart = caretPos;\n    textarea.selectionEnd = caretPos;\n    textarea.focus();\n    textarea.scrollTop = scrollPos;\n  }\n\n  hideMenu() {\n    if (this.menu) {\n      this.menu.remove();\n      this.menu = null;\n    }\n    this.isActive = false;\n    this.activationPending = false;\n  }\n\n  selectItemAtIndex(index, originalEvent) {\n    this.hideMenu();\n    index = parseInt(index);\n    if (typeof index !== \"number\" || isNaN(index) || !originalEvent.target)\n      return;\n    const item = this.current.filteredItems[index];\n    const content = this.current.collection.selectTemplate(item);\n    if (content !== null) this.replaceText(content, originalEvent, item);\n  }\n\n  replaceText(content, originalEvent, item) {\n    this.range.replaceTriggerText(content, true, true, originalEvent, item);\n  }\n\n  _append(collection, newValues, replace) {\n    if (typeof collection.values === \"function\") {\n      throw new Error(\"Unable to append to values, as it is a function.\");\n    } else if (!replace) {\n      collection.values = collection.values.concat(newValues);\n    } else {\n      collection.values = newValues;\n    }\n  }\n\n  append(collectionIndex, newValues, replace) {\n    const index = parseInt(collectionIndex);\n    if (typeof index !== \"number\")\n      throw new Error(\"please provide an index for the collection to update.\");\n\n    const collection = this.collection[index];\n\n    this._append(collection, newValues, replace);\n  }\n\n  appendCurrent(newValues, replace) {\n    if (this.isActive) {\n      this._append(this.current.collection, newValues, replace);\n    } else {\n      throw new Error(\n        \"No active state. Please use append instead and pass an index.\"\n      );\n    }\n  }\n\n  detach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._detach(el[i]);\n      }\n    } else {\n      this._detach(el);\n    }\n  }\n\n  _detach(el) {\n    this.events.unbind(el);\n    if (el.tributeMenu) {\n      this.menuEvents.unbind(el.tributeMenu);\n    }\n\n    setTimeout(() => {\n      el.removeAttribute(\"data-tribute\");\n      this.isActive = false;\n      if (el.tributeMenu) {\n        el.tributeMenu.remove();\n      }\n    });\n  }\n}\n\nexport default Tribute;\n"],"names":["CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","Array","prototype","find","Object","defineProperty","value","predicate","this","TypeError","o","len","length","thisArg","arguments","k","kValue","call","configurable","writable","window","Event","TributeEvents","constructor","tribute","events","key","bind","element","boundKeyDown","keydown","boundKeyUp","keyup","boundInput","input","addEventListener","unbind","removeEventListener","instance","shouldDeactivate","hideMenu","KeyboardEvent","controlKeyPressed","modifiers","forEach","getModifierState","isActive","keys","keyCode","callbacks","toLowerCase","str","text","charCodeAt","setTimeout","click","menu","contains","target","li","preventDefault","stopPropagation","nodeName","parentNode","Error","selectItemAtIndex","getAttribute","current","externalTrigger","updateSelection","getKeyCode","allowSpaces","hasTrailingSpace","isNaN","autocompleteMode","String","fromCharCode","match","trigger","triggers","InputEvent","collection","item","menuShowMinLength","mentionText","showMenuFor","el","info","range","getTriggerInfo","which","code","mentionTriggerChar","NaN","success","selectedPath","mentionSelectedPath","fullText","selectedOffset","mentionSelectedOffset","enter","e","_el","filteredItems","menuSelected","escape","tab","space","spaceSelectsMatch","up","count","selected","setActiveLi","scrollTop","scrollHeight","down","delete","index","lis","querySelectorAll","parseInt","i","classList","add","selectClass","liClientRect","getBoundingClientRect","menuClientRect","bottom","scrollDistance","top","remove","getFullHeight","elem","includeMargin","height","style","currentStyle","getComputedStyle","parseFloat","marginTop","marginBottom","TributeMenuEvents","menuEvents","_menu","menuClickEvent","menuContainerScrollEvent","debounce","windowResizeEvent","windowBlurEvent","getDocument","menuContainer","func","wait","immediate","timeout","context","args","callNow","clearTimeout","apply","TributeRange","iframe","contentWindow","positionMenuAtCaret","scrollTo","coordinates","positionMenu","display","isContentEditable","getContentEditableCaretPosition","mentionPosition","getTextAreaOrInputUnderlinePosition","left","right","maxHeight","maxWidth","position","scrollIntoView","body","selectElement","targetElement","path","offset","childNodes","nextSibling","previousSibling","sel","getWindowSelection","createRange","setStart","setEnd","collapse","removeAllRanges","error","console","addRange","focus","replaceTriggerText","requireLeadingSpace","originalEvent","replaceEvent","textEndsWithSpace","trimEnd","replaceTextSuffix","endPos","useHTML","pasteHtml","pasteText","myField","textSuffix","stripHtml","startPos","substring","selectionStart","selectionEnd","dispatchEvent","html","anchorNode","Math","min","deleteContents","createElement","innerHTML","frag","createDocumentFragment","node","lastNode","firstChild","appendChild","insertNode","newRange","collapseToEnd","tmp","textContent","innerText","nodeValue","getSelection","rootNode","getRootNode","getNodePositionInParent","getContentEditableSelectedPath","_ctx","ce","contentEditable","push","reverse","getRangeAt","startOffset","getWholeWordsUpToCharIndex","minLen","pos","arr","split","autocompleteSeparator","filter","trim","idx","indexOf","slice","getTextPrecedingCurrentSelection","selectedElem","workingNodeContent","selectStartOffset","textComponent","getLastWordInText","separator","wordsArray","menuAlreadyActive","isAutocomplete","ctx","selectionInfo","effectiveRange","lastWordOfEffectiveRange","mentionSelectedElement","triggerChar","mostRecentTriggerCharPos","config","c","lastIndexWithLeadingSpace","lastIndexOf","test","currentTriggerSnippet","firstSnippetChar","leadingSpace","regex","reversedStr","join","cidx","firstChar","triggerIdx","isMenuOffScreen","menuDimensions","windowWidth","innerWidth","windowHeight","innerHeight","doc","documentElement","windowLeft","pageXOffset","scrollLeft","clientLeft","windowTop","pageYOffset","clientTop","menuTop","menuRight","width","menuBottom","menuLeft","floor","ceil","getMenuDimensions","dimensions","visibility","offsetWidth","offsetHeight","_flipped","div","id","computed","whiteSpace","wordWrap","prop","span0","replace","span","span2","rect","spanRect","divRect","removeChild","clamp","number","max","finalRect","getFixedCoordinatesRelativeToRect","selectedNodePosition","textNode","nodeType","Node","TEXT_NODE","availableSpaceOnTop","availableSpaceOnBottom","availableSpaceOnLeft","availableSpaceOnRight","_elem","clientRect","elemTop","elemBottom","maxY","targetY","TributeSearch","search","simpleFilter","pattern","array","string","opts","pre","post","compareString","caseSensitive","skip","rendered","score","patternCache","traverse","render","cache","stringIndex","patternIndex","splice","calculateScore","best","temp","pop","indices","reduce","prev","_arr","extract","original","sort","a","b","compare","Tribute","values","loadingItemTemplate","containerClass","itemClass","selectTemplate","menuItemTemplate","lookup","fillAttr","noMatchTemplate","searchOpts","menuItemLimit","activationPending","defaultSelectTemplate","defaultMenuItemTemplate","t","warn","map","_isActive","val","noMatchEvent","matchItem","attach","jQuery","get","NodeList","HTMLCollection","_attach","hasAttribute","ensureEditable","setAttribute","inputTypes","createMenu","wrapper","ul","className","fontSize","round","currentMentionTextSnapshot","tributeMenu","processValues","forceReplace","activeElement","repeat","replaceText","items","querySelector","showMenu","fragment","_findLiTarget","movementY","showMenuForCollection","collectionIndex","placeCaretAtEnd","insertTextAtCursor","insertAtCaret","selectNodeContents","createTextRange","textRange","moveToElementText","select","createTextNode","textarea","scrollPos","caretPos","front","back","content","_append","newValues","concat","append","appendCurrent","detach","_detach","removeAttribute"],"mappings":"wOA8CA,SAASA,EAAYC,EAAOC,GAC1BA,EAASA,GAAU,CACjBC,SAAS,EACTC,YAAY,EACZC,YAAQC,SAEJC,EAAMC,SAASC,YAAY,sBACjCF,EAAIG,gBAAgBT,EAAOC,EAAOC,QAASD,EAAOE,WAAYF,EAAOG,QAC9DE,EAtDJI,MAAMC,UAAUC,MACnBC,OAAOC,eAAeJ,MAAMC,UAAW,OAAQ,CAC7CI,MAAO,SAAUC,MAEF,OAATC,WACIC,UAAU,uCAGZC,EAAIN,OAAOI,MAGXG,EAAMD,EAAEE,SAAW,KAGA,mBAAdL,QACHE,UAAU,sCAIZI,EAAUC,UAAU,OAGtBC,EAAI,OAGDA,EAAIJ,GAAK,OAKRK,EAASN,EAAEK,MACbR,EAAUU,KAAKJ,EAASG,EAAQD,EAAGL,UAC9BM,EAGTD,MAMJG,cAAc,EACdC,UAAU,IAeQ,oBAAXC,QAAwD,mBAAvBA,OAAO9B,mBACrB,IAAjB8B,OAAOC,QAChB/B,EAAYY,UAAYkB,OAAOC,MAAMnB,WAGvCkB,OAAO9B,YAAcA,GC7DvB,MAAMgC,EACJC,YAAYC,QACLA,QAAUA,OACVA,QAAQC,OAASjB,yBAIf,CACL,CACEkB,IAAK,EACLpB,MAAO,OAET,CACEoB,IAAK,GACLpB,MAAO,SAET,CACEoB,IAAK,GACLpB,MAAO,UAET,CACEoB,IAAK,GACLpB,MAAO,MAET,CACEoB,IAAK,GACLpB,MAAO,kCAMJ,CACL,WACA,UACA,KACA,QACA,OACA,KACA,QACA,SACA,OAIJqB,KAAKC,GACHA,EAAQC,aAAerB,KAAKsB,QAAQH,KAAKC,EAASpB,MAClDoB,EAAQG,WAAavB,KAAKwB,MAAML,KAAKC,EAASpB,MAC9CoB,EAAQK,WAAazB,KAAK0B,MAAMP,KAAKC,EAASpB,MAE9CoB,EAAQO,iBAAiB,UAAWP,EAAQC,cAAc,GAC1DD,EAAQO,iBAAiB,QAASP,EAAQG,YAAY,GACtDH,EAAQO,iBAAiB,QAASP,EAAQK,YAAY,GAGxDG,OAAOR,GACLA,EAAQS,oBAAoB,UAAWT,EAAQC,cAAc,GAC7DD,EAAQS,oBAAoB,QAAST,EAAQG,YAAY,GACzDH,EAAQS,oBAAoB,QAAST,EAAQK,YAAY,UAElDL,EAAQC,oBACRD,EAAQG,kBACRH,EAAQK,WAGjBH,QAAQQ,EAAU/C,MACZ+C,EAASC,iBAAiBhD,IAC5B+C,EAASd,QAAQgB,WAEfjD,aAAiBkD,cAAe,KAC9BC,GAAoB,KACxBpB,EAAcqB,YAAYC,SAASlC,IAC7BnB,EAAMsD,iBAAiBnC,KACzBgC,GAAoB,MAIpBA,EAAmB,OAGrBJ,EAASd,QAAQsB,UACnBxB,EAAcyB,OAAOH,SAASlC,IACxBA,EAAEgB,MAAQnC,EAAMyD,SAClBV,EAASW,YAAYvC,EAAEJ,MAAM4C,eAAe3D,EAAOiB,SAM3D0B,MAAMI,EAAU/C,MACVA,aAAiBD,YAAa,OAC1B6D,EAAM5D,EAAMI,OAAOyD,KACzB7D,EAAMyD,QAAUG,EAAIE,WAAWF,EAAIvC,OAAS,GAC5C0C,WAAWhB,EAASN,MAAML,KAAKnB,KAAM8B,EAAU/C,GAAQ,QAClD+C,EAASN,MAAMf,KAAKT,KAAM8B,EAAU/C,GAG7CgE,MAAMjB,EAAU/C,SACRiC,EAAUc,EAASd,WACrBA,EAAQgC,MAAQhC,EAAQgC,KAAKC,SAASlE,EAAMmE,QAAS,KACnDC,EAAKpE,EAAMmE,WACfnE,EAAMqE,iBACNrE,EAAMsE,kBAC+B,OAA9BF,EAAGG,SAASZ,kBACjBS,EAAKA,EAAGI,YACHJ,GAAMA,IAAOnC,EAAQgC,WAClB,IAAIQ,MAAM,gDAIpBxC,EAAQyC,kBAAkBN,EAAGO,aAAa,cAAe3E,QAEhDiC,EAAQ2C,QAAQvC,UAAYJ,EAAQ2C,QAAQC,kBACrD5C,EAAQ2C,QAAQC,iBAAkB,EAClC5C,EAAQgB,YAIZR,MAAMM,EAAU/C,OACT+C,EAAS+B,gBAAgB7D,MAAO,aAC/BwC,EAAUV,EAASgC,WAAWhC,EAAU9B,KAAMjB,MAEhDA,aAAiBkD,cAAe,KAC9BC,GAAoB,KACxBpB,EAAcqB,YAAYC,SAASlC,IAC7BnB,EAAMsD,iBAAiBnC,KACzBgC,GAAoB,MAKxBpB,EAAcyB,OAAOH,SAASlC,IACxBA,EAAEgB,MAAQsB,IACZN,GAAoB,MAIpBA,EAAmB,WAGpBJ,EAASd,QAAQ+C,aAAejC,EAASd,QAAQgD,wBACpDlC,EAASd,QAAQgD,kBAAmB,OACpClC,EAASW,YAAT,MAA8B1D,EAAOiB,MAKnCwC,IAAYyB,MAAMzB,GAElBV,EAASd,QAAQkD,kBACjBC,OAAOC,aAAa5B,GAAS6B,MAAM,YAEnCvC,EAASd,QAAQ2C,QAAQW,QAAU,GAEnCxC,EAASd,QAAQ2C,QAAQW,QAAUxC,EAASd,QACzCuD,WACA5E,MAAM2E,GACEA,EAAQzB,WAAW,KAAOL,IAIvCV,EAASd,QAAQkD,kBACjBnF,aAAiByF,aAEjB1C,EAASd,QAAQ2C,QAAQW,QAAU,KAIjCxC,EAASd,QAAQ2C,QAAQW,SACa,KAArCxC,EAASd,QAAQ2C,QAAQW,SACxBxC,EAASd,QAAQkD,oBAMvBpC,EAASd,QAAQ2C,QAAQc,WAAa3C,EAASd,QAAQyD,WAAW9E,MAC/D+E,GACQA,EAAKJ,UAAYxC,EAASd,QAAQ2C,QAAQW,WAIlDxC,EAASd,QAAQ2C,QAAQc,YAC1B3C,EAASd,QAAQ2C,QAAQc,WAAWE,kBAClC7C,EAASd,QAAQ2C,QAAQiB,YAAYxE,QAKzC0B,EAASd,QAAQ6D,YAAY7E,MAAM,IAGrC+B,iBAAiBhD,OACXmD,GAAoB,SACxBpB,EAAcyB,OAAOH,SAASlC,IACxBnB,EAAMyD,UAAYtC,EAAEgB,MACtBgB,GAAoB,OAKpBA,KACAlC,KAAKgB,QAAQsB,SAKnBwB,WAAWhC,EAAUgD,EAAI/F,SACjBiC,EAAUc,EAASd,QACnB+D,EAAO/D,EAAQgE,MAAMC,gBACzB,EACAjE,EAAQgD,kBACR,EACAhD,EAAQ+C,YACR/C,EAAQkD,yBAGNnF,EAAMyD,SAAWzD,EAAMmG,OAASnG,EAAMoG,KACjCpG,EAAMyD,SAAWzD,EAAMmG,OAASnG,EAAMoG,KACpCJ,EACLA,EAAKK,mBAA2BL,EAAKK,mBAAmBvC,WAAW,GAC3DkC,EAAKH,YAAY/B,WAAWkC,EAAKH,YAAYxE,OAAS,GAE3DiF,IAIXxB,gBAAgBiB,OACVQ,GAAU,OACTtE,QAAQ2C,QAAQvC,QAAU0D,QACzBC,EAAO/E,KAAKgB,QAAQgE,MAAMC,gBAC9B,EACAjF,KAAKgB,QAAQgD,kBACb,EACAhE,KAAKgB,QAAQ+C,YACb/D,KAAKgB,QAAQkD,yBAGXa,QACG/D,QAAQ2C,QAAQ4B,aAAeR,EAAKS,yBACpCxE,QAAQ2C,QAAQiB,YAAcG,EAAKH,iBACnC5D,QAAQ2C,QAAQ8B,SAAWV,EAAKU,cAChCzE,QAAQ2C,QAAQ+B,eAAiBX,EAAKY,2BACtC3E,QAAQ2C,QAAQoB,KAAOA,EAC5BO,GAAU,QAELtE,QAAQ2C,QAAU,GAElB2B,EAGT7C,kBACS,CACLmD,MAAO,CAACC,EAAGC,KAEL9F,KAAKgB,QAAQsB,UAAYtC,KAAKgB,QAAQ2C,QAAQoC,gBAChDF,EAAEzC,iBACFyC,EAAExC,uBACGrC,QAAQyC,kBAAkBzD,KAAKgB,QAAQgF,aAAcH,KAG9DI,OAAQ,CAACJ,EAAGC,KACN9F,KAAKgB,QAAQsB,WACfuD,EAAEzC,iBACFyC,EAAExC,uBACGrC,QAAQgB,aAGjBkE,IAAK,CAACL,EAAGf,UAEFrC,YAAYmD,MAAMC,EAAGf,IAE5BqB,MAAO,CAACN,EAAGf,KACL9E,KAAKgB,QAAQsB,WACXtC,KAAKgB,QAAQoF,uBACV3D,YAAYmD,MAAMC,EAAGf,GAChB9E,KAAKgB,QAAQ+C,cACvB8B,EAAExC,kBACFP,YAAW,UACJ9B,QAAQgB,aACZ,MAITqE,GAAI,CAACR,EAAGC,QAEF9F,KAAKgB,QAAQsB,UAAYtC,KAAKgB,QAAQ2C,QAAQoC,cAAe,CAC/DF,EAAEzC,iBACFyC,EAAExC,wBACIiD,EAAQtG,KAAKgB,QAAQ2C,QAAQoC,cAAc3F,OAC/CmG,EAAWvG,KAAKgB,QAAQgF,aAEtBM,EAAQC,GAAYA,EAAW,QAC5BvF,QAAQgF,oBACRQ,eACiB,IAAbD,SACJvF,QAAQgF,aAAeM,EAAQ,OAC/BE,mBACAxF,QAAQgC,KAAKyD,UAAYzG,KAAKgB,QAAQgC,KAAK0D,gBAItDC,KAAM,CAACd,EAAGC,QAEJ9F,KAAKgB,QAAQsB,UAAYtC,KAAKgB,QAAQ2C,QAAQoC,cAAe,CAC/DF,EAAEzC,iBACFyC,EAAExC,wBACIiD,EAAQtG,KAAKgB,QAAQ2C,QAAQoC,cAAc3F,OAAS,EACxDmG,EAAWvG,KAAKgB,QAAQgF,aAEtBM,EAAQC,QACLvF,QAAQgF,oBACRQ,eACIF,IAAUC,SACdvF,QAAQgF,aAAe,OACvBQ,mBACAxF,QAAQgC,KAAKyD,UAAY,KAIpCG,OAAQ,CAACf,EAAGf,KAER9E,KAAKgB,QAAQsB,UACbtC,KAAKgB,QAAQ2C,QAAQiB,YAAYxE,OAAS,OAErCY,QAAQgB,WACJhC,KAAKgB,QAAQsB,eACjBtB,QAAQ6D,YAAYC,KAMjC0B,YAAYK,SACJC,EAAM9G,KAAKgB,QAAQgC,KAAK+D,iBAAiB,MAC7C3G,EAAS0G,EAAI1G,SAAW,EAEtByG,IAAO7G,KAAKgB,QAAQgF,aAAegB,SAASH,QAE3C,IAAII,EAAI,EAAGA,EAAI7G,EAAQ6G,IAAK,OACzB9D,EAAK2D,EAAIG,MACXA,IAAMjH,KAAKgB,QAAQgF,aAAc,CACnC7C,EAAG+D,UAAUC,IAAInH,KAAKgB,QAAQ2C,QAAQc,WAAW2C,mBAE3CC,EAAelE,EAAGmE,wBAClBC,EAAiBvH,KAAKgB,QAAQgC,KAAKsE,2BAErCD,EAAaG,OAASD,EAAeC,OAAQ,OACzCC,EAAiBJ,EAAaG,OAASD,EAAeC,YACvDxG,QAAQgC,KAAKyD,WAAagB,OAC1B,GAAIJ,EAAaK,IAAMH,EAAeG,IAAK,OAC1CD,EAAiBF,EAAeG,IAAML,EAAaK,SACpD1G,QAAQgC,KAAKyD,WAAagB,QAGjCtE,EAAG+D,UAAUS,OAAO3H,KAAKgB,QAAQ2C,QAAQc,WAAW2C,cAK1DQ,cAAcC,EAAMC,SACZC,EAASF,EAAKP,wBAAwBS,UAExCD,EAAe,OACXE,EAAQH,EAAKI,cAAgBrH,OAAOsH,iBAAiBL,UAEzDE,EAASI,WAAWH,EAAMI,WAAaD,WAAWH,EAAMK,qBAIrDN,GCjXX,MAAMO,EACJvH,YAAYC,QACLA,QAAUA,OACVA,QAAQuH,WAAavI,UACrBgD,KAAOhD,KAAKgB,QAAQgC,KAG3B7B,KAAKqH,QACEC,eAAiBzI,KAAKgB,QAAQC,OAAO8B,MAAM5B,KAAK,KAAMnB,WACtD0I,yBAA2B1I,KAAK2I,UACnC,UACO3H,QAAQgB,aAEf,IACA,QAEG4G,kBAAoB5I,KAAK2I,UAC5B,UACO3H,QAAQgB,aAEf,IACA,QAGG6G,gBAAkB,UAChB7H,QAAQgB,iBAIVhB,QAAQgE,MACV8D,cACAnH,iBAAiB,gBAAiB3B,KAAKyI,gBAAgB,QACrDzH,QAAQgE,MACV8D,cACAnH,iBAAiB,YAAa3B,KAAKyI,gBAAgB,GACtD7H,OAAOe,iBAAiB,SAAU3B,KAAK4I,mBACvChI,OAAOe,iBAAiB,OAAQ3B,KAAK6I,iBAEjC7I,KAAK+I,mBACFA,cAAcpH,iBACjB,SACA3B,KAAK0I,0BACL,GAGF9H,OAAOe,iBAAiB,SAAU3B,KAAK0I,0BAI3C9G,OAAO4G,QACAxH,QAAQgE,MACV8D,cACAjH,oBAAoB,YAAa7B,KAAKyI,gBAAgB,QACpDzH,QAAQgE,MACV8D,cACAjH,oBAAoB,gBAAiB7B,KAAKyI,gBAAgB,GAC7D7H,OAAOiB,oBAAoB,SAAU7B,KAAK4I,mBAEtC5I,KAAK+I,mBACFA,cAAclH,oBACjB,SACA7B,KAAK0I,0BACL,GAGF9H,OAAOiB,oBAAoB,SAAU7B,KAAK0I,0BAI9CC,SAASK,EAAMC,EAAMC,OACfC,QACG,WACCC,EAAUpJ,KACdqJ,EAAO/I,UAKHgJ,EAAUJ,IAAcC,EAC9BI,aAAaJ,GACbA,EAAUrG,YANI,KACZqG,EAAU,KACLD,GAAWF,EAAKQ,MAAMJ,EAASC,KAIVJ,GACxBK,GAASN,EAAKQ,MAAMJ,EAASC,KC9EvC,MAAMI,EACJ1I,YAAYC,QACLA,QAAUA,OACVA,QAAQgE,MAAQhF,KAGvB8I,kBACMY,SACA1J,KAAKgB,QAAQ2C,QAAQc,aACvBiF,EAAS1J,KAAKgB,QAAQ2C,QAAQc,WAAWiF,QAGtCA,EAIEA,EAAOC,cAAcrK,SAHnBA,SAMXsK,oBAAoBC,SACZT,EAAUpJ,KAAKgB,QAAQ2C,YACzBmG,QAEE/E,EAAO/E,KAAKiF,gBAChB,EACAjF,KAAKgB,QAAQgD,kBACb,EACAhE,KAAKgB,QAAQ+C,YACb/D,KAAKgB,QAAQkD,0BAGK,IAATa,EAAsB,KAC1B/E,KAAKgB,QAAQ+I,8BACX/I,QAAQgC,KAAKgF,MAAMgC,QAAW,SAUnCF,EANG9J,KAAKiK,kBAAkBb,EAAQhI,SAMpBpB,KAAKkK,gCACjBnF,EAAKoF,gBAAkBpF,EAAKH,YAAYxE,QAN5BJ,KAAKoK,oCACjBpK,KAAKgB,QAAQ2C,QAAQvC,QACrB2D,EAAKoF,gBAAkBpF,EAAKH,YAAYxE,aAQvCY,QAAQgC,KAAKgF,MAAMN,IAAO,GAAEoC,EAAYpC,aACxC1G,QAAQgC,KAAKgF,MAAMqC,KAAQ,GAAEP,EAAYO,cACzCrJ,QAAQgC,KAAKgF,MAAMsC,MAAS,GAAER,EAAYQ,eAC1CtJ,QAAQgC,KAAKgF,MAAMR,OAAU,GAAEsC,EAAYtC,gBAC3CxG,QAAQgC,KAAKgF,MAAM,aAAgB,GACtC8B,EAAYS,WAAa,aAEtBvJ,QAAQgC,KAAKgF,MAAM,aAAgB,GAAE8B,EAAYU,UAAY,aAC7DxJ,QAAQgC,KAAKgF,MAAMyC,SAAY,GAClCX,EAAYW,UAAY,kBAErBzJ,QAAQgC,KAAKgF,MAAMgC,QAAW,QAEV,SAArBF,EAAYO,YACTrJ,QAAQgC,KAAKgF,MAAMqC,KAAO,QAGT,SAApBP,EAAYpC,WACT1G,QAAQgC,KAAKgF,MAAMN,IAAM,QAG5BmC,GAAU7J,KAAK0K,2BAEd1J,QAAQgC,KAAKgF,MAAMgC,QAAU,wCAMlChK,KAAKgB,QAAQ+H,gBAAkBzJ,SAASqL,OACvC3K,KAAKgB,QAAQ+H,cAIlB6B,cAAcC,EAAeC,EAAMC,OAC7BlD,EAAOgD,KAEPC,MACG,IAAI7D,EAAI,EAAGA,EAAI6D,EAAK1K,OAAQ6G,IAAK,IACpCY,EAAOA,EAAKmD,WAAWF,EAAK7D,SACf7H,IAATyI,cAGGA,EAAKzH,OAAS2K,GACnBA,GAAUlD,EAAKzH,OACfyH,EAAOA,EAAKoD,YAEiB,IAA3BpD,EAAKmD,WAAW5K,QAAiByH,EAAKzH,SACxCyH,EAAOA,EAAKqD,uBAIZC,EAAMnL,KAAKoL,qBACXpG,EAAQhF,KAAK8I,cAAcuC,cACjCrG,EAAMsG,SAASzD,EAAMkD,GACrB/F,EAAMuG,OAAO1D,EAAMkD,GACnB/F,EAAMwG,UAAS,OAGbL,EAAIM,kBACJ,MAAOC,GACPC,QAAQD,MAAMA,GAGhBP,EAAIS,SAAS5G,GACb6F,EAAcgB,QAGhBC,mBACElJ,EACAmJ,EACA/H,EACAgI,EACAtH,SAEMK,EAAO/E,KAAKgB,QAAQ2C,QAAQoB,aAErB3F,IAAT2F,EAAoB,OAChBqE,EAAUpJ,KAAKgB,QAAQ2C,QACvBxE,EAAS,CACbuF,KAAMA,EACN5C,SAAUsH,EACVA,QAASrE,EACThG,MAAOiN,EACPpJ,KAAMA,GAEFqJ,EAAe,IAAInN,YAAY,mBAAoB,CACvDK,OAAQA,OAGLa,KAAKiK,kBAAkBb,EAAQhI,SAwB7B,OAEC8K,EAAoBtJ,IAASA,EAAKuJ,UAKxCvJ,GAH4C,iBAAnC5C,KAAKgB,QAAQoL,kBAChBpM,KAAKgB,QAAQoL,kBACb,QAEFC,EACFtH,EAAKoF,gBAAkBpF,EAAKH,YAAYxE,OAAS8L,EAC9ClM,KAAKgB,QAAQkD,mBAChBmI,GAAUtH,EAAKK,mBAAmBhF,aAE/BY,QAAQsL,QACTtM,KAAKuM,UAAU3J,EAAMmC,EAAKoF,gBAAiBkC,GAC3CrM,KAAKwM,UAAU5J,EAAMmC,EAAKoF,gBAAiBkC,OAvCH,OACtCH,EAAoBtJ,IAASA,EAAKuJ,UAClCM,EAAUzM,KAAKgB,QAAQ2C,QAAQvC,QAC/BsL,EACsC,iBAAnC1M,KAAKgB,QAAQoL,kBAChBpM,KAAKgB,QAAQoL,kBACb,IACNxJ,EAAO5C,KAAK2M,UAAU/J,GACtBA,GAAQ8J,QACFE,EAAW7H,EAAKoF,oBAClBkC,EACFtH,EAAKoF,gBACLpF,EAAKH,YAAYxE,OACjBsM,EAAWtM,OACX8L,EACGlM,KAAKgB,QAAQkD,mBAChBmI,GAAUtH,EAAKK,mBAAmBhF,OAAS,GAE7CqM,EAAQ3M,MACN2M,EAAQ3M,MAAM+M,UAAU,EAAGD,GAC3BhK,EACA6J,EAAQ3M,MAAM+M,UAAUR,EAAQI,EAAQ3M,MAAMM,QAChDqM,EAAQK,eAAiBF,EAAWhK,EAAKxC,OACzCqM,EAAQM,aAAeH,EAAWhK,EAAKxC,OAmBzCgJ,EAAQhI,QAAQ4L,cACd,IAAIlO,YAAY,QAAS,CAAEG,SAAS,EAAME,OAAQA,KAEpDiK,EAAQhI,QAAQ4L,cAAcf,IAIlCM,UAAUU,EAAML,EAAUP,SAClBlB,EAAMnL,KAAKoL,qBACXpG,EAAQhF,KAAK8I,cAAcuC,cACjCrG,EAAMsG,SAASH,EAAI+B,WAAYN,GAC/B5H,EAAMuG,OAAOJ,EAAI+B,WAAYC,KAAKC,IAAIf,EAAQlB,EAAI+B,WAAW9M,SAC7D4E,EAAMqI,uBAEAvI,EAAK9E,KAAK8I,cAAcwE,cAAc,OAC5CxI,EAAGyI,UAAYN,QACTO,EAAOxN,KAAK8I,cAAc2E,6BAC5BC,EAAMC,OAEFD,EAAO5I,EAAG8I,YAChBD,EAAWH,EAAKK,YAAYH,MAE9B1I,EAAM8I,WAAWN,GAGbG,EAAU,OACNI,EAAW/N,KAAK8I,cAAcuC,cACpC0C,EAASzC,SAASqC,EAAUA,EAASvN,QACrC2N,EAASvC,UAAS,GAClBL,EAAIM,kBACJN,EAAIS,SAASmC,GACb5C,EAAI6C,iBAIRrB,UAAUM,SACFgB,EAAM3O,SAASgO,cAAc,cACnCW,EAAIV,UAAYN,EACTgB,EAAIC,aAAeD,EAAIE,WAAa,GAG7C3B,UAAUS,EAAML,EAAUP,SAClBzJ,EAAO5C,KAAK2M,UAAUM,GACtBjI,EAAQhF,KAAK8I,cAAcuC,cAC3BF,EAAMnL,KAAKoL,qBACjBD,EAAI+B,WAAWkB,UACbjD,EAAI+B,WAAWkB,UAAUvB,UAAU,EAAGD,GACtChK,EACAuI,EAAI+B,WAAWkB,UAAUvB,UACvBR,EACAlB,EAAI+B,WAAWkB,UAAUhO,QAE7B4E,EAAMsG,SAASH,EAAI+B,WAAYN,EAAWhK,EAAKxC,QAC/C4E,EAAMwG,UAAS,GACfL,EAAIM,kBACJN,EAAIS,SAAS5G,GACbmG,EAAI6C,gBAGN5C,wBACMpL,KAAKgB,QAAQyD,WAAWiF,cACnB1J,KAAKgB,QAAQyD,WAAWiF,OAAOC,cAAc0E,qBAGhDC,EAAWtO,KAAKgB,QAAQ2C,QAAQvC,QAAQmN,qBAC1CD,EAASD,aAAqBC,EAASD,eAC/BzN,OAAOyN,eAGrBG,wBAAwBpN,MACK,OAAvBA,EAAQmC,kBACH,MAGJ,IAAI0D,EAAI,EAAGA,EAAI7F,EAAQmC,WAAWyH,WAAW5K,OAAQ6G,IAAK,IAChD7F,EAAQmC,WAAWyH,WAAW/D,KAE9B7F,SACJ6F,GAKbwH,+BAA+BC,SACvBvD,EAAMnL,KAAKoL,yBACb7E,EAAW4E,EAAI+B,iBACbpC,EAAO,OACTC,KAEa,OAAbxE,EAAmB,KACjBU,EACA0H,EAAKpI,EAASqI,qBACE,OAAbrI,GAA4B,SAAPoI,GAC1B1H,EAAIjH,KAAKwO,wBAAwBjI,GACjCuE,EAAK+D,KAAK5H,GACVV,EAAWA,EAAShD,WACH,OAAbgD,IACFoI,EAAKpI,EAASqI,wBAGlB9D,EAAKgE,UAGL/D,EAASI,EAAI4D,WAAW,GAAGC,YAEpB,CACLzI,SAAUA,EACVuE,KAAMA,EACNC,OAAQA,IAKdkE,2BAA2BtM,EAAKuM,OAC1BC,EAAM,QACJC,EAAMzM,EACT0M,MAAMrP,KAAKgB,QAAQsO,uBACnBC,QAAO,SAAU1J,UACTA,EAAE2J,UAEP5M,EAAOD,MACR,IAAIsE,EAAI,EAAG9G,EAAMiP,EAAIhP,OAAQ6G,EAAI9G,EAAK8G,IAAK,OACxCwI,EAAM9M,EAAI+M,QAAQN,EAAInI,OAC5BkI,GAAYM,EACZ9M,EAAMA,EAAIgN,MAAMF,GACZP,GAAUC,GAAOD,GAAUC,EAAMC,EAAInI,GAAG7G,OAAQ,CAClD8O,EAASC,EAAMC,EAAInI,GAAG7G,qBAKnBwC,EAAKiK,UAAU,EAAGqC,GAE3BU,yCACQxG,EAAUpJ,KAAKgB,QAAQ2C,YACzBf,EAAO,MAEN5C,KAAKiK,kBAAkBb,EAAQhI,SAS7B,OACCyO,EAAe7P,KAAKoL,qBAAqB8B,cAE1B,OAAjB2C,EAAuB,OACnBC,EAAqBD,EAAa3B,YAClC6B,EACJ/P,KAAKoL,qBAAqB2D,WAAW,GAAGC,YAEtCc,GAAsBC,GAAqB,IAC7CnN,EAAOkN,EAAmBjD,UAAU,GACpCjK,EAAO5C,KAAKiP,2BAA2BrM,EAAMmN,SAnBL,OACtCC,EAAgBhQ,KAAKgB,QAAQ2C,QAAQvC,WACvC4O,EAAe,OACXpD,EAAWoD,EAAclD,eAC3BkD,EAAclQ,OAAS8M,GAAY,IACrChK,EAAOoN,EAAclQ,MAAM+M,UAAU,GACrCjK,EAAO5C,KAAKiP,2BAA2BrM,EAAMgK,YAkB5ChK,EAGTqN,kBAAkBrN,SACVsN,EAAYlQ,KAAKgB,QAAQsO,sBAC3BtP,KAAKgB,QAAQsO,sBACb,MACEa,EAAavN,EAAKyM,MAAMa,UAEzBC,EAAW/P,OACT+P,EAAWA,EAAW/P,OAAS,GADP,IAIjC6E,eACEmL,EACApM,EACA+H,EACAhI,EACAsM,SAEMC,EAAMtQ,KAAKgB,QAAQ2C,YACrB4C,EAAUuE,EAAMC,KAEf/K,KAAKiK,kBAAkBqG,EAAIlP,SAEzB,OACCmP,EAAgBvQ,KAAKyO,+BAA+B6B,GAEtDC,IACFhK,EAAWgK,EAAchK,SACzBuE,EAAOyF,EAAczF,KACrBC,EAASwF,EAAcxF,aAPzBxE,EAAWvG,KAAKgB,QAAQ2C,QAAQvC,cAW5BoP,EAAiBxQ,KAAK4P,mCACtBa,EAA2BzQ,KAAKiQ,kBAAkBO,MAEpDH,QACK,CACLlG,gBACEqG,EAAepQ,OAASqQ,EAAyBrQ,OACnDwE,YAAa6L,EACbhL,SAAU+K,EACVE,uBAAwBnK,EACxBf,oBAAqBsF,EACrBnF,sBAAuBoF,MAIvByF,MAAAA,EAAyD,KAEvDG,EADAC,GAA4B,UAG3B5P,QAAQyD,WAAWrC,SAASyO,UACzBC,EAAID,EAAOvM,QACXmL,EAAMoB,EAAO9E,oBACf/L,KAAK+Q,0BAA0BP,EAAgBM,GAC/CN,EAAeQ,YAAYF,GAE3BrB,EAAMmB,IACRA,EAA2BnB,EAC3BkB,EAAcG,EACd/E,EAAsB8E,EAAO9E,wBAK/B6E,GAA4B,IACE,IAA7BA,IACE7E,GACD,KAAKkF,KACHT,EAAe3D,UACb+D,EAA2B,EAC3BA,KAGN,KACIM,EAAwBV,EAAe3D,UACzC+D,EAA2BD,EAAYvQ,OACvCoQ,EAAepQ,QAGjBuQ,EAAcH,EAAe3D,UAC3B+D,EACAA,EAA2BD,EAAYvQ,cAEnC+Q,EAAmBD,EAAsBrE,UAAU,EAAG,GACtDuE,EACJF,EAAsB9Q,OAAS,IACT,MAArB+Q,GAAiD,MAArBA,GAC3BnN,IACFkN,EAAwBA,EAAsB1B,cAG1C6B,EAAQtN,EAAc,UAAY,oBAEnC/C,QAAQgD,iBAAmBqN,EAAMJ,KAAKC,IAGxCE,IACAhB,IAAsBiB,EAAMJ,KAAKC,UAE3B,CACL/G,gBAAiByG,EACjBhM,YAAasM,EACbR,uBAAwBnK,EACxBf,oBAAqBsF,EACrBnF,sBAAuBoF,EACvB3F,mBAAoBuL,KAO9BI,0BAA0BpO,EAAK2B,SACvBgN,EAAc3O,EAAI0M,MAAM,IAAIP,UAAUyC,KAAK,QAC7C1K,GAAS,MAER,IAAI2K,EAAO,EAAGrR,EAAMwC,EAAIvC,OAAQoR,EAAOrR,EAAKqR,IAAQ,OACjDC,EAAYD,IAAS7O,EAAIvC,OAAS,EAClCgR,EAAe,KAAKH,KAAKK,EAAYE,EAAO,QAE9CnN,GAAQ,MACP,IAAIqN,EAAapN,EAAQlE,OAAS,EAAGsR,GAAc,EAAGA,OACrDpN,EAAQoN,KAAgBJ,EAAYE,EAAOE,GAAa,CAC1DrN,GAAQ,WAKRA,IAAUoN,GAAaL,GAAe,CACxCvK,EAAQlE,EAAIvC,OAAS,EAAIoR,gBAKtB3K,EAGToD,kBAAkB7I,SACY,UAArBA,EAAQkC,UAA6C,aAArBlC,EAAQkC,SAGjDqO,gBAAgB7H,EAAa8H,SACrBC,EAAcjR,OAAOkR,WACrBC,EAAenR,OAAOoR,YACtBC,EAAM3S,SAAS4S,gBACfC,GACHvR,OAAOwR,aAAeH,EAAII,aAAeJ,EAAIK,YAAc,GACxDC,GACH3R,OAAO4R,aAAeP,EAAIxL,YAAcwL,EAAIQ,WAAa,GAEtDC,EACuB,iBAApB5I,EAAYpC,IACfoC,EAAYpC,IACZoC,EAAYtC,OAASoK,EAAe7J,OACpC4K,EACyB,iBAAtB7I,EAAYQ,MACfR,EAAYQ,MACZR,EAAYO,KAAOuH,EAAegB,MAClCC,EAC0B,iBAAvB/I,EAAYtC,OACfsC,EAAYtC,OACZsC,EAAYpC,IAAMkK,EAAe7J,OACjC+K,EACwB,iBAArBhJ,EAAYO,KACfP,EAAYO,KACZP,EAAYQ,MAAQsH,EAAegB,YAElC,CACLlL,IAAKgL,EAAUvF,KAAK4F,MAAMR,GAC1BjI,MAAOqI,EAAYxF,KAAK6F,KAAKb,EAAaN,GAC1CrK,OAAQqL,EAAa1F,KAAK6F,KAAKT,EAAYR,GAC3C1H,KAAMyI,EAAW3F,KAAK4F,MAAMZ,IAIhCc,0BAIQC,EAAa,CACjBN,MAAO,KACP7K,OAAQ,kBAGL/G,QAAQgC,KAAKgF,MAAMN,IAAO,WAC1B1G,QAAQgC,KAAKgF,MAAMqC,KAAQ,WAC3BrJ,QAAQgC,KAAKgF,MAAMsC,MAAQ,UAC3BtJ,QAAQgC,KAAKgF,MAAMR,OAAS,UAC5BxG,QAAQgC,KAAKgF,MAAMyC,SAAY,aAC/BzJ,QAAQgC,KAAKgF,MAAMmL,WAAc,cACjCnS,QAAQgC,KAAKgF,MAAMgC,QAAW,QAEnCkJ,EAAWN,MAAQ5S,KAAKgB,QAAQgC,KAAKoQ,YACrCF,EAAWnL,OAAS/H,KAAKgB,QAAQgC,KAAKqQ,kBAEjCrS,QAAQgC,KAAKgF,MAAMgC,QAAW,YAC9BhJ,QAAQgC,KAAKgF,MAAMmL,WAAc,UAE/BD,EAGT9I,oCAAoChJ,EAASqJ,EAAU6I,SAiC/CC,EAAMvT,KAAK8I,cAAcwE,cAAc,OAC7CiG,EAAIC,GAAK,gDACJ1K,cAAc6B,KAAKkD,YAAY0F,SAE9BvL,EAAQuL,EAAIvL,MACZyL,EAAW7S,OAAOsH,iBACpBA,iBAAiB9G,GACjBA,EAAQ6G,aAEZD,EAAM0L,WAAa,WACM,UAArBtS,EAAQkC,WACV0E,EAAM2L,SAAW,cAInB3L,EAAMyC,SAAW,WACjBzC,EAAMmL,WAAa,SAhDA,CACjB,YACA,YACA,QACA,SACA,YACA,YACA,iBACA,mBACA,oBACA,kBACA,cACA,aACA,eACA,gBACA,cACA,YACA,cACA,aACA,cACA,WACA,iBACA,aACA,aACA,YACA,gBACA,aACA,iBACA,gBACA,eAsBS/Q,SAASwR,IAClB5L,EAAM4L,GAAQH,EAASG,YAYnBC,EAAQvU,SAASgO,cAAc,QACrCuG,EAAM3F,YAAc9M,EAAQtB,MAAM+M,UAAU,EAAGpC,GAC/C8I,EAAI1F,YAAYgG,GAES,UAArBzS,EAAQkC,WACViQ,EAAIrF,YAAcqF,EAAIrF,YAAY4F,QAAQ,MAAO,YAK7CC,EAAO/T,KAAK8I,cAAcwE,cAAc,QAE9CiG,EAAI1F,YAAYkG,SAEVC,EAAQhU,KAAK8I,cAAcwE,cAAc,QAC/C0G,EAAM9F,YAAc9M,EAAQtB,MAAM+M,UAAUpC,EAAUA,EAAW,GACjE8I,EAAI1F,YAAYmG,SAEVC,EAAO7S,EAAQkG,wBAKrBiM,EAAIvL,MAAMyC,SAAW,QACrB8I,EAAIvL,MAAMqC,KAAO4J,EAAK5J,KAAO,KAC7BkJ,EAAIvL,MAAMN,IAAMuM,EAAKvM,IAAM,KAC3B6L,EAAIvL,MAAM4K,MAAQqB,EAAKrB,MAAQ,KAC/BW,EAAIvL,MAAMD,OAASkM,EAAKlM,OAAS,KACjCwL,EAAI9M,UAAYrF,EAAQqF,gBAElByN,EAAWH,EAAKzM,wBAChB6M,EAAUZ,EAAIjM,6BACfwB,cAAc6B,KAAKyJ,YAAYb,SAC9Bc,EAAQ,SAAUC,EAAQlH,EAAKmH,UAC5BpH,KAAKoH,IAAInH,EAAKD,KAAKC,IAAIkH,EAAQC,KAElCC,EAAY,CAChBzM,OAAQoF,KAAKC,IAAI+G,EAAQpM,OAAQmM,EAASnM,QAC1CsC,KAAMgK,EAAMH,EAAS7J,KAAM8J,EAAQ9J,KAAM8J,EAAQ9J,KAAO8J,EAAQvB,OAChElL,IAAK2M,EAAMH,EAASxM,IAAKyM,EAAQzM,IAAKyM,EAAQzM,IAAMyM,EAAQpM,gBAEvD/H,KAAKyU,kCAAkCD,GAGhDtK,gCAAgCwK,SACxBvJ,EAAMnL,KAAKoL,qBACXpG,EAAQhF,KAAK8I,cAAcuC,cAC3BsJ,EACJxJ,EAAI+B,WAAW0H,WAAaC,KAAKC,UAC7B3J,EAAI+B,WACJ/B,EAAI+B,WAAWlC,WAAW,GAChChG,EAAMsG,SAASqJ,EAAUD,GACzB1P,EAAMuG,OAAOoJ,EAAUD,GAEvB1P,EAAMwG,UAAS,SAETyI,EAAOjP,EAAMsC,+BAEZtH,KAAKyU,kCAAkCR,GAGhDQ,kCAAkCR,SAC1BnK,EAAc,CAClBW,SAAU,QACVJ,KAAM4J,EAAK5J,KACX3C,IAAKuM,EAAKvM,IAAMuM,EAAKlM,QAGjB6J,EAAiB5R,KAAKiT,oBAEtB8B,EAAsBd,EAAKvM,IAC3BsN,EACJpU,OAAOoR,aAAeiC,EAAKvM,IAAMuM,EAAKlM,QAGpCiN,EAAyBpD,EAAe7J,SAExCgN,GAAuBnD,EAAe7J,QACtCgN,EAAsBC,GAEtBlL,EAAYpC,IAAM,OAClBoC,EAAYtC,OAAS5G,OAAOoR,YAAciC,EAAKvM,IAC3CsN,EAAyBpD,EAAe7J,SAC1C+B,EAAYS,UAAYwK,IAGtBA,EAAsBnD,EAAe7J,SACvC+B,EAAYS,UAAYyK,UAKxBC,EAAuBhB,EAAK5J,KAC5B6K,EAAwBtU,OAAOkR,WAAamC,EAAK5J,YAGnD6K,EAAwBtD,EAAegB,QAEvCqC,GAAwBrD,EAAegB,OACvCqC,EAAuBC,GAEvBpL,EAAYO,KAAO,OACnBP,EAAYQ,MAAQ1J,OAAOkR,WAAamC,EAAK5J,KACzC6K,EAAwBtD,EAAegB,QACzC9I,EAAYU,SAAWyK,IAGrBA,EAAuBrD,EAAegB,QACxC9I,EAAYU,SAAW0K,IAKtBpL,EAGTY,eAAeyK,OAGTC,EACAvP,EAAI7F,KAAKgD,aAEI,IAAN6C,EAAmB,iBAERzG,IAAfgW,GAAkD,IAAtBA,EAAWrN,WAC5CqN,EAAavP,EAAEyB,wBAEW,IAAtB8N,EAAWrN,SACblC,EAAIA,EAAEmF,WAAW,QACP5L,IAANyG,IAAoBA,EAAEyB,oCAMxB+N,EAAUD,EAAW1N,IACrB4N,EAAaD,EAAUD,EAAWrN,UAEpCsN,EAAU,EACZzU,OAAOiJ,SACL,EACAjJ,OAAO4R,YAAc4C,EAAW1N,IAxBX,SA0BlB,GAAI4N,EAAa1U,OAAOoR,YAAa,KACtCuD,EAAO3U,OAAO4R,YAAc4C,EAAW1N,IA3BpB,GA6BnB6N,EAAO3U,OAAO4R,YA5BU,MA6B1B+C,EAAO3U,OAAO4R,YA7BY,SAgCxBgD,EAAU5U,OAAO4R,aAAe5R,OAAOoR,YAAcsD,GAErDE,EAAUD,IACZC,EAAUD,GAGZ3U,OAAOiJ,SAAS,EAAG2L,KCjwBzB,MAAMC,EACJ1U,YAAYC,QACLA,QAAUA,OACVA,QAAQ0U,OAAS1V,KAGxB2V,aAAaC,EAASC,UACbA,EAAMtG,QAAQuG,GACZ9V,KAAKiR,KAAK2E,EAASE,KAI9B7E,KAAK2E,EAASE,UAC2B,OAAhC9V,KAAKqE,MAAMuR,EAASE,GAG7BzR,MAAMuR,EAASE,EAAQC,SAEfC,GADND,EAAOA,GAAQ,IACEC,KAAO,GACtBC,EAAOF,EAAKE,MAAQ,GACpBC,EAAiBH,EAAKI,eAAiBL,GAAWA,EAAOpT,iBAEvDqT,EAAKK,WACA,CAAEC,SAAUP,EAAQQ,MAAO,GAGpCV,EAAWG,EAAKI,eAAiBP,GAAYA,EAAQlT,oBAE/C6T,EAAevW,KAAKwW,SAASN,EAAeN,EAAS,EAAG,EAAG,WAC5DW,EAGE,CACLF,SAAUrW,KAAKyW,OAAOX,EAAQS,EAAaG,MAAOV,EAAKC,GACvDK,MAAOC,EAAaD,OAJb,KAQXE,SAASV,EAAQF,EAASe,EAAaC,EAAcL,MAC/CvW,KAAKgB,QAAQsO,wBAEfsG,EAAUA,EAAQvG,MAAMrP,KAAKgB,QAAQsO,uBAAuBuH,QAAQ,GAAG,IAGrEjB,EAAQxV,SAAWwW,QAEd,CACLN,MAAOtW,KAAK8W,eAAeP,GAC3BG,MAAOH,EAAa5G,YAMtBmG,EAAO1V,SAAWuW,GAClBf,EAAQxV,OAASwW,EAAed,EAAO1V,OAASuW,eAK5C7F,EAAI8E,EAAQgB,OAEdG,EACAC,EAFAnQ,EAAQiP,EAAOpG,QAAQoB,EAAG6F,QAIvB9P,GAAS,GAAG,IACjB0P,EAAa1H,KAAKhI,GAClBmQ,EAAOhX,KAAKwW,SACVV,EACAF,EACA/O,EAAQ,EACR+P,EAAe,EACfL,GAEFA,EAAaU,OAGRD,SACID,IAGJA,GAAQA,EAAKT,MAAQU,EAAKV,SAC7BS,EAAOC,GAGTnQ,EAAQiP,EAAOpG,QAAQoB,EAAGjK,EAAQ,UAG7BkQ,EAGTD,eAAeP,OACTD,EAAQ,EACRU,EAAO,SAEXT,EAAanU,SAAQ,CAACyE,EAAOI,KACvBA,EAAI,IACFsP,EAAatP,EAAI,GAAK,IAAMJ,EAC9BmQ,GAAQA,EAAO,EAEfA,EAAO,GAIXV,GAASU,KAGJV,EAGTG,OAAOX,EAAQoB,EAASlB,EAAKC,OACvBI,EAAWP,EAAOjJ,UAAU,EAAGqK,EAAQ,WAE3CA,EAAQ9U,SAAQ,CAACyE,EAAOI,KACtBoP,GACEL,EACAF,EAAOjP,GACPoP,EACAH,EAAOjJ,UACLhG,EAAQ,EACRqQ,EAAQjQ,EAAI,GAAKiQ,EAAQjQ,EAAI,GAAK6O,EAAO1V,WAIxCiW,EAGT9G,OAAOqG,EAASxG,EAAK2G,UACnBA,EAAOA,GAAQ,GACR3G,EACJ+H,QAAO,CAACC,EAAMhW,EAASqO,EAAK4H,SACvB1U,EAAMvB,EAEN2U,EAAKuB,UACP3U,EAAMoT,EAAKuB,QAAQlW,GAEduB,IAEHA,EAAM,WAIJ0T,EAAWrW,KAAKqE,MAAMuR,EAASjT,EAAKoT,UAEzB,OAAbM,IACFe,EAAKA,EAAKhX,QAAU,CAClB0V,OAAQO,EAASA,SACjBC,MAAOD,EAASC,MAChBzP,MAAO4I,EACP8H,SAAUnW,IAIPgW,IACN,IAEFI,MAAK,CAACC,EAAGC,WACFC,EAAUD,EAAEpB,MAAQmB,EAAEnB,aACxBqB,GACGF,EAAE5Q,MAAQ6Q,EAAE7Q,UC5J3B,MAAM+Q,EACJ7W,aAAY8W,OACVA,EAAS,KADCC,oBAEVA,EAAsB,KAFZpO,OAGVA,EAAS,KAHCtC,YAIVA,EAAc,YAJJ2Q,eAKVA,EAAiB,oBALPC,UAMVA,EAAY,GANF1T,QAOVA,EAAU,IAPAJ,iBAQVA,GAAmB,EARToL,sBASVA,EAAwB,KATd2I,eAUVA,EAAiB,KAVPC,iBAWVA,EAAmB,KAXTC,OAYVA,EAAS,MAZCC,SAaVA,EAAW,QAbD3T,WAcVA,EAAa,KAdHsE,cAeVA,EAAgB,KAfNsP,gBAgBVA,EAAkB,KAhBRtM,oBAiBVA,GAAsB,EAjBZhI,YAkBVA,GAAc,EAlBJqI,kBAmBVA,EAAoB,KAnBVrC,aAoBVA,GAAe,EApBL3D,kBAqBVA,GAAoB,EArBVkS,WAsBVA,EAAa,GAtBHC,cAuBVA,EAAgB,KAvBN5T,kBAwBVA,EAAoB,EAxBVpC,KAyBVA,EAAO,KAzBG+J,QA0BVA,GAAU,YAELpI,iBAAmBA,OACnBoL,sBAAwBA,OACxBtJ,aAAe,OACfrC,QAAU,QACVrB,UAAW,OACXkW,mBAAoB,OACpBzP,cAAgBA,OAChBhF,YAAcA,OACdqI,kBAAoBA,OACpBrC,aAAeA,OACf/F,kBAAmB,OACnBoC,kBAAoBA,OACpBkG,QAAUA,EACX/J,IACFzB,EAAcyB,KAAOA,GAGnBvC,KAAKkE,mBACPI,EAAU,GACVP,GAAc,GAGZ8T,OACGpT,WAAa,CAChB,CAEEH,QAASA,EAGToF,OAAQA,EAGRtC,YAAaA,EAGb2Q,eAAgBA,EAGhBC,UAAWA,EAGXC,gBACEA,GAAkBL,EAAQa,uBAC1BtX,KAAKnB,MAGPkY,kBACEA,GAAoBN,EAAQc,yBAC5BvX,KAAKnB,MAGPqY,gBAAiB,CAAEM,GACA,iBAANA,EACQ,KAAbA,EAAEnJ,OAAsB,KACrBmJ,EAEQ,mBAANA,EACFA,EAAExX,KAAKnB,MAIdqY,GACA,iBACS,4BAZI,CAedA,GAGHF,OAAQA,EAGRC,SAAUA,EAGVP,OAAQA,EAGRC,oBAAqBA,EAErB/L,oBAAqBA,EAErBuM,WAAYA,EAEZC,cAAeA,EAEf5T,kBAAmBA,QAGlB,CAAA,IAAIF,QA8CH,IAAIjB,MAAM,sCA7CZxD,KAAKkE,kBACPyH,QAAQiN,KACN,mEAECnU,WAAaA,EAAWoU,KAAKnU,IACzB,CACLJ,QAASI,EAAKJ,SAAWA,EACzBoF,OAAQhF,EAAKgF,QAAUA,EACvBtC,YAAa1C,EAAK0C,aAAeA,EACjC2Q,eAAgBrT,EAAKqT,gBAAkBA,EACvCC,UAAWtT,EAAKsT,WAAaA,EAC7BC,gBACEvT,EAAKuT,gBAAkBL,EAAQa,uBAC/BtX,KAAKnB,MACPkY,kBACExT,EAAKwT,kBAAoBN,EAAQc,yBACjCvX,KAAKnB,MAEPqY,gBAAiB,CAAEM,GACA,iBAANA,EACQ,KAAbA,EAAEnJ,OAAsB,KACrBmJ,EAEQ,mBAANA,EACFA,EAAExX,KAAKnB,MAIdqY,GACA,iBACS,4BAZI,CAedA,GACHF,OAAQzT,EAAKyT,QAAUA,EACvBC,SAAU1T,EAAK0T,UAAYA,EAC3BP,OAAQnT,EAAKmT,OACbC,oBAAqBpT,EAAKoT,oBAC1B/L,oBAAqBrH,EAAKqH,oBAC1BuM,WAAY5T,EAAK4T,YAAcA,EAC/BC,cAAe7T,EAAK6T,eAAiBA,EACrC5T,kBAAmBD,EAAKC,mBAAqBA,UAO/C8E,EAAazJ,UACbc,EAAcd,UACdsI,EAAkBtI,UAClByV,EAAczV,4BAIXA,KAAK8Y,uBAGDC,MACP/Y,KAAK8Y,YAAcC,SAChBD,UAAYC,EACb/Y,KAAK2D,QAAQvC,SAAS,OAClB4X,EAAe,IAAIla,YAAa,kBAAiBia,UAClDpV,QAAQvC,QAAQ4L,cAAcgM,iCAKZtU,eACP,IAATA,EACD,GAAE1E,KAAK2D,QAAQc,WAAWH,UAAUtE,KAAK2D,QAAQiB,cACvD5E,KAAKgF,MAAMiF,kBAAkBjK,KAAK2D,QAAQvC,SAE1C,kCACCpB,KAAK2D,QAAQc,WAAWH,QACvBI,EAAK6S,SAASvX,KAAK2D,QAAQc,WAAW2T,WACxC,UAKFpY,KAAK2D,QAAQc,WAAWH,QACxBI,EAAK6S,SAASvX,KAAK2D,QAAQc,WAAW2T,yCAIXa,UACtBA,EAAUnD,iCAIV,CAAC,WAAY,SAGtBvR,kBACSvE,KAAKyE,WAAWoU,KAAKhI,GACnBA,EAAOvM,UAIlB4U,OAAOpU,OACAA,QACG,IAAItB,MAAM,qDAKI,oBAAX2V,QAA0BrU,aAAcqU,SACjDrU,EAAKA,EAAGsU,OAKRtU,EAAG/D,cAAgBsY,UACnBvU,EAAG/D,cAAgBuY,gBACnBxU,EAAG/D,cAAgBtB,MACnB,OACMW,EAAS0E,EAAG1E,WACb,IAAI6G,EAAI,EAAGA,EAAI7G,IAAU6G,OACvBsS,QAAQzU,EAAGmC,cAGbsS,QAAQzU,GAIjByU,QAAQzU,GACFA,EAAG0U,aAAa,iBAClB7N,QAAQiN,KAAK,gCAAkC9T,EAAGxB,eAG/CmW,eAAe3U,QACf7D,OAAOE,KAAK2D,GACjBA,EAAG4U,aAAa,gBAAgB,GAGlCD,eAAerY,OAC2C,IAApDwW,EAAQ+B,aAAajK,QAAQtO,EAAQkC,UAAkB,KACrDlC,EAAQwN,sBAGJ,IAAIpL,MAAM,4BAA8BpC,EAAQkC,UAFtDlC,EAAQwN,iBAAkB,GAOhCgL,WAAW7B,EAAgB3W,SASnBqS,EAAW7S,OAAOsH,iBACpBA,iBAAiB9G,GACjBA,EAAQ6G,aACN4R,EAAU7Z,KAAKgF,MAAM8D,cAAcwE,cAAc,OACrDwM,EAAK9Z,KAAKgF,MAAM8D,cAAcwE,cAAc,aAC9CuM,EAAQE,UAAYhC,EACpB8B,EAAQH,aAAa,WAAY,KACjCG,EAAQhM,YAAYiM,GACpBD,EAAQ7R,MAAMgS,SACZ7M,KAAK8M,MAAoC,GAA9BjT,SAASyM,EAASuG,WAAmB,KAClDH,EAAQ7R,MAAMgC,QAAU,OAlBL,CACjB,YACA,cACA,aACA,cACA,iBACA,cAcS5H,SAASwR,IAClBiG,EAAQ7R,MAAM4L,GAAQH,EAASG,MAG7B5T,KAAK+I,cACA/I,KAAK+I,cAAc8E,YAAYgM,GAGjC7Z,KAAKgF,MAAM8D,cAAc6B,KAAKkD,YAAYgM,GAGnDhV,YAAYzD,EAASyI,MAGjB7J,KAAKsC,UACLtC,KAAK2D,QAAQvC,UAAYA,GACzBpB,KAAK2D,QAAQiB,cAAgB5E,KAAKka,uCAI/BA,2BAA6Bla,KAAK2D,QAAQiB,YAG1C5E,KAAKgD,YACHA,KAAOhD,KAAK4Z,WACf5Z,KAAK2D,QAAQc,WAAWsT,eACxB3W,GAEFA,EAAQ+Y,YAAcna,KAAKgD,UACtBuF,WAAWpH,KAAKnB,KAAKgD,YAGvBwV,mBAAoB,OACpBxS,aAAe,EAEfhG,KAAK2D,QAAQiB,mBACXjB,QAAQiB,YAAc,UAGvBwV,EAAgB,CAACvC,EAAQwC,SAExBra,KAAKwY,iCAGLA,mBAAoB,EAErBlZ,SAASgb,gBAAkBta,KAAK2D,QAAQvC,kBAIxCiZ,cAEG1W,QAAQoB,KAAKoF,iBAAmBkQ,EAAaja,YAC7CuD,QAAQoB,KAAKH,YAChB,IAAI2V,OAAOF,EAAaja,QAAUJ,KAAK2D,QAAQoB,KAAKH,sBACjD4V,YAAYH,EAAazX,KAAM,KAAM,UAIxC6X,EAAQza,KAAK0V,OAAOnG,OAAOvP,KAAK2D,QAAQiB,YAAaiT,EAAQ,CAC/D7B,IAAKhW,KAAK2D,QAAQc,WAAW6T,WAAWtC,KAAO,SAC/CC,KAAMjW,KAAK2D,QAAQc,WAAW6T,WAAWrC,MAAQ,UACjDG,KAAMpW,KAAK2D,QAAQc,WAAW6T,WAAWlC,KACzCkB,QAAUxS,OACsC,iBAAnC9E,KAAK2D,QAAQc,WAAW0T,cAC1BrT,EAAG9E,KAAK2D,QAAQc,WAAW0T,QAC7B,GAA8C,mBAAnCnY,KAAK2D,QAAQc,WAAW0T,cACjCnY,KAAK2D,QAAQc,WAAW0T,OAAOrT,EAAI9E,KAAK2D,QAAQiB,mBAEjD,IAAIpB,MACR,mEAMJxD,KAAK2D,QAAQc,WAAW8T,gBAC1BkC,EAAQA,EAAM9K,MAAM,EAAG3P,KAAK2D,QAAQc,WAAW8T,qBAG5C5U,QAAQoC,cAAgB0U,QAEvBX,EAAK9Z,KAAKgD,KAAK0X,cAAc,UAC/BC,GAAW,KAEVF,EAAMra,OAiBJ,CACL0Z,EAAGvM,UAAY,SACTqN,EAAW5a,KAAKgF,MAAM8D,cAAc2E,yBAE1CgN,EAAMrY,SAAQ,CAACsC,EAAMmC,WACb1D,EAAKnD,KAAKgF,MAAM8D,cAAcwE,cAAc,MAClDnK,EAAGuW,aAAa,aAAc7S,GAC9B1D,EAAG4W,UAAY/Z,KAAK2D,QAAQc,WAAWuT,UACvC7U,EAAGxB,iBAAiB,aAAckE,WACvBgB,GAAS7G,KAAK6a,cAAchV,EAAE3C,QACnB,IAAhB2C,EAAEiV,gBACC7Z,OAAOuF,YAAYK,MAGxB7G,KAAKgG,eAAiBa,GACxB1D,EAAG+D,UAAUC,IAAInH,KAAK2D,QAAQc,WAAW2C,aAE3CjE,EAAGoK,UAAYvN,KAAK2D,QAAQc,WAAWyT,iBAAiBxT,GACxDkW,EAAS/M,YAAY1K,MAEvB2W,EAAGjM,YAAY+M,GACfD,GAAW,MAtCM,OACX3B,EAAe,IAAIla,YAAY,mBAAoB,CACvDK,OAAQa,KAAKgD,YAEVW,QAAQvC,QAAQ4L,cAAcgM,GAEmB,mBAA5ChZ,KAAK2D,QAAQc,WAAW4T,kBAC7BrY,KAAK2D,QAAQc,WAAW4T,oBAC1BrY,KAAK2D,QAAQc,WAAW4T,gBAEzBsC,GAAW,GAEwC,mBAA5C3a,KAAK2D,QAAQc,WAAW4T,gBAC1ByB,EAAGvM,UAAYvN,KAAK2D,QAAQc,WAAW4T,kBACvCyB,EAAGvM,UAAYvN,KAAK2D,QAAQc,WAAW4T,gBAC5CsC,GAAW,GAyBXA,SACGrY,UAAW,OACX0C,MAAM4E,oBAAoBC,KAIW,mBAAnC7J,KAAK2D,QAAQc,WAAWoT,QAC7B7X,KAAK2D,QAAQc,WAAWqT,2BACrB9U,KAAK0X,cAAc,MAAMnN,UAC5BvN,KAAK2D,QAAQc,WAAWqT,yBACrB9S,MAAM4E,oBAAoBC,SAG5BlG,QAAQc,WAAWoT,OAAO7X,KAAK2D,QAAQ8B,SAAU2U,IAEtDA,EAAcpa,KAAK2D,QAAQc,WAAWoT,QAI1CgD,cAAc/V,OACPA,EAAI,MAAO,SACV+B,EAAQ/B,EAAGpB,aAAa,qBACtBmD,EAA4C,CAAC/B,EAAI+B,GAAzC7G,KAAK6a,cAAc/V,EAAGvB,YAGxCwX,sBAAsB3Z,EAAS4Z,GACzB5Z,IAAY9B,SAASgb,oBAClBW,gBAAgB7Z,QAGlBuC,QAAQc,WAAazE,KAAKyE,WAAWuW,GAAmB,QACxDrX,QAAQC,iBAAkB,OAC1BD,QAAQvC,QAAUA,EAEnBA,EAAQ6I,kBACVjK,KAAKkb,mBAAmBlb,KAAK2D,QAAQc,WAAWH,SAC7CtE,KAAKmb,cAAc/Z,EAASpB,KAAK2D,QAAQc,WAAWH,cAEpDO,YAAYzD,GAInB6Z,gBAAgBnW,MACdA,EAAG+G,aAE8B,IAAxBjL,OAAOyN,mBACkB,IAAzB/O,SAAS+L,YAChB,OACMrG,EAAQ1F,SAAS+L,cACvBrG,EAAMoW,mBAAmBtW,GACzBE,EAAMwG,UAAS,SACTL,EAAMvK,OAAOyN,eACnBlD,EAAIM,kBACJN,EAAIS,SAAS5G,QACR,QAA6C,IAAlC1F,SAASqL,KAAK0Q,gBAAiC,OACzDC,EAAYhc,SAASqL,KAAK0Q,kBAChCC,EAAUC,kBAAkBzW,GAC5BwW,EAAU9P,UAAS,GACnB8P,EAAUE,UAKdN,mBAAmBtY,SACXuI,EAAMvK,OAAOyN,eACbrJ,EAAQmG,EAAI4D,WAAW,GAC7B/J,EAAMqI,uBACAsH,EAAWrV,SAASmc,eAAe7Y,GACzCoC,EAAM8I,WAAW6G,GACjB3P,EAAMoW,mBAAmBzG,GACzB3P,EAAMwG,UAAS,GACfL,EAAIM,kBACJN,EAAIS,SAAS5G,GAIfmW,cAAcO,EAAU9Y,SAChB+Y,EAAYD,EAASjV,cACvBmV,EAAWF,EAAS5O,qBAElB+O,EAAQH,EAAS5b,MAAM+M,UAAU,EAAG+O,GACpCE,EAAOJ,EAAS5b,MAAM+M,UAC1B6O,EAAS3O,aACT2O,EAAS5b,MAAMM,QAEjBsb,EAAS5b,MAAQ+b,EAAQjZ,EAAOkZ,EAChCF,GAAsBhZ,EAAKxC,OAC3Bsb,EAAS5O,eAAiB8O,EAC1BF,EAAS3O,aAAe6O,EACxBF,EAAS7P,QACT6P,EAASjV,UAAYkV,EAGvB3Z,WACMhC,KAAKgD,YACFA,KAAK2E,cACL3E,KAAO,WAETV,UAAW,OACXkW,mBAAoB,EAG3B/U,kBAAkBoD,EAAOmF,WAClBhK,WAEgB,iBADrB6E,EAAQG,SAASH,KACgB5C,MAAM4C,KAAWmF,EAAc9I,OAC9D,aACIwB,EAAO1E,KAAK2D,QAAQoC,cAAcc,GAClCkV,EAAU/b,KAAK2D,QAAQc,WAAWwT,eAAevT,GACvC,OAAZqX,GAAkB/b,KAAKwa,YAAYuB,EAAS/P,EAAetH,GAGjE8V,YAAYuB,EAAS/P,EAAetH,QAC7BM,MAAM8G,mBAAmBiQ,GAAS,GAAM,EAAM/P,EAAetH,GAGpEsX,QAAQvX,EAAYwX,EAAWnI,MACI,mBAAtBrP,EAAWoT,aACd,IAAIrU,MAAM,oDAIhBiB,EAAWoT,OAHD/D,EAGUmI,EAFAxX,EAAWoT,OAAOqE,OAAOD,GAMjDE,OAAOnB,EAAiBiB,EAAWnI,SAC3BjN,EAAQG,SAASgU,MACF,iBAAVnU,EACT,MAAM,IAAIrD,MAAM,+DAEZiB,EAAazE,KAAKyE,WAAWoC,QAE9BmV,QAAQvX,EAAYwX,EAAWnI,GAGtCsI,cAAcH,EAAWnI,OACnB9T,KAAKsC,eAGD,IAAIkB,MACR,sEAHGwY,QAAQhc,KAAK2D,QAAQc,WAAYwX,EAAWnI,GAQrDuI,OAAOvX,OACAA,QACG,IAAItB,MAAM,qDAII,oBAAX2V,QAA0BrU,aAAcqU,SACjDrU,EAAKA,EAAGsU,OAKRtU,EAAG/D,cAAgBsY,UACnBvU,EAAG/D,cAAgBuY,gBACnBxU,EAAG/D,cAAgBtB,MACnB,OACMW,EAAS0E,EAAG1E,WACb,IAAI6G,EAAI,EAAGA,EAAI7G,IAAU6G,OACvBqV,QAAQxX,EAAGmC,cAGbqV,QAAQxX,GAIjBwX,QAAQxX,QACD7D,OAAOW,OAAOkD,GACfA,EAAGqV,kBACA5R,WAAW3G,OAAOkD,EAAGqV,aAG5BrX,YAAW,KACTgC,EAAGyX,gBAAgB,qBACdja,UAAW,EACZwC,EAAGqV,aACLrV,EAAGqV,YAAYxS"}