{"version":3,"file":"tribute.min.js","sources":["../src/TributeEvents.js","../src/TributeMenuEvents.js","../src/TributeRange.js","../src/TributeSearch.js","../src/Tribute.js"],"sourcesContent":["/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\nclass TributeEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.events = this;\n  }\n\n  static keys() {\n    return [\"Tab\", \"Enter\", \"Escape\", \"ArrowUp\", \"ArrowDown\", \"Backspace\"];\n  }\n\n  static digits() {\n    return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\"]\n  }\n\n  static modifiers() {\n    return [\n      \"CapsLock\",\n      \"Control\",\n      \"Fn\",\n      \"Hyper\",\n      \"Meta\",\n      \"OS\",\n      \"Super\",\n      \"Symbol\",\n      \"Win\",\n    ];\n  }\n\n  bind(element) {\n    const KEY_EVENT_TIMEOUT_MS = 32;\n    element.boundKeyDown = this.tribute.debounce(\n      this.keydown.bind(element, this),\n      KEY_EVENT_TIMEOUT_MS\n    );\n    element.boundKeyUpInput = this.tribute.debounce(\n      this.input.bind(element, this),\n      KEY_EVENT_TIMEOUT_MS\n    );\n\n    element.addEventListener(\"keydown\", element.boundKeyDown, true);\n    element.addEventListener(\"keyup\", element.boundKeyUpInput, true);\n    element.addEventListener(\"input\", element.boundKeyUpInput, true);\n  }\n\n  unbind(element) {\n    element.removeEventListener(\"keydown\", element.boundKeyDown, true);\n    element.removeEventListener(\"keyup\", element.boundKeyUpInput, true);\n    element.removeEventListener(\"input\", element.boundKeyUpInput, true);\n\n    delete element.boundKeyDown;\n    delete element.boundKeyUpInput;\n  }\n\n  keydown(instance, event) {\n    let controlKeyPressed = false;\n    let keyProcessed = false;\n\n    if (event instanceof KeyboardEvent) {\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n    }\n\n    if (!controlKeyPressed) {\n      TributeEvents.keys().forEach((key) => {\n        if (\n          key === event.code &&\n          // Special handling of Backspace\n          (instance.tribute.isActive || event.code == \"Backspace\")) {\n            instance.callbacks()[key](event, this);\n            keyProcessed = true;\n            return;\n        }\n      });\n      if (instance.tribute.selectByDigit) {\n        TributeEvents.digits().forEach((key, index) => {\n          if (key === event.key && instance.tribute.isActive) {\n            const count = instance.tribute.current.filteredItems.length;\n            if (index < count) {\n              instance.callbacks()['Digit'](event, index, this);\n              keyProcessed = true;\n              return;\n            }\n          }\n        });\n      }\n    }\n\n    if (!keyProcessed) {\n      instance.tribute.lastReplacement = null;\n      instance.tribute.hideMenu();\n    }\n  }\n\n  input(instance, event) {\n    const cEvent = event instanceof CustomEvent;\n    const iEvent = event instanceof InputEvent;\n    const iEventHandle = iEvent && (event.inputType == \"insertText\"\n      || event.inputType == \"insertCompositionText\"\n      || event.inputType.startsWith(\"deleteContent\"));\n\n    if (cEvent) {\n      return;\n    }\n    if (iEvent && !iEventHandle) {\n      return;\n    }\n    \n    instance.keyup.call(this, instance, event);\n  }\n\n  click(instance, event) {\n    const tribute = instance.tribute;\n    if (tribute.menu && tribute.menu.contains(event.target)) {\n      let li = event.target;\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      while (li.nodeName.toLowerCase() !== \"li\") {\n        if (li.nodeName.toLowerCase() === \"lh\") return;\n        \n        li = li.parentNode;\n        if (!li || li === tribute.menu) {\n          throw new Error(\"cannot find the <li> container for the click\");\n        }\n      }\n\n      tribute.selectItemAtIndex(li.getAttribute(\"data-index\"), event);\n    } else {\n      tribute.hideMenu();\n    }\n  }\n\n  keyup(instance, event) {\n    // Check for modifiers keys\n    if (event instanceof KeyboardEvent) {\n      if (event.key && event.key.length > 1) {\n        // Not a Character exit early\n        return;\n      }\n\n      let controlKeyPressed = false;\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      // Check for control keys\n      TributeEvents.keys().forEach((key) => {\n        if (key === event.code) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      if (controlKeyPressed) return;\n    }\n\n    if (!instance.updateSelection(this)) return;\n\n    const keyCode = instance.getKeyCode(event);\n    // Exit if no keyCode\n    if (isNaN(keyCode)) {\n      return;\n    }\n\n    if (!instance.tribute.autocompleteMode) {\n      const trigger = instance.tribute.triggers().find((trigger) => {\n        return trigger.charCodeAt(0) === keyCode;\n      });\n      if (!trigger) return;\n      const collection = instance.tribute.collection.find((item) => {\n        return item.trigger === trigger;\n      });\n      if (!collection) return;\n      instance.tribute.current.collection = collection;\n    } else {\n      instance.tribute.current.collection = instance.tribute.collection[0];\n    }\n    if (\n      instance.tribute.current.collection.menuShowMinLength >\n      instance.tribute.current.mentionText.length\n    )\n    return;\n    instance.tribute.showMenuFor(this, true);\n  }\n\n  getKeyCode(event) {\n    const keyCode = event.keyCode || event.which || event.code;\n    if (keyCode) {\n      return keyCode;\n    }\n    if (event instanceof InputEvent && event.data) {\n      return event.data.charCodeAt(event.data.length - 1);\n    }\n    if (this.tribute.current.mentionTriggerChar) {\n      return this.tribute.current.mentionTriggerChar.charCodeAt(0);\n    }\n    if (this.tribute.current.mentionText) {\n      return this.tribute.current.mentionText.charCodeAt(\n          this.tribute.current.mentionText.length - 1);\n    }\n\n    return NaN;\n  }\n\n  updateSelection(el) {\n    this.tribute.current.element = el;\n    const info = this.tribute.range.getTriggerInfo(\n      this.tribute.allowSpaces,\n      this.tribute.autocompleteMode\n    );\n\n    if (info) {\n      this.tribute.current.mentionTriggerChar = info.mentionTriggerChar;\n      this.tribute.current.mentionText = info.mentionText;\n      this.tribute.current.mentionPosition = info.mentionPosition;\n      this.tribute.current.fullText = info.fullText;\n      this.tribute.current.nextChar = info.nextChar;\n      return true;\n    }\n\n    return false;\n  }\n\n  callbacks() {\n    return {\n      Backspace: (e, _el) => {\n        if (this.tribute.lastReplacement) {\n          if (this.tribute.events.updateSelection(_el) &&\n             (this.tribute.current.mentionPosition + this.tribute.current.mentionText.length) ==\n            (this.tribute.lastReplacement.mentionPosition + this.tribute.lastReplacement.content.length)) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            const addSpace = false;//this.tribute.lastReplacement.content !== this.tribute.lastReplacement.content.trimEnd();\n\n            this.tribute.current = {...this.tribute.lastReplacement};\n            this.tribute.current.mentionText = this.tribute.lastReplacement.content;\n            this.tribute.replaceText(this.tribute.lastReplacement.mentionText + (addSpace ? \" \" : \"\"), e, null);\n          }\n          this.tribute.lastReplacement = null;\n          this.tribute.current = {};\n        }\n        this.tribute.hideMenu();\n      },\n      Digit: (e, digit, el) => {\n        this.setActiveLi(digit);\n        this.callbacks().Enter(e, el);\n     },\n      Enter: (e, _el) => {\n        // choose selection\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          this.tribute.selectItemAtIndex(this.tribute.menuSelected, e);\n        }\n      },\n      Escape: (e, _el) => {\n        if (this.tribute.isActive) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          this.tribute.hideMenu();\n        }\n      },\n      Tab: (e, el) => {\n        // choose first match\n        this.callbacks().Enter(e, el);\n      },\n      Space: (e, el) => {\n        if (this.tribute.isActive) {\n          if (this.tribute.spaceSelectsMatch) {\n            this.callbacks().Enter(e, el);\n          } else {\n            this.tribute.hideMenu();\n          }\n        }\n      },\n      ArrowUp: (e, _el) => {\n        // navigate up ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          const count = this.tribute.current.filteredItems.length,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected && selected > 0) {\n            this.setActiveLi(selected - 1);\n          } else if (selected === 0) {\n            this.setActiveLi(count - 1);\n            this.tribute.menu.scrollTop = this.tribute.menu.scrollHeight;\n          }\n        }\n      },\n      ArrowDown: (e, _el) => {\n        // navigate down ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          const count = this.tribute.current.filteredItems.length - 1,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected) {\n            this.setActiveLi(selected + 1);\n          } else if (count === selected) {\n            this.setActiveLi(0);\n            this.tribute.menu.scrollTop = 0;\n          }\n        }\n      },\n    };\n  }\n\n  setActiveLi(index) {\n    const lis = this.tribute.menu.querySelectorAll(\"li\"),\n      length = lis.length >>> 0;\n\n    this.tribute.menuSelected = index;\n\n    for (let i = 0; i < length; i++) {\n      const li = lis[i];\n      if (i === this.tribute.menuSelected) {\n        li.classList.add(this.tribute.current.collection.selectClass);\n\n        const liClientRect = li.getBoundingClientRect();\n        const menuClientRect = this.tribute.menu.getBoundingClientRect();\n\n        if (liClientRect.bottom > menuClientRect.bottom) {\n          const scrollDistance = liClientRect.bottom - menuClientRect.bottom;\n          this.tribute.menu.scrollTop += scrollDistance;\n        } else if (liClientRect.top < menuClientRect.top) {\n          const scrollDistance = menuClientRect.top - liClientRect.top;\n          this.tribute.menu.scrollTop -= scrollDistance;\n        }\n      } else {\n        li.classList.remove(this.tribute.current.collection.selectClass);\n      }\n    }\n  }\n}\n\nexport default TributeEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\nclass TributeMenuEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.menuEvents = this;\n    this.menu = this.tribute.menu;\n  }\n\n  bind(_menu) {\n    const DEBOUNCE_TIMEOUT_MS = 100;\n    this.menuClickEvent = this.tribute.events.click.bind(null, this);\n    this.menuContainerScrollEvent = this.tribute.debounce(() => {\n      this.tribute.hideMenu();\n    }, DEBOUNCE_TIMEOUT_MS);\n    this.windowResizeEvent = this.tribute.debounce(() => {\n      this.tribute.hideMenu();\n    }, DEBOUNCE_TIMEOUT_MS);\n\n    this.windowBlurEvent = () => {\n      this.tribute.hideMenu();\n    };\n\n    this.tribute.range\n      .getDocument()\n      .addEventListener(\"mousedown\", this.menuClickEvent, false);\n    window.addEventListener(\"resize\", this.windowResizeEvent);\n    window.addEventListener(\"blur\", this.windowBlurEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.addEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.addEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n\n  unbind(_menu) {\n    this.tribute.range\n      .getDocument()\n      .removeEventListener(\"mousedown\", this.menuClickEvent, false);\n    window.removeEventListener(\"resize\", this.windowResizeEvent);\n    window.removeEventListener(\"blur\", this.windowBlurEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.removeEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.removeEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n}\n\nexport default TributeMenuEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/jeff-collins/ment.io\n\nclass TributeRange {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.range = this;\n  }\n\n  getDocument() {\n    let iframe;\n    if (this.tribute.current.collection) {\n      iframe = this.tribute.current.collection.iframe;\n    }\n\n    if (!iframe) {\n      return document;\n    }\n\n    return iframe.contentWindow.document;\n  }\n\n  positionMenuAtCaret(scrollTo) {\n    const context = this.tribute.current;\n    let coordinates;\n\n    if (!this.tribute.positionMenu) {\n      this.tribute.menu.style.display = `block`;\n      return;\n    }\n\n    if (!this.isContentEditable(context.element)) {\n      coordinates = this.getTextAreaOrInputUnderlinePosition(\n        context.element,\n        context.mentionPosition + context.mentionText.length\n      );\n    } else {\n      coordinates = this.getContentEditableCaretPosition(\n        context.mentionPosition + context.mentionText.length\n      );\n    }\n\n    this.tribute.menu.style.top = `${coordinates.top}px`;\n    this.tribute.menu.style.left = `${coordinates.left}px`;\n    this.tribute.menu.style.right = `${coordinates.right}px`;\n    this.tribute.menu.style.bottom = `${coordinates.bottom}px`;\n    this.tribute.menu.style[\"max-heigh\"] = `${coordinates.maxHeight || 500}px`;\n    this.tribute.menu.style[\"max-width\"] = `${coordinates.maxWidth || 300}px`;\n    this.tribute.menu.style.position = `${coordinates.position || \"absolute\"}`;\n    this.tribute.menu.style.display = `block`;\n\n    if (coordinates.left === \"auto\") {\n      this.tribute.menu.style.left = \"auto\";\n    }\n\n    if (coordinates.top === \"auto\") {\n      this.tribute.menu.style.top = \"auto\";\n    }\n\n    if (scrollTo) this.scrollIntoView();\n  }\n\n  replaceTriggerText(text, originalEvent, item) {\n    const context = this.tribute.current;\n    const detail = {\n      item: item,\n      context: context,\n      event: originalEvent,\n      text: text,\n    };\n    const replaceEvent = new CustomEvent(\"tribute-replaced\");\n\n    if (!this.isContentEditable(context.element)) {\n      const myField = this.tribute.current.element;\n      const textSuffix =\n        typeof this.tribute.replaceTextSuffix === \"string\"\n          ? this.tribute.replaceTextSuffix\n          : \" \";\n      text = this.stripHtml(text);\n      text += textSuffix;\n      const startPos = context.mentionPosition;\n      let endPos =\n        context.mentionPosition +\n        context.mentionText.length +\n        textSuffix.length;\n      if (!this.tribute.autocompleteMode && context.mentionTriggerChar.length) {\n        endPos += context.mentionTriggerChar.length - 1;\n      }\n      myField.value =\n        myField.value.substring(0, startPos) +\n        text +\n        myField.value.substring(endPos, myField.value.length);\n      myField.selectionStart = startPos + text.length;\n      myField.selectionEnd = startPos + text.length;\n    } else {\n      const {\n        sel,\n        range\n      } = this.getContentEditableSelectionStart(true);\n      const staticRange = new StaticRange({startContainer: sel.anchorNode, startOffset: sel.anchorOffset - context.mentionText.length, endContainer: sel.anchorNode, endOffset: sel.anchorOffset });\n      const textSuffix =\n        typeof this.tribute.replaceTextSuffix === \"string\"\n          ? this.tribute.replaceTextSuffix\n          : \"\\xA0\";\n      text += textSuffix;\n\n      context.element.dispatchEvent(new InputEvent(\"beforeinput\", {\n        bubbles: true,\n        data: text,\n        cancelable: true,\n        inputType: \"insertReplacementText\",\n        targetRanges: [staticRange],\n\n      }));\n\n      this.pasteContentEditable(\n        text,\n        context.mentionText.length + context.mentionTriggerChar.length\n      );\n    }\n\n    context.element.dispatchEvent(\n      new CustomEvent(\"input\", { bubbles: true, detail: detail })\n    );\n    context.element.dispatchEvent(replaceEvent);\n  }\n\n  pasteContentEditable(html, numOfCharsToRemove) {\n    const { sel, range } = this.getContentEditableSelectionStart(true);\n    if (sel) {\n      const strippedText = this.stripHtml(html);\n      const isHTML = html !== strippedText;\n      const useSimpleReplace =\n        !isHTML &&\n        sel.anchorOffset >= numOfCharsToRemove &&\n        sel.anchorOffset <= sel.anchorNode.nodeValue.length;\n      if (useSimpleReplace) {\n        this.pasteText(sel, range, strippedText, numOfCharsToRemove);\n      } else {\n        this.pasteHtml(sel, range, html, numOfCharsToRemove);\n      }\n    }\n  }\n\n  pasteText(sel, range, text, numOfCharsToRemove) {\n    const pre = sel.anchorNode.nodeValue.substring(\n      0,\n      sel.anchorOffset - numOfCharsToRemove\n    );\n    const post = sel.anchorNode.nodeValue.substring(\n      sel.anchorOffset,\n      sel.anchorNode.nodeValue.length\n    );\n    sel.anchorNode.nodeValue = pre + text + post;\n    range.setStart(sel.anchorNode, pre.length + text.length);\n    range.collapse(true);\n    sel.removeAllRanges();\n    sel.addRange(range);\n    sel.collapseToEnd();\n  }\n\n  pasteHtml(sel, _range, html, numOfCharsToRemove) {\n    for (let index = 0; index < numOfCharsToRemove; index++) {\n      sel.modify(\"extend\", \"backward\", \"character\");\n    }\n    const newRange = sel.getRangeAt(0);\n    newRange.deleteContents();\n\n    const el = this.getDocument().createElement(\"div\");\n    el.innerHTML = html;\n    const frag = this.getDocument().createDocumentFragment();\n    let node, lastNode;\n\n    while ((node = el.firstChild)) {\n      lastNode = frag.appendChild(node);\n    }\n    newRange.insertNode(frag);\n\n    // Preserve the selection\n    if (lastNode) {\n      newRange.setStart(lastNode, lastNode.length);\n      newRange.setEnd(lastNode, lastNode.length);\n      newRange.collapse(true);\n      sel.removeAllRanges();\n      sel.addRange(newRange);\n      sel.collapseToEnd();\n    }\n  }\n\n  stripHtml(html) {\n    const tmp = this.getDocument().createElement(\"DIV\");\n    tmp.innerHTML = html;\n    return tmp.textContent || tmp.innerText || \"\";\n  }\n\n  getWindowSelection() {\n    if (this.tribute.collection.iframe) {\n      return this.tribute.collection.iframe.contentWindow.getSelection();\n    }\n\n    const rootNode = this.tribute.current.element.getRootNode();\n    if (rootNode.getSelection) return rootNode.getSelection();\n    else return window.getSelection();\n  }\n\n  getContentEditableSelectionStart(moveToEndOfWord) {\n    const sel = this.getWindowSelection();\n    if (!sel.isCollapsed) {\n      return { sel: null, range: null, direction: null };\n    }\n    const direction = sel.anchorOffset <= sel.focusOffset;\n    const range = sel.getRangeAt(0);\n    const selectedElem = sel.anchorNode;\n    const workingNodeContent = selectedElem.textContent;\n    const selectStartOffset = range.startOffset;\n    let nextChar =\n      workingNodeContent.length > selectStartOffset\n        ? workingNodeContent[selectStartOffset]\n        : null;\n    if (nextChar === null) {\n      if (selectedElem.nextSibling && selectedElem.nextSibling.textContent) {\n        const nextNodeText = selectedElem.nextSibling.textContent;\n        nextChar = nextNodeText.length ? nextNodeText[0] : null;\n      }\n    }\n    const nextCharIsSeparator =\n      !this.tribute.autocompleteSeparator ||\n      (nextChar && nextChar.match(this.tribute.autocompleteSeparator));\n    sel.collapseToEnd();\n    if (nextChar && !nextCharIsSeparator && moveToEndOfWord)\n      sel.modify(\"move\", \"forward\", \"word\");\n\n    return { sel, range, direction };\n  }\n\n  getWholeWordsUpToCharIndex(str, minLen) {\n    if (this.tribute.autocompleteSeparator) {\n      let searchPos = 0;\n      const arr = str\n        .split(this.tribute.autocompleteSeparator)\n        .filter(function (e) {\n          return e.trim();\n        });\n\n      for (let i = 0, len = arr.length; i < len; i++) {\n        const idx = str.indexOf(arr[i], searchPos);\n        searchPos += arr[i].length;\n\n        if (minLen >= idx && minLen <= idx + arr[i].length) {\n          minLen = idx + arr[i].length;\n          break;\n        }\n      }\n    }\n\n    const nextChar = str.length > minLen ? str[minLen] : \"\";\n    return [str.substring(0, minLen), nextChar];\n  }\n\n  getTextForCurrentSelection() {\n    const context = this.tribute.current;\n    let effectiveRange = null;\n    let nextChar = \"\";\n\n    if (!this.isContentEditable(context.element)) {\n      const textComponent = this.tribute.current.element;\n      if (textComponent) {\n        const startPos = textComponent.selectionStart;\n        const endPos = textComponent.selectionEnd;\n\n        if (textComponent.value && startPos >= 0 && startPos === endPos) {\n          const result = this.getWholeWordsUpToCharIndex(\n            textComponent.value,\n            startPos\n          );\n          effectiveRange = result[0];\n          nextChar = result[1];\n        }\n      }\n    } else {\n      const { sel, range, direction } =\n        this.getContentEditableSelectionStart(true);\n      if (sel) {\n        const selectedElem = sel.anchorNode;\n        const workingNodeContent = selectedElem.textContent;\n        const selectStartOffset = sel.getRangeAt(0).startOffset;\n        effectiveRange = sel.toString().trim();\n        nextChar =\n          workingNodeContent.length > selectStartOffset\n            ? workingNodeContent[selectStartOffset]\n            : \"\";\n\n        for (\n          let index = 0;\n          index < this.tribute.numberOfWordsInContextText;\n          index++\n        ) {\n          sel.modify(\"extend\", \"backward\", \"word\");\n          const newText = sel.toString();\n\n          if (\n            newText.length > effectiveRange.length &&\n            newText.endsWith(effectiveRange)\n          ) {\n            // Workarounds Firefox issue, where selection sometimes collapse or move instead of extend\n            effectiveRange = newText;\n          }\n        }\n\n        this.restoreSelection(sel, range, direction);\n      }\n    }\n\n    return { effectiveRange, nextChar };\n  }\n\n  getLastWordInText(text) {\n    if (this.tribute.autocompleteSeparator) {\n      const wordsArray = text.split(this.tribute.autocompleteSeparator);\n      if (!wordsArray.length) return \" \";\n      return wordsArray[wordsArray.length - 1];\n    }\n    return text;\n  }\n\n  escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  }\n\n  getTriggerInfo(allowSpaces, isAutocomplete) {\n    let requireLeadingSpace = true;\n    const { effectiveRange, nextChar } = this.getTextForCurrentSelection();\n    if (effectiveRange === null) return null;\n    const lastWordOfEffectiveRange = this.getLastWordInText(effectiveRange);\n\n    if (isAutocomplete) {\n      return {\n        mentionPosition:\n          effectiveRange.length - lastWordOfEffectiveRange.length,\n        mentionText: lastWordOfEffectiveRange,\n        fullText: effectiveRange,\n        nextChar: nextChar,\n        mentionTriggerChar: \"\",\n      };\n    }\n\n    if (effectiveRange !== undefined && effectiveRange !== null) {\n      let mostRecentTriggerCharPos = -1;\n      let triggerChar;\n\n      this.tribute.collection.forEach((config) => {\n        const c = config.trigger;\n        const regExpStr =\n          \"(\" +\n          (config.requireLeadingSpace ? \"\\\\s\" : \"\") +\n          this.escapeRegExp(c) +\n          \")(?!.*\\\\1)\";\n        const searchRes = effectiveRange.match(RegExp(regExpStr));\n        const idx = (() => {\n          if (searchRes)\n            return searchRes.index + (config.requireLeadingSpace ? 1 : 0);\n          if (effectiveRange.startsWith(c)) return 0;\n          return -1;\n        })();\n\n        if (idx > mostRecentTriggerCharPos) {\n          mostRecentTriggerCharPos = idx;\n          triggerChar = c;\n          requireLeadingSpace = config.requireLeadingSpace;\n        }\n      });\n\n      if (\n        mostRecentTriggerCharPos >= 0 &&\n        (mostRecentTriggerCharPos === 0 ||\n          !requireLeadingSpace ||\n          /\\s/.test(\n            effectiveRange.substring(\n              mostRecentTriggerCharPos - 1,\n              mostRecentTriggerCharPos\n            )\n          ))\n      ) {\n        const currentTriggerSnippet = effectiveRange.substring(\n          mostRecentTriggerCharPos + triggerChar.length,\n          effectiveRange.length\n        );\n\n        triggerChar = effectiveRange.substring(\n          mostRecentTriggerCharPos,\n          mostRecentTriggerCharPos + triggerChar.length\n        );\n        const firstSnippetChar = currentTriggerSnippet.substring(0, 1);\n        const leadingSpace =\n          currentTriggerSnippet.length > 0 &&\n          (firstSnippetChar === \" \" || firstSnippetChar === \"\\xA0\");\n\n        const trailingSpace =\n          currentTriggerSnippet !== currentTriggerSnippet.trimEnd();\n\n        if (!leadingSpace && (allowSpaces || !trailingSpace)) {\n          return {\n            mentionPosition: mostRecentTriggerCharPos,\n            mentionText: currentTriggerSnippet,\n            mentionTriggerChar: triggerChar,\n            fullText: effectiveRange,\n            nextChar: \"\",\n          };\n        }\n      }\n    }\n  }\n\n  isContentEditable(element) {\n    return element.nodeName !== \"INPUT\" && element.nodeName !== \"TEXTAREA\";\n  }\n\n  isMenuOffScreen(coordinates, menuDimensions) {\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    const doc = this.getDocument().documentElement;\n    const windowLeft =\n      (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n    const windowTop =\n      (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n\n    const menuTop =\n      typeof coordinates.top === \"number\"\n        ? coordinates.top\n        : coordinates.bottom - menuDimensions.height;\n    const menuRight =\n      typeof coordinates.right === \"number\"\n        ? coordinates.right\n        : coordinates.left + menuDimensions.width;\n    const menuBottom =\n      typeof coordinates.bottom === \"number\"\n        ? coordinates.bottom\n        : coordinates.top + menuDimensions.height;\n    const menuLeft =\n      typeof coordinates.left === \"number\"\n        ? coordinates.left\n        : coordinates.right - menuDimensions.width;\n\n    return {\n      top: menuTop < Math.floor(windowTop),\n      right: menuRight > Math.ceil(windowLeft + windowWidth),\n      bottom: menuBottom > Math.ceil(windowTop + windowHeight),\n      left: menuLeft < Math.floor(windowLeft),\n    };\n  }\n\n  getMenuDimensions() {\n    // Width of the menu depends of its contents and position\n    // We must check what its width would be without any obstruction\n    // This way, we can achieve good positioning for flipping the menu\n    const dimensions = {\n      width: null,\n      height: null,\n    };\n\n    this.tribute.menu.style.top = `0px`;\n    this.tribute.menu.style.left = `0px`;\n    this.tribute.menu.style.right = null;\n    this.tribute.menu.style.bottom = null;\n    this.tribute.menu.style.position = `fixed`;\n    this.tribute.menu.style.visibility = `hidden`;\n    this.tribute.menu.style.display = `block`;\n\n    dimensions.width = this.tribute.menu.offsetWidth;\n    dimensions.height = this.tribute.menu.offsetHeight;\n\n    this.tribute.menu.style.display = `none`;\n    this.tribute.menu.style.visibility = `visible`;\n\n    return dimensions;\n  }\n\n  getTextAreaOrInputUnderlinePosition(element, position, _flipped) {\n    const properties = [\n      \"direction\",\n      \"boxSizing\",\n      \"width\",\n      \"height\",\n      \"overflowX\",\n      \"overflowY\",\n      \"borderTopWidth\",\n      \"borderRightWidth\",\n      \"borderBottomWidth\",\n      \"borderLeftWidth\",\n      \"borderStyle\",\n      \"paddingTop\",\n      \"paddingRight\",\n      \"paddingBottom\",\n      \"paddingLeft\",\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSize\",\n      \"fontSizeAdjust\",\n      \"lineHeight\",\n      \"fontFamily\",\n      \"textAlign\",\n      \"textTransform\",\n      \"textIndent\",\n      \"textDecoration\",\n      \"letterSpacing\",\n      \"wordSpacing\",\n    ];\n\n    const div = this.getDocument().createElement(\"div\");\n    div.id = \"input-textarea-caret-position-mirror-div\";\n    this.getDocument().body.appendChild(div);\n\n    const style = div.style;\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n\n    style.whiteSpace = \"pre-wrap\";\n    if (element.nodeName !== \"INPUT\") {\n      style.wordWrap = \"break-word\";\n    }\n\n    // position off-screen\n    style.position = \"absolute\";\n    style.visibility = \"hidden\";\n\n    // transfer the element's properties to the div\n    properties.forEach((prop) => {\n      style[prop] = computed[prop];\n    });\n\n    const span0 = this.getDocument().createElement(\"span\");\n    span0.textContent = element.value.substring(0, position);\n    div.appendChild(span0);\n\n    if (element.nodeName === \"INPUT\") {\n      div.textContent = div.textContent.replace(/\\s/g, \"Â \");\n    }\n\n    //Create a span in the div that represents where the cursor\n    //should be\n    const span = this.getDocument().createElement(\"span\");\n    //we give it no content as this represents the cursor\n    div.appendChild(span);\n\n    const span2 = this.getDocument().createElement(\"span\");\n    span2.textContent = element.value.substring(position, position + 1);\n    div.appendChild(span2);\n\n    const rect = element.getBoundingClientRect();\n\n    //position the div exactly over the element\n    //so we can get the bounding client rect for the span and\n    //it should represent exactly where the cursor is\n    div.style.position = \"fixed\";\n    div.style.left = rect.left + \"px\";\n    div.style.top = rect.top + \"px\";\n    div.style.width = rect.width + \"px\";\n    div.style.height = rect.height + \"px\";\n    div.scrollTop = element.scrollTop;\n\n    const spanRect = span.getBoundingClientRect();\n    const divRect = div.getBoundingClientRect();\n    this.getDocument().body.removeChild(div);\n    const clamp = function (number, min, max) {\n      return Math.max(min, Math.min(number, max));\n    };\n    const finalRect = {\n      height: Math.min(divRect.height, spanRect.height),\n      left: clamp(spanRect.left, divRect.left, divRect.left + divRect.width),\n      top: clamp(spanRect.top, divRect.top, divRect.top + divRect.height),\n    };\n    return this.getFixedCoordinatesRelativeToRect(finalRect);\n  }\n\n  getContentEditableCaretPosition(_selectedNodePosition) {\n    const { sel, range, direction } =\n      this.getContentEditableSelectionStart(false);\n    const newRange = sel.getRangeAt(0);\n    // restore selection\n    this.restoreSelection(sel, range, direction);\n    let rect = newRange.getBoundingClientRect();\n    if (sel.anchorNode.parentNode) {\n      const parentNodeRect = sel.anchorNode.parentNode.getBoundingClientRect();\n      const clamp = function (number, min, max) {\n        return Math.max(min, Math.min(number, max));\n      };\n      rect = {\n        height: Math.min(parentNodeRect.height, rect.height),\n        left: clamp(\n          rect.left,\n          parentNodeRect.left,\n          parentNodeRect.left + parentNodeRect.width\n        ),\n        top: clamp(\n          rect.top,\n          parentNodeRect.top,\n          parentNodeRect.top + parentNodeRect.height\n        ),\n      };\n    }\n    return this.getFixedCoordinatesRelativeToRect(rect);\n  }\n\n  getFixedCoordinatesRelativeToRect(rect) {\n    const coordinates = {\n      position: \"fixed\",\n      left: rect.left,\n      top: rect.top + rect.height,\n    };\n\n    const menuDimensions = this.getMenuDimensions();\n\n    const availableSpaceOnTop = rect.top;\n    const availableSpaceOnBottom =\n      window.innerHeight - (rect.top + rect.height);\n\n    //check to see where's the right place to put the menu vertically\n    if (availableSpaceOnBottom < menuDimensions.height) {\n      if (\n        availableSpaceOnTop >= menuDimensions.height ||\n        availableSpaceOnTop > availableSpaceOnBottom\n      ) {\n        coordinates.top = \"auto\";\n        coordinates.bottom = window.innerHeight - rect.top;\n        if (availableSpaceOnBottom < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnTop;\n        }\n      } else {\n        if (availableSpaceOnTop < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnBottom;\n        }\n      }\n    }\n\n    const availableSpaceOnLeft = rect.left;\n    const availableSpaceOnRight = window.innerWidth - rect.left;\n\n    //check to see where's the right place to put the menu horizontally\n    if (availableSpaceOnRight < menuDimensions.width) {\n      if (\n        availableSpaceOnLeft >= menuDimensions.width ||\n        availableSpaceOnLeft > availableSpaceOnRight\n      ) {\n        coordinates.left = \"auto\";\n        coordinates.right = window.innerWidth - rect.left;\n        if (availableSpaceOnRight < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnLeft;\n        }\n      } else {\n        if (availableSpaceOnLeft < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnRight;\n        }\n      }\n    }\n\n    return coordinates;\n  }\n\n  scrollIntoView(_elem) {\n    const reasonableBuffer = 20;\n    const maxScrollDisplacement = 100;\n    let clientRect;\n    let e = this.menu;\n\n    if (typeof e === \"undefined\") return;\n\n    while (clientRect === undefined || clientRect.height === 0) {\n      clientRect = e.getBoundingClientRect();\n\n      if (clientRect.height === 0) {\n        e = e.childNodes[0];\n        if (e === undefined || !e.getBoundingClientRect) {\n          return;\n        }\n      }\n    }\n\n    const elemTop = clientRect.top;\n    const elemBottom = elemTop + clientRect.height;\n\n    if (elemTop < 0) {\n      window.scrollTo(\n        0,\n        window.pageYOffset + clientRect.top - reasonableBuffer\n      );\n    } else if (elemBottom > window.innerHeight) {\n      let maxY = window.pageYOffset + clientRect.top - reasonableBuffer;\n\n      if (maxY - window.pageYOffset > maxScrollDisplacement) {\n        maxY = window.pageYOffset + maxScrollDisplacement;\n      }\n\n      let targetY = window.pageYOffset - (window.innerHeight - elemBottom);\n\n      if (targetY > maxY) {\n        targetY = maxY;\n      }\n\n      window.scrollTo(0, targetY);\n    }\n  }\n\n  restoreSelection(sel, range, directionFwd = true) {\n    sel.removeAllRanges();\n\n    if (directionFwd) {\n      sel.addRange(range);\n    } else {\n      const endRange = range.cloneRange();\n      endRange.collapse(false);\n      sel.addRange(endRange);\n      sel.extend(range.startContainer, range.startOffset);\n    }\n  }\n}\n\nexport default TributeRange;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/mattyork/fuzzy\nclass TributeSearch {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.search = this;\n  }\n\n  match(pattern, string, opts) {\n    opts = opts || {};\n    const pre = opts.pre || \"\",\n      post = opts.post || \"\",\n      compareString = (opts.caseSensitive && string) || string.toLowerCase();\n\n    if (opts.skip) {\n      return { rendered: string, score: 0 };\n    }\n\n    pattern = (opts.caseSensitive && pattern) || pattern.toLowerCase();\n\n    const patternCache = this.traverse(compareString, pattern, 0, 0, []);\n    if (!patternCache) {\n      return null;\n    }\n    return {\n      rendered: this.render(string, patternCache.cache, pre, post),\n      score: patternCache.score,\n    };\n  }\n\n  traverse(string, pattern, stringIndex, patternIndex, patternCache) {\n    if (this.tribute.autocompleteMode && this.tribute.autocompleteSeparator) {\n      // if the pattern search at end\n      pattern = pattern.split(this.tribute.autocompleteSeparator).splice(-1)[0];\n    }\n\n    if (pattern.length === patternIndex) {\n      // calculate score and copy the cache containing the indices where it's found\n      return {\n        score: this.calculateScore(patternCache),\n        cache: patternCache.slice(),\n      };\n    }\n\n    // if string at end or remaining pattern > remaining string\n    if (\n      string.length === stringIndex ||\n      pattern.length - patternIndex > string.length - stringIndex\n    ) {\n      return undefined;\n    }\n\n    const c = pattern[patternIndex];\n    let index = string.indexOf(c, stringIndex);\n    let best;\n    let temp;\n\n    while (index > -1) {\n      patternCache.push(index);\n      temp = this.traverse(\n        string,\n        pattern,\n        index + 1,\n        patternIndex + 1,\n        patternCache\n      );\n      patternCache.pop();\n\n      // if downstream traversal failed, return best answer so far\n      if (!temp) {\n        return best;\n      }\n\n      if (!best || best.score < temp.score) {\n        best = temp;\n      }\n\n      index = string.indexOf(c, index + 1);\n    }\n\n    return best;\n  }\n\n  calculateScore(patternCache) {\n    let score = 0;\n    let temp = 1;\n\n    patternCache.forEach((index, i) => {\n      if (i > 0) {\n        if (patternCache[i - 1] + 1 === index) {\n          temp += temp + 1;\n        } else {\n          temp = 1;\n        }\n      }\n\n      score += temp;\n    });\n\n    return score;\n  }\n\n  render(string, indices, pre, post) {\n    let rendered = string.substring(0, indices[0]);\n\n    indices.forEach((index, i) => {\n      rendered +=\n        pre +\n        string[index] +\n        post +\n        string.substring(\n          index + 1,\n          indices[i + 1] ? indices[i + 1] : string.length\n        );\n    });\n\n    return rendered;\n  }\n\n  filter(pattern, arr, opts) {\n    opts = opts || {};\n    return arr\n      .reduce((prev, element, idx, _arr) => {\n        let str = element;\n\n        if (opts.extract) {\n          str = opts.extract(element);\n\n          if (!str) {\n            // take care of undefineds / nulls / etc.\n            str = \"\";\n          }\n        }\n\n        const rendered = this.match(pattern, str, opts);\n\n        if (rendered !== null) {\n          prev[prev.length] = {\n            string: rendered.rendered,\n            score: rendered.score,\n            index: idx,\n            original: element,\n          };\n        }\n\n        return prev;\n      }, [])\n\n      .sort((a, b) => {\n        const compare = b.score - a.score;\n        if (compare) return compare;\n        return a.index - b.index;\n      });\n  }\n}\n\nexport default TributeSearch;\n","import TributeEvents from \"./TributeEvents\";\nimport TributeMenuEvents from \"./TributeMenuEvents\";\nimport TributeRange from \"./TributeRange\";\nimport TributeSearch from \"./TributeSearch\";\n\nclass Tribute {\n  constructor({\n    values = null,\n    loadingItemTemplate = null,\n    iframe = null,\n    selectClass = \"highlight\",\n    containerClass = \"tribute-container\",\n    itemClass = \"\",\n    trigger = \"@\",\n    autocompleteMode = false,\n    autocompleteSeparator = RegExp(/\\s+/),\n    selectTemplate = null,\n    menuItemTemplate = null,\n    lookup = \"key\",\n    fillAttr = \"value\",\n    collection = null,\n    menuContainer = null,\n    noMatchTemplate = null,\n    requireLeadingSpace = true,\n    allowSpaces = false,\n    replaceTextSuffix = null,\n    positionMenu = true,\n    spaceSelectsMatch = false,\n    searchOpts = {},\n    menuItemLimit = undefined,\n    menuShowMinLength = 0,\n    keys = null,\n    numberOfWordsInContextText = 5,\n    supportRevert = false,\n    selectByDigit = false,\n  }) {\n    this.autocompleteMode = autocompleteMode;\n    this.autocompleteSeparator = autocompleteSeparator;\n    this.menuSelected = 0;\n    this.current = {};\n    this.lastReplacement = null;\n    this.isActive = false;\n    this.activationPending = false;\n    this.menuContainer = menuContainer;\n    this.allowSpaces = allowSpaces;\n    this.replaceTextSuffix = replaceTextSuffix;\n    this.positionMenu = positionMenu;\n    this.spaceSelectsMatch = spaceSelectsMatch;\n    this.numberOfWordsInContextText = numberOfWordsInContextText;\n    this.supportRevert = supportRevert;\n    this.selectByDigit = selectByDigit;\n    if (keys) {\n      TributeEvents.keys = keys;\n    }\n\n    if (this.autocompleteMode) {\n      trigger = \"\";\n      allowSpaces = false;\n    }\n\n    if (values) {\n      this.collection = [\n        {\n          // symbol that starts the lookup\n          trigger: trigger,\n\n          // is it wrapped in an iframe\n          iframe: iframe,\n\n          // class applied to selected item\n          selectClass: selectClass,\n\n          // class applied to the Container\n          containerClass: containerClass,\n\n          // class applied to each item\n          itemClass: itemClass,\n\n          // function called on select that retuns the content to insert\n          selectTemplate: (\n            selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n\n          // function called that returns content for an item\n          menuItemTemplate: (\n            menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n\n          // column to search against in the object\n          lookup: lookup,\n\n          // column that contains the content to insert by default\n          fillAttr: fillAttr,\n\n          // array of objects or a function returning an array of objects\n          values: values,\n\n          // useful for when values is an async function\n          loadingItemTemplate: loadingItemTemplate,\n\n          requireLeadingSpace: requireLeadingSpace,\n\n          searchOpts: searchOpts,\n\n          menuItemLimit: menuItemLimit,\n\n          menuShowMinLength: menuShowMinLength,\n        },\n      ];\n    } else if (collection) {\n      if (this.autocompleteMode)\n        console.warn(\n          \"Tribute in autocomplete mode does not work for collections\"\n        );\n      this.collection = collection.map((item) => {\n        return {\n          trigger: item.trigger || trigger,\n          iframe: item.iframe || iframe,\n          selectClass: item.selectClass || selectClass,\n          containerClass: item.containerClass || containerClass,\n          itemClass: item.itemClass || itemClass,\n          selectTemplate: (\n            item.selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n          menuItemTemplate: (\n            item.menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n          lookup: item.lookup || lookup,\n          fillAttr: item.fillAttr || fillAttr,\n          values: item.values,\n          loadingItemTemplate: item.loadingItemTemplate,\n          requireLeadingSpace: item.requireLeadingSpace,\n          searchOpts: item.searchOpts || searchOpts,\n          menuItemLimit: item.menuItemLimit || menuItemLimit,\n          menuShowMinLength: item.menuShowMinLength || menuShowMinLength,\n        };\n      });\n    } else {\n      throw new Error(\"[Tribute] No collection specified.\");\n    }\n\n    new TributeRange(this);\n    new TributeEvents(this);\n    new TributeMenuEvents(this);\n    new TributeSearch(this);\n  }\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  set isActive(val) {\n    if (this._isActive !== val) {\n      this._isActive = val;\n      if (this.current.element) {\n        const noMatchEvent = new CustomEvent(`tribute-active-${val}`);\n        this.current.element.dispatchEvent(noMatchEvent);\n      }\n    }\n  }\n\n  static defaultSelectTemplate(item) {\n    if (typeof item === \"undefined\")\n      return `${this.current.collection.trigger}${this.current.mentionText}`;\n    if (this.range.isContentEditable(this.current.element)) {\n      return (\n        '<span class=\"tribute-mention\">' +\n        (this.current.collection.trigger +\n          item.original[this.current.collection.fillAttr]) +\n        \"</span>\"\n      );\n    }\n\n    return (\n      this.current.collection.trigger +\n      item.original[this.current.collection.fillAttr]\n    );\n  }\n\n  static defaultMenuItemTemplate(matchItem) {\n    return matchItem.string;\n  }\n\n  static inputTypes() {\n    return [\"TEXTAREA\", \"INPUT\"];\n  }\n\n  triggers() {\n    return this.collection.map((config) => {\n      return config.trigger;\n    });\n  }\n\n  attach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    /* global jQuery */\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._attach(el[i]);\n      }\n    } else {\n      this._attach(el);\n    }\n  }\n\n  _attach(el) {\n    if (el.hasAttribute(\"data-tribute\")) {\n      console.warn(\"Tribute was already bound to \" + el.nodeName);\n    }\n\n    this.ensureEditable(el);\n    this.events.bind(el);\n    el.setAttribute(\"data-tribute\", true);\n  }\n\n  ensureEditable(element) {\n    if (Tribute.inputTypes().indexOf(element.nodeName) === -1) {\n      if (element.contentEditable) {\n        element.contentEditable = true;\n      } else {\n        throw new Error(\"[Tribute] Cannot bind to \" + element.nodeName);\n      }\n    }\n  }\n\n  createMenu(containerClass, element) {\n    const properties = [\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSizeAdjust\",\n      \"fontFamily\",\n    ];\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n    const wrapper = this.range.getDocument().createElement(\"div\"),\n      ul = this.range.getDocument().createElement(\"ul\");\n    wrapper.className = containerClass;\n    wrapper.setAttribute(\"tabindex\", \"0\");\n    wrapper.appendChild(ul);\n    wrapper.style.fontSize =\n      Math.round(parseInt(computed.fontSize) * 0.9) + \"px\";\n    wrapper.style.display = \"none\";\n\n    properties.forEach((prop) => {\n      wrapper.style[prop] = computed[prop];\n    });\n\n    if (this.menuContainer) {\n      return this.menuContainer.appendChild(wrapper);\n    }\n\n    return this.range.getDocument().body.appendChild(wrapper);\n  }\n\n  showMenuFor(element, scrollTo) {\n    // Only proceed if menu isn't already shown for the current element & mentionText\n    if (\n      this.isActive &&\n      this.current.element === element &&\n      this.current.mentionText === this.currentMentionTextSnapshot\n    ) {\n      return;\n    }\n    this.currentMentionTextSnapshot = this.current.mentionText;\n\n    // create the menu if it doesn't exist.\n    if (!this.menu) {\n      this.menu = this.createMenu(\n        this.current.collection.containerClass,\n        element\n      );\n      element.tributeMenu = this.menu;\n      this.menuEvents.bind(this.menu);\n    }\n\n    this.activationPending = true;\n    this.menuSelected = 0;\n\n    if (!this.current.mentionText) {\n      this.current.mentionText = \"\";\n    }\n\n    const processValues = (values, forceReplace, header=null) => {\n      // Tribute may not be active any more by the time the value callback returns\n      if (!this.activationPending) {\n        return;\n      }\n      this.activationPending = false;\n      // Element is no longer in focus - don't show menu\n      if (this.range.getDocument().activeElement !== this.current.element) {\n        return;\n      }\n\n      if (forceReplace) {\n        // Do force replace - don't show menu\n        this.current.mentionPosition -= forceReplace.length;\n        this.current.mentionText = this.current.fullText.slice(-forceReplace.length);\n        this.replaceText(forceReplace.text, null, null);\n        return;\n      }\n\n      let items = this.search.filter(this.current.mentionText, values, {\n        pre: this.current.collection.searchOpts.pre || \"<span>\",\n        post: this.current.collection.searchOpts.post || \"</span>\",\n        skip: this.current.collection.searchOpts.skip || false,\n        caseSensitive:\n          this.current.collection.searchOpts.caseSensitive || false,\n        extract: (el) => {\n          if (typeof this.current.collection.lookup === \"string\") {\n            return el[this.current.collection.lookup];\n          } else if (typeof this.current.collection.lookup === \"function\") {\n            return this.current.collection.lookup(el, this.current.mentionText);\n          } else {\n            throw new Error(\n              \"Invalid lookup attribute, lookup must be string or function.\"\n            );\n          }\n        },\n      });\n\n      items = items.slice(0, this.current.collection.menuItemLimit);\n\n      this.current.filteredItems = items;\n\n      const ul = this.menu.querySelector(\"ul\");\n      let showMenu = false;\n\n      if (!items.length) {\n        const noMatchEvent = new CustomEvent(\"tribute-no-match\", {\n          detail: this.menu,\n        });\n        this.current.element.dispatchEvent(noMatchEvent);\n        if (\n          (typeof this.current.collection.noMatchTemplate === \"function\" &&\n            !this.current.collection.noMatchTemplate()) ||\n          !this.current.collection.noMatchTemplate\n        ) {\n          showMenu = false;\n        } else {\n          typeof this.current.collection.noMatchTemplate === \"function\"\n            ? (ul.innerHTML = this.current.collection.noMatchTemplate())\n            : (ul.innerHTML = this.current.collection.noMatchTemplate);\n          showMenu = true;\n        }\n      } else {\n        const fragment = this.range.getDocument().createDocumentFragment();\n        ul.innerHTML = \"\";\n        if (header) {\n          const lh = this.range.getDocument().createElement(\"lh\");\n          lh.innerHTML = header;\n          ul.appendChild(lh)\n        }\n\n        items.forEach((item, index) => {\n          const li = this.range.getDocument().createElement(\"li\");\n          li.setAttribute(\"data-index\", index);\n          li.className = this.current.collection.itemClass;\n          li.addEventListener(\n            \"mouseover\",\n            function (index) {\n              this.events.setActiveLi(index);\n            }.bind(this, index)\n          );\n\n          if (this.menuSelected === index) {\n            li.classList.add(this.current.collection.selectClass);\n          }\n          li.innerHTML = this.current.collection.menuItemTemplate(item);\n          if (this.selectByDigit) {\n            li.innerHTML = ( (index +1 ) % 10).toString() + '. ' + li.innerHTML;\n          }\n          fragment.appendChild(li);\n        });\n        ul.appendChild(fragment);\n        showMenu = true;\n      }\n      if (showMenu) {\n        this.isActive = true;\n        this.range.positionMenuAtCaret(scrollTo);\n      }\n    };\n\n    if (typeof this.current.collection.values === \"function\") {\n      if (this.current.collection.loadingItemTemplate) {\n        this.menu.querySelector(\"ul\").innerHTML =\n          this.current.collection.loadingItemTemplate;\n        this.range.positionMenuAtCaret(scrollTo);\n      }\n\n      this.current.collection.values(\n        this.current.mentionText,\n        processValues,\n        this.current.fullText,\n        this.current.nextChar\n      );\n    } else {\n      processValues(this.current.collection.values);\n    }\n  }\n\n  showMenuForCollection(element, collectionIndex) {\n    if (!this.events.updateSelection(element)) return;\n    if (element !== this.range.getDocument().activeElement) {\n      this.placeCaretAtEnd(element);\n      if (element.isContentEditable)\n        this.insertTextAtCursor(this.current.collection.trigger);\n      else this.insertAtCaret(element, this.current.collection.trigger);\n    }\n\n    this.current.collection = this.collection[collectionIndex || 0];\n    this.current.element = element;\n\n    this.showMenuFor(element);\n  }\n\n  // TODO: make sure this works for inputs/textareas\n  placeCaretAtEnd(el) {\n    el.focus();\n    if (\n      typeof window.getSelection !== \"undefined\" &&\n      typeof this.range.getDocument().createRange !== \"undefined\"\n    ) {\n      const range = this.range.getDocument().createRange();\n      range.selectNodeContents(el);\n      range.collapse(false);\n      const sel = window.getSelection();\n      sel.removeAllRanges();\n      sel.addRange(range);\n    } else if (\n      typeof this.range.getDocument().body.createTextRange !== \"undefined\"\n    ) {\n      const textRange = this.range.getDocument().body.createTextRange();\n      textRange.moveToElementText(el);\n      textRange.collapse(false);\n      textRange.select();\n    }\n  }\n\n  // for contenteditable\n  insertTextAtCursor(text) {\n    const sel = window.getSelection();\n    const range = sel.getRangeAt(0);\n    range.deleteContents();\n    const textNode = this.range.getDocument().createTextNode(text);\n    range.insertNode(textNode);\n    range.selectNodeContents(textNode);\n    range.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n\n  // for regular inputs\n  insertAtCaret(textarea, text) {\n    const scrollPos = textarea.scrollTop;\n    let caretPos = textarea.selectionStart;\n\n    const front = textarea.value.substring(0, caretPos);\n    const back = textarea.value.substring(\n      textarea.selectionEnd,\n      textarea.value.length\n    );\n    textarea.value = front + text + back;\n    caretPos = caretPos + text.length;\n    textarea.selectionStart = caretPos;\n    textarea.selectionEnd = caretPos;\n    textarea.focus();\n    textarea.scrollTop = scrollPos;\n  }\n\n  hideMenu() {\n    if (this.menu) {\n      this.menu.remove();\n      this.menu = null;\n    }\n    this.isActive = false;\n    this.activationPending = false;\n    this.current = {};\n  }\n\n  selectItemAtIndex(index, originalEvent) {\n    index = parseInt(index);\n    if (!(typeof index !== \"number\" || isNaN(index) || !originalEvent.target)) {\n      const item = this.current.filteredItems[index];\n      const content = this.current.collection.selectTemplate(item);\n      if (content !== null) this.replaceText(content, originalEvent, item);\n    }\n    this.hideMenu();\n  }\n\n  replaceText(content, originalEvent, item) {\n    if (this.supportRevert) {\n      this.lastReplacement = {...this.current};\n      this.lastReplacement.content = content;\n    }\n\n    this.range.replaceTriggerText(content, originalEvent, item);\n  }\n\n  _append(collection, newValues, replace) {\n    if (typeof collection.values === \"function\") {\n      throw new Error(\"Unable to append to values, as it is a function.\");\n    } else if (!replace) {\n      collection.values = collection.values.concat(newValues);\n    } else {\n      collection.values = newValues;\n    }\n  }\n\n  append(collectionIndex, newValues, replace) {\n    const index = parseInt(collectionIndex);\n    if (typeof index !== \"number\")\n      throw new Error(\"please provide an index for the collection to update.\");\n\n    const collection = this.collection[index];\n\n    this._append(collection, newValues, replace);\n  }\n\n  appendCurrent(newValues, replace) {\n    if (this.isActive) {\n      this._append(this.current.collection, newValues, replace);\n    } else {\n      throw new Error(\n        \"No active state. Please use append instead and pass an index.\"\n      );\n    }\n  }\n\n  detach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._detach(el[i]);\n      }\n    } else {\n      this._detach(el);\n    }\n  }\n\n  _detach(el) {\n    this.events.unbind(el);\n    if (el.tributeMenu) {\n      this.menuEvents.unbind(el.tributeMenu);\n    }\n\n    setTimeout(() => {\n      el.removeAttribute(\"data-tribute\");\n      this.isActive = false;\n      if (el.tributeMenu) {\n        el.tributeMenu.remove();\n      }\n    });\n  }\n\n  debounce(func, wait, option = { leading: true, trailing: true }) {\n    let timer = null;\n    return (...args) => {\n      const timerExpired = (callFunc) => {\n        timer = null;\n        if (callFunc) func.apply(this, args);\n      };\n      const callNow = option.leading && timer === null;\n      const timeoutFn = timerExpired.bind(this, !callNow && option.trailing);\n      clearTimeout(timer);\n      timer = setTimeout(timeoutFn, wait);\n      if (callNow) func.apply(this, args);\n    };\n  }\n}\n\nexport default Tribute;\n"],"names":["TributeEvents","constructor","tribute","this","events","keys","digits","modifiers","bind","element","boundKeyDown","debounce","keydown","boundKeyUpInput","input","addEventListener","unbind","removeEventListener","instance","event","controlKeyPressed","keyProcessed","KeyboardEvent","forEach","o","getModifierState","key","code","isActive","callbacks","selectByDigit","index","current","filteredItems","length","lastReplacement","hideMenu","cEvent","CustomEvent","iEvent","InputEvent","iEventHandle","inputType","startsWith","keyup","call","click","menu","contains","target","li","preventDefault","stopImmediatePropagation","nodeName","toLowerCase","parentNode","Error","selectItemAtIndex","getAttribute","updateSelection","keyCode","getKeyCode","isNaN","autocompleteMode","collection","trigger","triggers","find","charCodeAt","item","menuShowMinLength","mentionText","showMenuFor","which","data","mentionTriggerChar","NaN","el","info","range","getTriggerInfo","allowSpaces","mentionPosition","fullText","nextChar","Backspace","e","_el","content","replaceText","Digit","digit","setActiveLi","Enter","menuSelected","Escape","Tab","Space","spaceSelectsMatch","ArrowUp","count","selected","scrollTop","scrollHeight","ArrowDown","lis","querySelectorAll","i","classList","add","selectClass","liClientRect","getBoundingClientRect","menuClientRect","bottom","scrollDistance","top","remove","TributeMenuEvents","menuEvents","_menu","menuClickEvent","menuContainerScrollEvent","windowResizeEvent","windowBlurEvent","getDocument","window","menuContainer","TributeRange","iframe","contentWindow","document","positionMenuAtCaret","scrollTo","context","coordinates","positionMenu","isContentEditable","getContentEditableCaretPosition","getTextAreaOrInputUnderlinePosition","style","left","right","maxHeight","maxWidth","position","display","scrollIntoView","replaceTriggerText","text","originalEvent","detail","replaceEvent","sel","getContentEditableSelectionStart","staticRange","StaticRange","startContainer","anchorNode","startOffset","anchorOffset","endContainer","endOffset","replaceTextSuffix","dispatchEvent","bubbles","cancelable","targetRanges","pasteContentEditable","myField","textSuffix","stripHtml","startPos","endPos","value","substring","selectionStart","selectionEnd","html","numOfCharsToRemove","strippedText","nodeValue","pasteText","pasteHtml","pre","post","setStart","collapse","removeAllRanges","addRange","collapseToEnd","_range","modify","newRange","getRangeAt","deleteContents","createElement","innerHTML","frag","createDocumentFragment","node","lastNode","firstChild","appendChild","insertNode","setEnd","tmp","textContent","innerText","getWindowSelection","getSelection","rootNode","getRootNode","moveToEndOfWord","isCollapsed","direction","focusOffset","selectedElem","workingNodeContent","selectStartOffset","nextSibling","nextNodeText","nextCharIsSeparator","autocompleteSeparator","match","getWholeWordsUpToCharIndex","str","minLen","searchPos","arr","split","filter","trim","len","idx","indexOf","getTextForCurrentSelection","effectiveRange","toString","numberOfWordsInContextText","newText","endsWith","restoreSelection","textComponent","result","getLastWordInText","wordsArray","escapeRegExp","string","replace","isAutocomplete","requireLeadingSpace","lastWordOfEffectiveRange","triggerChar","mostRecentTriggerCharPos","config","c","regExpStr","searchRes","RegExp","test","currentTriggerSnippet","firstSnippetChar","leadingSpace","trailingSpace","trimEnd","isMenuOffScreen","menuDimensions","windowWidth","innerWidth","windowHeight","innerHeight","doc","documentElement","windowLeft","pageXOffset","scrollLeft","clientLeft","windowTop","pageYOffset","clientTop","menuTop","height","menuRight","width","menuBottom","menuLeft","Math","floor","ceil","getMenuDimensions","dimensions","visibility","offsetWidth","offsetHeight","_flipped","div","id","body","computed","getComputedStyle","currentStyle","whiteSpace","wordWrap","prop","span0","span","span2","rect","spanRect","divRect","removeChild","clamp","number","min","max","finalRect","getFixedCoordinatesRelativeToRect","_selectedNodePosition","parentNodeRect","availableSpaceOnTop","availableSpaceOnBottom","availableSpaceOnLeft","availableSpaceOnRight","_elem","clientRect","undefined","childNodes","elemTop","elemBottom","maxY","targetY","directionFwd","endRange","cloneRange","extend","TributeSearch","search","pattern","opts","compareString","caseSensitive","skip","rendered","score","patternCache","traverse","render","cache","stringIndex","patternIndex","splice","calculateScore","slice","best","temp","push","pop","indices","reduce","prev","_arr","extract","original","sort","a","b","compare","Tribute","values","loadingItemTemplate","containerClass","itemClass","selectTemplate","menuItemTemplate","lookup","fillAttr","noMatchTemplate","searchOpts","menuItemLimit","supportRevert","activationPending","defaultSelectTemplate","defaultMenuItemTemplate","t","console","warn","map","_isActive","val","noMatchEvent","matchItem","inputTypes","attach","jQuery","get","NodeList","HTMLCollection","Array","_attach","hasAttribute","ensureEditable","setAttribute","contentEditable","createMenu","wrapper","ul","className","fontSize","round","parseInt","currentMentionTextSnapshot","tributeMenu","processValues","forceReplace","header","activeElement","items","querySelector","showMenu","fragment","lh","showMenuForCollection","collectionIndex","placeCaretAtEnd","insertTextAtCursor","insertAtCaret","focus","createRange","selectNodeContents","createTextRange","textRange","moveToElementText","select","textNode","createTextNode","textarea","scrollPos","caretPos","front","back","_append","newValues","concat","append","appendCurrent","detach","_detach","setTimeout","removeAttribute","func","wait","option","leading","trailing","timer","args","callNow","timeoutFn","callFunc","apply","clearTimeout"],"mappings":"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"}