{"version":3,"file":"tribute.min.js","sources":["../src/TributeEvents.js","../src/TributeMenuEvents.js","../src/TributeRange.js","../src/TributeSearch.js","../src/Tribute.js"],"sourcesContent":["/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\nclass TributeEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.events = this;\n  }\n\n  static keys() {\n    return [\"Tab\", \"Enter\", \"Escape\", \"ArrowUp\", \"ArrowDown\", \"Backspace\"];\n  }\n\n  static digits() {\n    return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\"]\n  }\n\n  static modifiers() {\n    return [\n      \"CapsLock\",\n      \"Control\",\n      \"Fn\",\n      \"Hyper\",\n      \"Meta\",\n      \"OS\",\n      \"Super\",\n      \"Symbol\",\n      \"Win\",\n    ];\n  }\n\n  static isSpaceKey(event) {\n    return event.code === \"Space\" || event.key === \" \" || event.key === \"Spacebar\" || event.key === \"Space\";\n  }\n\n  static isTextInputKey(event) {\n    return TributeEvents.isSpaceKey(event) || (event.key && event.key.length === 1);\n  }\n\n  bind(element) {\n    const KEY_EVENT_TIMEOUT_MS = 32;\n    element.boundKeyDown = this.keydown.bind(element, this);\n    element.boundKeyUpInput = this.tribute.debounce(\n      this.input.bind(element, this),\n      this.tribute.inputDebounce || KEY_EVENT_TIMEOUT_MS\n    );\n\n    element.addEventListener(\"keydown\", element.boundKeyDown, true);\n    element.addEventListener(\"keyup\", element.boundKeyUpInput, true);\n    element.addEventListener(\"input\", element.boundKeyUpInput, true);\n  }\n\n  unbind(element) {\n    element.removeEventListener(\"keydown\", element.boundKeyDown, true);\n    element.removeEventListener(\"keyup\", element.boundKeyUpInput, true);\n    element.removeEventListener(\"input\", element.boundKeyUpInput, true);\n\n    delete element.boundKeyDown;\n    delete element.boundKeyUpInput;\n  }\n\n  keydown(instance, event) {\n    let controlKeyPressed = false;\n    let keyProcessed = false;\n    instance.tribute.lastKeydownEvent = {\n      key: event.key,\n      code: event.code,\n      keyCode: event.keyCode,\n      which: event.which,\n      handled: false,\n      defaultPrevented: false,\n    };\n\n    const isTab =\n      event.code === \"Tab\" || event.key === \"Tab\" || event.keyCode === 9;\n    const inlineElement =\n      instance.tribute.current.inlineSuggestion ||\n      instance.tribute.range\n        .getDocument()\n        .querySelector(\".tribute-inline\");\n    if (isTab && inlineElement) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      instance.tribute.current.inlineSuggestion = inlineElement;\n      instance.tribute.range.hideInlineSuggestion();\n      instance.tribute.current.element = this;\n      if (\n        !instance.tribute.current.mentionTriggerChar &&\n        instance.tribute.current.collection\n      ) {\n        instance.tribute.current.mentionTriggerChar =\n          instance.tribute.current.collection.trigger || \"\";\n      }\n      const item = instance.tribute.current.inlineSuggestionItem;\n      if (item) {\n        const content = instance.tribute.current.collection.selectTemplate(item);\n        if (content !== null) {\n          instance.tribute.replaceText(content, event, item);\n        }\n      }\n      instance.tribute.hideMenu();\n      instance.tribute.lastKeydownEvent.handled = true;\n      instance.tribute.lastKeydownEvent.defaultPrevented = event.defaultPrevented;\n      return;\n    }\n\n    if (event instanceof KeyboardEvent) {\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n    }\n\n    if (!controlKeyPressed) {\n      TributeEvents.keys().forEach((key) => {\n        if (\n          key === event.code &&\n          // Special handling of Backspace\n          (instance.tribute.isActive || event.code == \"Backspace\")) {\n          instance.callbacks()[key](event, this);\n          keyProcessed = true;\n          return;\n        }\n      });\n\n      if (instance.tribute.selectByDigit) {\n        TributeEvents.digits().forEach((key, index) => {\n          if (key === event.key && instance.tribute.isActive) {\n            const count = instance.tribute.current.filteredItems.length;\n            if (index < count) {\n              instance.callbacks()['Digit'](event, index, this);\n              keyProcessed = true;\n              return;\n            }\n          }\n        });\n      }\n    }\n\n    if (!keyProcessed) {\n      instance.tribute.lastReplacement = null;\n      instance.tribute.hideMenu();\n    }\n\n    instance.tribute.lastKeydownEvent.handled = keyProcessed;\n    instance.tribute.lastKeydownEvent.defaultPrevented = event.defaultPrevented;\n  }\n\n  input(instance, event) {\n    const cEvent = event instanceof CustomEvent;\n    const iEvent = event instanceof InputEvent;\n    const iEventHandle = iEvent && (event.inputType == \"insertText\"\n      || event.inputType == \"insertCompositionText\"\n      || event.inputType.startsWith(\"deleteContent\"));\n\n    if (cEvent) {\n      return;\n    }\n    if (iEvent && !iEventHandle) {\n      return;\n    }\n\n    instance.keyup.call(this, instance, event);\n  }\n\n  click(instance, event) {\n    const tribute = instance.tribute;\n    if (tribute.menu && tribute.menu.contains(event.target)) {\n      let li = event.target;\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      while (li.nodeName.toLowerCase() !== \"li\") {\n        if (li.nodeName.toLowerCase() === \"lh\") return;\n\n        li = li.parentNode;\n        if (!li || li === tribute.menu) {\n          throw new Error(\"cannot find the <li> container for the click\");\n        }\n      }\n\n      tribute.selectItemAtIndex(li.getAttribute(\"data-index\"), event);\n    } else {\n      tribute.hideMenu();\n    }\n  }\n\n  keyup(instance, event) {\n    // Check for modifiers keys\n    if (event instanceof KeyboardEvent) {\n      let controlKeyPressed = false;\n      TributeEvents.modifiers().forEach((o) => {\n        if (event.getModifierState(o)) {\n          controlKeyPressed = true;\n          return;\n        }\n      });\n      // Check for control keys\n      const lastKeydownEvent = instance.tribute.lastKeydownEvent;\n      const keydownHandled =\n        lastKeydownEvent &&\n        lastKeydownEvent.handled &&\n        (lastKeydownEvent.code === event.code ||\n          lastKeydownEvent.key === event.key ||\n          (event.keyCode && lastKeydownEvent.keyCode === event.keyCode) ||\n          (event.which && lastKeydownEvent.which === event.which));\n      const keydownPrevented =\n        keydownHandled &&\n        lastKeydownEvent.defaultPrevented;\n\n      TributeEvents.keys().forEach((key) => {\n        if (key === event.code || key === event.key) {\n          if (!instance.tribute.autocompleteMode) {\n            controlKeyPressed = true;\n            return;\n          }\n\n          if (keydownPrevented || !TributeEvents.isTextInputKey(event)) {\n            controlKeyPressed = true;\n          }\n          return;\n        }\n      });\n      if (controlKeyPressed) return;\n\n      if (!instance.tribute.autocompleteMode && event.key && event.key.length > 1) {\n        // Not a Character exit early\n        return;\n      }\n    }\n\n    if (!instance.updateSelection(this)) {\n      return;\n    }\n\n    if (!instance.tribute.autocompleteMode) {\n      const keyCode = instance.getKeyCode(event);\n      // Exit if no keyCode\n      if (isNaN(keyCode)) {\n        return;\n      }\n\n      const trigger = instance.tribute.triggers().find((trigger) => {\n        return trigger.charCodeAt(0) === keyCode;\n      });\n\n      if (instance.tribute.isActive) {\n        // already active, so just update\n      } else if (trigger) {\n        // not active, but we found a trigger\n        instance.tribute.current.collection = instance.tribute.collection.find((item) => {\n          return item.trigger === trigger;\n        });\n      } else {\n        // not active and not a trigger\n        return;\n      }\n    } else {\n      instance.tribute.current.collection = instance.tribute.collection[0];\n    }\n    const minLength = instance.tribute.current.collection.menuShowMinLength;\n    if (instance.tribute.current.mentionText.length < minLength) {\n      instance.tribute.hideMenu();\n      return;\n    }\n    instance.tribute.showMenuFor(this, true);\n  }\n\n  getKeyCode(event) {\n    const keyCode = event.keyCode || event.which || event.code;\n    if (keyCode) {\n      return keyCode;\n    }\n    if (event instanceof InputEvent && event.data) {\n      return event.data.charCodeAt(event.data.length - 1);\n    }\n    if (this.tribute.current.mentionTriggerChar) {\n      return this.tribute.current.mentionTriggerChar.charCodeAt(0);\n    }\n    if (this.tribute.current.mentionText) {\n      return this.tribute.current.mentionText.charCodeAt(\n        this.tribute.current.mentionText.length - 1);\n    }\n\n    return NaN;\n  }\n\n  updateSelection(el) {\n    this.tribute.current.element = el;\n    const info = this.tribute.range.getTriggerInfo(\n      this.tribute.allowSpaces,\n      this.tribute.autocompleteMode\n    );\n\n\n    if (info) {\n      this.tribute.current.mentionTriggerChar = info.mentionTriggerChar;\n      this.tribute.current.mentionText = info.mentionText;\n      this.tribute.current.mentionPosition = info.mentionPosition;\n      this.tribute.current.fullText = info.fullText;\n      this.tribute.current.nextChar = info.nextChar;\n      return true;\n    }\n\n    return false;\n  }\n\n  callbacks() {\n    return {\n      Backspace: (e, _el) => {\n        if (this.tribute.lastReplacement) {\n          if (this.tribute.events.updateSelection(_el) &&\n            (this.tribute.current.mentionPosition + this.tribute.current.mentionText.length) ==\n            (this.tribute.lastReplacement.mentionPosition + this.tribute.lastReplacement.content.length)) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            const addSpace = false;//this.tribute.lastReplacement.content !== this.tribute.lastReplacement.content.trimEnd();\n\n            this.tribute.current = { ...this.tribute.lastReplacement };\n            this.tribute.current.mentionText = this.tribute.lastReplacement.content;\n            this.tribute.replaceText(this.tribute.lastReplacement.mentionText + (addSpace ? \" \" : \"\"), e, null);\n          }\n          this.tribute.lastReplacement = null;\n          this.tribute.current = {};\n        }\n        this.tribute.hideMenu();\n      },\n      Digit: (e, digit, el) => {\n        this.setActiveLi(digit);\n        this.callbacks().Enter(e, el);\n      },\n      Enter: (e, _el) => {\n        // choose selection\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          this.tribute.selectItemAtIndex(this.tribute.menuSelected, e);\n        }\n      },\n      Escape: (e, _el) => {\n        if (this.tribute.isActive) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          this.tribute.hideMenu();\n        }\n      },\n      Tab: (e, el) => {\n        // choose first match\n        this.callbacks().Enter(e, el);\n      },\n      Space: (e, el) => {\n        if (this.tribute.isActive) {\n          if (this.tribute.spaceSelectsMatch) {\n            this.callbacks().Enter(e, el);\n          } else {\n            this.tribute.hideMenu();\n          }\n        }\n      },\n      ArrowUp: (e, _el) => {\n        // navigate up ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          const count = this.tribute.current.filteredItems.length,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected && selected > 0) {\n            this.setActiveLi(selected - 1);\n          } else if (selected === 0) {\n            this.setActiveLi(count - 1);\n            this.tribute.menu.scrollTop = this.tribute.menu.scrollHeight;\n          }\n        }\n      },\n      ArrowDown: (e, _el) => {\n        // navigate down ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          const count = this.tribute.current.filteredItems.length - 1,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected) {\n            this.setActiveLi(selected + 1);\n          } else if (count === selected) {\n            this.setActiveLi(0);\n            this.tribute.menu.scrollTop = 0;\n          }\n        }\n      },\n    };\n  }\n\n  setActiveLi(index) {\n    const lis = this.tribute.menu.querySelectorAll(\"li\"),\n      length = lis.length >>> 0;\n\n    this.tribute.menuSelected = index;\n\n    for (let i = 0; i < length; i++) {\n      const li = lis[i];\n      if (i === this.tribute.menuSelected) {\n        li.classList.add(this.tribute.current.collection.selectClass);\n\n        const liClientRect = li.getBoundingClientRect();\n        const menuClientRect = this.tribute.menu.getBoundingClientRect();\n\n        if (liClientRect.bottom > menuClientRect.bottom) {\n          const scrollDistance = liClientRect.bottom - menuClientRect.bottom;\n          this.tribute.menu.scrollTop += scrollDistance;\n        } else if (liClientRect.top < menuClientRect.top) {\n          const scrollDistance = menuClientRect.top - liClientRect.top;\n          this.tribute.menu.scrollTop -= scrollDistance;\n        }\n      } else {\n        li.classList.remove(this.tribute.current.collection.selectClass);\n      }\n    }\n  }\n}\n\nexport default TributeEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\nclass TributeMenuEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.menuEvents = this;\n    this.menu = this.tribute.menu;\n  }\n\n  bind(_menu) {\n    const DEBOUNCE_TIMEOUT_MS = 100;\n    this.menuClickEvent = this.tribute.events.click.bind(null, this);\n    this.menuContainerScrollEvent = this.tribute.debounce(() => {\n      this.tribute.hideMenu();\n    }, DEBOUNCE_TIMEOUT_MS);\n    this.windowResizeEvent = this.tribute.debounce(() => {\n      this.tribute.hideMenu();\n    }, DEBOUNCE_TIMEOUT_MS);\n\n    this.windowBlurEvent = () => {\n      this.tribute.hideMenu();\n    };\n\n    this.tribute.range\n      .getDocument()\n      .addEventListener(\"mousedown\", this.menuClickEvent, false);\n    window.addEventListener(\"resize\", this.windowResizeEvent);\n    window.addEventListener(\"blur\", this.windowBlurEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.addEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.addEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n\n  unbind(_menu) {\n    this.tribute.range\n      .getDocument()\n      .removeEventListener(\"mousedown\", this.menuClickEvent, false);\n    window.removeEventListener(\"resize\", this.windowResizeEvent);\n    window.removeEventListener(\"blur\", this.windowBlurEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.removeEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.removeEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n}\n\nexport default TributeMenuEvents;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/jeff-collins/ment.io\n\nclass TributeRange {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.range = this;\n  }\n\n  getDocument() {\n    let iframe;\n    if (this.tribute.current.collection) {\n      iframe = this.tribute.current.collection.iframe;\n    }\n\n    if (!iframe) {\n      return document;\n    }\n\n    return iframe.contentWindow.document;\n  }\n\n  positionMenuAtCaret(scrollTo) {\n    const context = this.tribute.current;\n    let coordinates;\n\n    if (!this.tribute.positionMenu) {\n      this.tribute.menu.style.display = `block`;\n      return;\n    }\n\n    if (!this.isContentEditable(context.element)) {\n      coordinates = this.getTextAreaOrInputUnderlinePosition(\n        context.element,\n        context.mentionPosition + context.mentionText.length\n      );\n    } else {\n      coordinates = this.getContentEditableCaretPosition(\n        context.mentionPosition + context.mentionText.length\n      );\n    }\n\n    this.tribute.menu.style.top = `${coordinates.top}px`;\n    this.tribute.menu.style.left = `${coordinates.left}px`;\n    this.tribute.menu.style.right = `${coordinates.right}px`;\n    this.tribute.menu.style.bottom = `${coordinates.bottom}px`;\n    this.tribute.menu.style[\"max-height\"] = `${coordinates.maxHeight || 500}px`;\n    this.tribute.menu.style[\"max-width\"] = `${coordinates.maxWidth || 300}px`;\n    this.tribute.menu.style.position = `${coordinates.position || \"absolute\"}`;\n    this.tribute.menu.style.display = `block`;\n\n    if (coordinates.left === \"auto\") {\n      this.tribute.menu.style.left = \"auto\";\n    }\n\n    if (coordinates.top === \"auto\") {\n      this.tribute.menu.style.top = \"auto\";\n    }\n\n    if (scrollTo) this.scrollIntoView();\n  }\n\n  showInlineSuggestion(text) {\n    const context = this.tribute.current;\n    this.hideInlineSuggestion();\n\n    const isContentEditable = this.isContentEditable(context.element);\n    const coordinates = isContentEditable\n      ? this.getContentEditableInlinePosition()\n      : this.getTextAreaOrInputUnderlinePosition(\n        context.element,\n        context.mentionPosition + context.mentionText.length\n      );\n    if (!coordinates) {\n      return;\n    }\n\n    let div = this.getDocument().createElement(\"div\");\n    div.className = \"tribute-inline\";\n    div.innerText = text;\n\n    // Calculate dynamic color and font styles\n    const targetElement = isContentEditable ? (this.getContentEditableTargetElement() || context.element) : context.element;\n    const computedStyle = getComputedStyle(targetElement);\n    div.style.color = computedStyle.color;\n    div.style.opacity = 0.5;\n\n    div.style.position = \"fixed\";\n    div.style.left = coordinates.left + \"px\";\n    const inlineTop =\n      typeof coordinates.height === \"number\"\n        ? coordinates.top - coordinates.height\n        : coordinates.top;\n    div.style.top = inlineTop + \"px\"; // Align with text baseline\n    div.style.pointerEvents = \"none\";\n    div.style.whiteSpace = \"pre-wrap\";\n    div.style.zIndex = 10000;\n\n    // Copy font styles precisely rather than relying on shorthand which Firefox can omit\n    div.style.font = computedStyle.font;\n    div.style.fontFamily = computedStyle.fontFamily;\n    div.style.fontSize = computedStyle.fontSize;\n    div.style.fontWeight = computedStyle.fontWeight;\n    div.style.fontStyle = computedStyle.fontStyle;\n    div.style.fontVariant = computedStyle.fontVariant;\n    div.style.letterSpacing = computedStyle.letterSpacing;\n    div.style.wordSpacing = computedStyle.wordSpacing;\n    div.style.textTransform = computedStyle.textTransform;\n    div.style.lineHeight = computedStyle.lineHeight;\n    div.style.direction = computedStyle.direction;\n\n    // Preserve font feature settings and rendering for subpixel matching\n    div.style.fontFeatureSettings = computedStyle.fontFeatureSettings;\n    div.style.fontKerning = computedStyle.fontKerning;\n    div.style.textAlign = computedStyle.textAlign;\n\n    // Preserve OS-level font smoothing (often causes mismatches if missing, especially on macOS)\n    div.style.WebkitFontSmoothing = computedStyle.WebkitFontSmoothing;\n    div.style.MozOsxFontSmoothing = computedStyle.MozOsxFontSmoothing;\n\n    if (coordinates.maxWidth) {\n      div.style.maxWidth = coordinates.maxWidth + \"px\";\n    }\n\n    this.getDocument().body.appendChild(div);\n    this.tribute.current.inlineSuggestion = div;\n  }\n\n  getContentEditableInlinePosition() {\n    const selection = this.getWindowSelection();\n    if (!selection || selection.rangeCount === 0) return null;\n\n    const originalRange = selection.getRangeAt(0).cloneRange();\n    let rect = originalRange.getBoundingClientRect();\n\n    if (!rect || rect.height === 0) {\n      const marker = this.getDocument().createTextNode(\"\\u200b\");\n      originalRange.insertNode(marker);\n      rect = marker.getBoundingClientRect();\n      if (marker.parentNode) {\n        marker.parentNode.removeChild(marker);\n      }\n      selection.removeAllRanges();\n      selection.addRange(originalRange);\n    }\n\n    if (!rect) return null;\n\n    const targetElement = this.getContentEditableTargetElement() || this.tribute.current.element;\n    const computedStyle = getComputedStyle(targetElement);\n    const fontSize = parseFloat(computedStyle.fontSize) || 0;\n    let lineHeight = parseFloat(computedStyle.lineHeight);\n    if (!lineHeight || Number.isNaN(lineHeight)) {\n      lineHeight = fontSize ? fontSize * 1.2 : 0;\n    }\n    const height = Math.max(rect.height || 0, lineHeight || 0);\n    const top = rect.top - Math.max(0, height - (rect.height || 0)) / 2;\n    const elementRect = this.tribute.current.element.getBoundingClientRect();\n    const maxWidth = Math.max(0, elementRect.right - rect.left);\n\n    return {\n      position: \"fixed\",\n      left: rect.left,\n      top: top + height,\n      height,\n      maxWidth,\n    };\n  }\n\n  getContentEditableTargetElement() {\n    const selection = this.getWindowSelection();\n    if (!selection || selection.rangeCount === 0) return null;\n    let node = selection.getRangeAt(0).startContainer;\n    if (node.nodeType === 3) {\n      node = node.parentNode;\n    }\n    return node;\n  }\n\n  hideInlineSuggestion() {\n    const inlineSuggestion = this.tribute.current.inlineSuggestion;\n    if (inlineSuggestion && inlineSuggestion.parentNode) {\n      inlineSuggestion.parentNode.removeChild(inlineSuggestion);\n    }\n    this.tribute.current.inlineSuggestion = null;\n    const leftovers = this.getDocument().querySelectorAll(\".tribute-inline\");\n    leftovers.forEach((node) => {\n      if (node.parentNode) node.parentNode.removeChild(node);\n    });\n  }\n\n  replaceTriggerText(text, originalEvent, item) {\n    const context = this.tribute.current;\n    this.hideInlineSuggestion();\n    const detail = {\n      item: item,\n      context: context,\n      event: originalEvent,\n      text: text,\n    };\n    const replaceEvent = new CustomEvent(\"tribute-replaced\", { detail: detail });\n\n    if (!this.isContentEditable(context.element)) {\n      const myField = this.tribute.current.element;\n      const textSuffix =\n        typeof this.tribute.replaceTextSuffix === \"string\"\n          ? this.tribute.replaceTextSuffix\n          : \" \";\n      text = this.stripHtml(text);\n      text += textSuffix;\n      const startPos = context.mentionPosition;\n      let endPos =\n        context.mentionPosition +\n        context.mentionText.length +\n        textSuffix.length;\n      if (!this.tribute.autocompleteMode && context.mentionTriggerChar.length) {\n        endPos += context.mentionTriggerChar.length - 1;\n      }\n      myField.value =\n        myField.value.substring(0, startPos) +\n        text +\n        myField.value.substring(endPos, myField.value.length);\n      myField.selectionStart = startPos + text.length;\n      myField.selectionEnd = startPos + text.length;\n    } else {\n      const {\n        sel,\n        range\n      } = this.getContentEditableSelectionStart(true);\n      const staticRange = new StaticRange({startContainer: sel.anchorNode, startOffset: sel.anchorOffset - context.mentionText.length, endContainer: sel.anchorNode, endOffset: sel.anchorOffset });\n      const textSuffix =\n        typeof this.tribute.replaceTextSuffix === \"string\"\n          ? this.tribute.replaceTextSuffix\n          : \"\\xA0\";\n      text += textSuffix;\n      context.element.dispatchEvent(new InputEvent(\"beforeinput\", {\n        bubbles: true,\n        data: text,\n        cancelable: true,\n        inputType: \"insertReplacementText\",\n        targetRanges: [staticRange],\n      }));\n      this.pasteContentEditable(\n        text,\n        context.mentionText.length + context.mentionTriggerChar.length\n      );\n    }\n\n    context.element.dispatchEvent(\n      new CustomEvent(\"input\", { bubbles: true, detail: detail })\n    );\n    context.element.dispatchEvent(replaceEvent);\n  }\n\n  pasteContentEditable(html, numOfCharsToRemove) {\n    const { sel, range } = this.getContentEditableSelectionStart(true);\n    if (sel && sel.anchorNode) {\n      const strippedText = this.stripHtml(html);\n      const isHTML = html !== strippedText;\n      const anchorNodeValue = sel.anchorNode.nodeValue || \"\";\n      const useSimpleReplace =\n        !isHTML &&\n        sel.anchorOffset >= numOfCharsToRemove &&\n        sel.anchorOffset <= anchorNodeValue.length;\n      if (useSimpleReplace) {\n        this.pasteText(sel, range, strippedText, numOfCharsToRemove);\n      } else {\n        this.pasteHtml(sel, range, html, numOfCharsToRemove);\n      }\n    }\n  }\n\n  pasteText(sel, range, text, numOfCharsToRemove) {\n    const pre = sel.anchorNode.nodeValue.substring(\n      0,\n      sel.anchorOffset - numOfCharsToRemove\n    );\n    const post = sel.anchorNode.nodeValue.substring(\n      sel.anchorOffset,\n      sel.anchorNode.nodeValue.length\n    );\n    sel.anchorNode.nodeValue = pre + text + post;\n    range.setStart(sel.anchorNode, pre.length + text.length);\n    range.collapse(true);\n    sel.removeAllRanges();\n    sel.addRange(range);\n    sel.collapseToEnd();\n  }\n\n  pasteHtml(sel, _range, html, numOfCharsToRemove) {\n    const range = sel.getRangeAt(0);\n    let newRange;\n    if (range.startContainer.nodeType === 3 && range.startOffset >= numOfCharsToRemove) {\n      range.setStart(range.startContainer, range.startOffset - numOfCharsToRemove);\n      range.deleteContents();\n      newRange = range;\n    } else {\n      for (let index = 0; index < numOfCharsToRemove; index++) {\n        sel.modify(\"extend\", \"backward\", \"character\");\n      }\n      newRange = sel.getRangeAt(0);\n      newRange.deleteContents();\n    }\n\n    const el = this.getDocument().createElement(\"div\");\n    el.innerHTML = html;\n    const frag = this.getDocument().createDocumentFragment();\n    let node, lastNode;\n\n    while ((node = el.firstChild)) {\n      lastNode = frag.appendChild(node);\n    }\n    newRange.insertNode(frag);\n\n    // Preserve the selection\n    if (lastNode) {\n      newRange.setStart(lastNode, lastNode.length);\n      newRange.setEnd(lastNode, lastNode.length);\n      newRange.collapse(true);\n      sel.removeAllRanges();\n      sel.addRange(newRange);\n      sel.collapseToEnd();\n    }\n  }\n\n  stripHtml(html) {\n    const tmp = this.getDocument().createElement(\"DIV\");\n    tmp.innerHTML = html;\n    return tmp.textContent || tmp.innerText || \"\";\n  }\n\n  getWindowSelection() {\n    if (this.tribute.collection.iframe) {\n      return this.tribute.collection.iframe.contentWindow.getSelection();\n    }\n\n    const rootNode = this.tribute.current.element.getRootNode();\n    if (rootNode.getSelection) return rootNode.getSelection();\n    else return window.getSelection();\n  }\n\n  getContentEditableSelectionStart(moveToEndOfWord) {\n    const sel = this.getWindowSelection();\n    if (!sel.isCollapsed) {\n      return { sel: null, range: null, direction: null };\n    }\n    const direction = sel.anchorOffset <= sel.focusOffset;\n    const range = sel.getRangeAt(0);\n    let selectedElem = sel.anchorNode;\n\n    if (selectedElem && selectedElem.nodeType !== 3) {\n      const childNodes = selectedElem.childNodes;\n      if (childNodes && childNodes.length) {\n        const fallbackIndex = Math.max(\n          0,\n          Math.min(range.startOffset - 1, childNodes.length - 1)\n        );\n        const textNode = childNodes[fallbackIndex];\n        if (textNode && textNode.nodeType === 3) {\n          range.setStart(textNode, textNode.textContent.length);\n          range.collapse(true);\n          sel.removeAllRanges();\n          sel.addRange(range);\n          selectedElem = textNode;\n        }\n      }\n    }\n\n    const workingNodeContent = selectedElem.textContent || \"\";\n    const selectStartOffset = range.startOffset;\n    let nextChar =\n      workingNodeContent.length > selectStartOffset\n        ? workingNodeContent[selectStartOffset]\n        : null;\n    if (nextChar === null) {\n      if (selectedElem.nextSibling && selectedElem.nextSibling.textContent) {\n        const nextNodeText = selectedElem.nextSibling.textContent;\n        nextChar = nextNodeText.length ? nextNodeText[0] : null;\n      }\n    }\n    const nextCharIsSeparator =\n      !this.tribute.autocompleteSeparator ||\n      (nextChar && nextChar.match(this.tribute.autocompleteSeparator));\n    sel.collapseToEnd();\n    if (nextChar && !nextCharIsSeparator && moveToEndOfWord)\n      sel.modify(\"move\", \"forward\", \"word\");\n\n    return { sel, range, direction };\n  }\n\n  getWholeWordsUpToCharIndex(str, minLen) {\n    if (this.tribute.autocompleteSeparator) {\n      let searchPos = 0;\n      const arr = str\n        .split(this.tribute.autocompleteSeparator)\n        .filter(function (e) {\n          return e.trim();\n        });\n\n      for (let i = 0, len = arr.length; i < len; i++) {\n        const idx = str.indexOf(arr[i], searchPos);\n        searchPos += arr[i].length;\n\n        if (minLen >= idx && minLen <= idx + arr[i].length) {\n          minLen = idx + arr[i].length;\n          break;\n        }\n      }\n    }\n\n    const nextChar = str.length > minLen ? str[minLen] : \"\";\n    return [str.substring(0, minLen), nextChar];\n  }\n\n  getTextForCurrentSelection() {\n    const context = this.tribute.current;\n    let effectiveRange = null;\n    let nextChar = \"\";\n\n    if (!this.isContentEditable(context.element)) {\n      const textComponent = this.tribute.current.element;\n      if (textComponent) {\n        const startPos = textComponent.selectionStart;\n        const endPos = textComponent.selectionEnd;\n\n        if (textComponent.value && startPos >= 0 && startPos === endPos) {\n          const result = this.getWholeWordsUpToCharIndex(\n            textComponent.value,\n            startPos\n          );\n          effectiveRange = result[0];\n          nextChar = result[1];\n        }\n      }\n    } else {\n      const { sel, range, direction } =\n        this.getContentEditableSelectionStart(true);\n      if (sel) {\n        const selectedElem = sel.anchorNode;\n        const workingNodeContent = selectedElem.textContent;\n        const selectStartOffset = sel.getRangeAt(0).startOffset;\n        effectiveRange = sel.toString().trim();\n        nextChar =\n          workingNodeContent.length > selectStartOffset\n            ? workingNodeContent[selectStartOffset]\n            : \"\";\n\n        for (\n          let index = 0;\n          index < this.tribute.numberOfWordsInContextText;\n          index++\n        ) {\n          sel.modify(\"extend\", \"backward\", \"word\");\n          const newText = sel.toString();\n\n          if (\n            newText.length > effectiveRange.length &&\n            newText.endsWith(effectiveRange)\n          ) {\n            // Workarounds Firefox issue, where selection sometimes collapse or move instead of extend\n            effectiveRange = newText;\n          }\n        }\n\n        this.restoreSelection(sel, range, direction);\n      }\n    }\n\n    return { effectiveRange, nextChar };\n  }\n\n  getLastWordInText(text) {\n    if (this.tribute.autocompleteSeparator) {\n      const wordsArray = text.split(this.tribute.autocompleteSeparator);\n      if (!wordsArray.length) return \" \";\n      return wordsArray[wordsArray.length - 1];\n    } else if (this.tribute.autocompleteMode) {\n      const wordsArray = text.split(/\\s+/);\n      return wordsArray.length ? wordsArray[wordsArray.length - 1] : \"\";\n    }\n    return text;\n  }\n\n  escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  }\n\n  getTriggerInfo(allowSpaces, isAutocomplete) {\n    let requireLeadingSpace = true;\n    const { effectiveRange, nextChar } = this.getTextForCurrentSelection();\n    if (effectiveRange === null) return null;\n    const lastWordOfEffectiveRange = this.getLastWordInText(effectiveRange);\n\n    if (isAutocomplete) {\n      return {\n        mentionPosition:\n          effectiveRange.length - lastWordOfEffectiveRange.length,\n        mentionText: lastWordOfEffectiveRange,\n        fullText: effectiveRange,\n        nextChar: nextChar,\n        mentionTriggerChar: \"\",\n      };\n    }\n\n    if (effectiveRange !== undefined && effectiveRange !== null) {\n      let mostRecentTriggerCharPos = -1;\n      let triggerChar;\n\n      this.tribute.collection.forEach((config) => {\n        const c = config.trigger;\n        const regExpStr =\n          \"(\" +\n          (config.requireLeadingSpace ? \"\\\\s\" : \"\") +\n          this.escapeRegExp(c) +\n          \")(?!.*\\\\1)\";\n        const searchRes = effectiveRange.match(RegExp(regExpStr));\n        const idx = (() => {\n          if (searchRes)\n            return searchRes.index + (config.requireLeadingSpace ? 1 : 0);\n          if (effectiveRange.startsWith(c)) return 0;\n          return -1;\n        })();\n\n        if (idx > mostRecentTriggerCharPos) {\n          mostRecentTriggerCharPos = idx;\n          triggerChar = c;\n          requireLeadingSpace = config.requireLeadingSpace;\n        }\n      });\n\n      if (\n        mostRecentTriggerCharPos >= 0 &&\n        (mostRecentTriggerCharPos === 0 ||\n          !requireLeadingSpace ||\n          /\\s/.test(\n            effectiveRange.substring(\n              mostRecentTriggerCharPos - 1,\n              mostRecentTriggerCharPos\n            )\n          ))\n      ) {\n        const currentTriggerSnippet = effectiveRange.substring(\n          mostRecentTriggerCharPos + triggerChar.length,\n          effectiveRange.length\n        );\n\n        triggerChar = effectiveRange.substring(\n          mostRecentTriggerCharPos,\n          mostRecentTriggerCharPos + triggerChar.length\n        );\n        const firstSnippetChar = currentTriggerSnippet.substring(0, 1);\n        const leadingSpace =\n          currentTriggerSnippet.length > 0 &&\n          (firstSnippetChar === \" \" || firstSnippetChar === \"\\xA0\");\n\n        const trailingSpace =\n          currentTriggerSnippet !== currentTriggerSnippet.trimEnd();\n\n        if (!leadingSpace && (allowSpaces || !trailingSpace)) {\n          return {\n            mentionPosition: mostRecentTriggerCharPos,\n            mentionText: currentTriggerSnippet,\n            mentionTriggerChar: triggerChar,\n            fullText: effectiveRange,\n            nextChar: \"\",\n          };\n        }\n      }\n    }\n  }\n\n  isContentEditable(element) {\n    return element.nodeName !== \"INPUT\" && element.nodeName !== \"TEXTAREA\";\n  }\n\n  isMenuOffScreen(coordinates, menuDimensions) {\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    const doc = this.getDocument().documentElement;\n    const windowLeft =\n      (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n    const windowTop =\n      (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n\n    const menuTop =\n      typeof coordinates.top === \"number\"\n        ? coordinates.top\n        : coordinates.bottom - menuDimensions.height;\n    const menuRight =\n      typeof coordinates.right === \"number\"\n        ? coordinates.right\n        : coordinates.left + menuDimensions.width;\n    const menuBottom =\n      typeof coordinates.bottom === \"number\"\n        ? coordinates.bottom\n        : coordinates.top + menuDimensions.height;\n    const menuLeft =\n      typeof coordinates.left === \"number\"\n        ? coordinates.left\n        : coordinates.right - menuDimensions.width;\n\n    return {\n      top: menuTop < Math.floor(windowTop),\n      right: menuRight > Math.ceil(windowLeft + windowWidth),\n      bottom: menuBottom > Math.ceil(windowTop + windowHeight),\n      left: menuLeft < Math.floor(windowLeft),\n    };\n  }\n\n  getMenuDimensions() {\n    // Width of the menu depends of its contents and position\n    // We must check what its width would be without any obstruction\n    // This way, we can achieve good positioning for flipping the menu\n    const dimensions = {\n      width: null,\n      height: null,\n    };\n\n    this.tribute.menu.style.top = `0px`;\n    this.tribute.menu.style.left = `0px`;\n    this.tribute.menu.style.right = null;\n    this.tribute.menu.style.bottom = null;\n    this.tribute.menu.style.position = `fixed`;\n    this.tribute.menu.style.visibility = `hidden`;\n    this.tribute.menu.style.display = `block`;\n\n    dimensions.width = this.tribute.menu.offsetWidth;\n    dimensions.height = this.tribute.menu.offsetHeight;\n\n    this.tribute.menu.style.display = `none`;\n    this.tribute.menu.style.visibility = `visible`;\n\n    return dimensions;\n  }\n\n  getTextAreaOrInputUnderlinePosition(element, position, _flipped) {\n    const properties = [\n      \"direction\",\n      \"boxSizing\",\n      \"width\",\n      \"height\",\n      \"overflowX\",\n      \"overflowY\",\n      \"borderTopWidth\",\n      \"borderRightWidth\",\n      \"borderBottomWidth\",\n      \"borderLeftWidth\",\n      \"borderStyle\",\n      \"paddingTop\",\n      \"paddingRight\",\n      \"paddingBottom\",\n      \"paddingLeft\",\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSize\",\n      \"fontSizeAdjust\",\n      \"lineHeight\",\n      \"fontFamily\",\n      \"textAlign\",\n      \"textTransform\",\n      \"textIndent\",\n      \"textDecoration\",\n      \"letterSpacing\",\n      \"wordSpacing\",\n    ];\n\n    const div = this.getDocument().createElement(\"div\");\n    div.id = \"input-textarea-caret-position-mirror-div\";\n    this.getDocument().body.appendChild(div);\n\n    const style = div.style;\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n\n    style.whiteSpace = \"pre-wrap\";\n    if (element.nodeName !== \"INPUT\") {\n      style.wordWrap = \"break-word\";\n    }\n\n    // position off-screen\n    style.position = \"absolute\";\n    style.visibility = \"hidden\";\n\n    // transfer the element's properties to the div\n    properties.forEach((prop) => {\n      style[prop] = computed[prop];\n    });\n\n    const span0 = this.getDocument().createElement(\"span\");\n    span0.textContent = element.value.substring(0, position);\n    div.appendChild(span0);\n\n    if (element.nodeName === \"INPUT\") {\n      div.textContent = div.textContent.replace(/\\s/g, \"Â \");\n    }\n\n    //Create a span in the div that represents where the cursor\n    //should be\n    const span = this.getDocument().createElement(\"span\");\n    //we give it no content as this represents the cursor\n    div.appendChild(span);\n\n    const span2 = this.getDocument().createElement(\"span\");\n    span2.textContent = element.value.substring(position, position + 1);\n    div.appendChild(span2);\n\n    const rect = element.getBoundingClientRect();\n\n    //position the div exactly over the element\n    //so we can get the bounding client rect for the span and\n    //it should represent exactly where the cursor is\n    div.style.position = \"fixed\";\n    div.style.left = rect.left + \"px\";\n    div.style.top = rect.top + \"px\";\n    div.style.width = rect.width + \"px\";\n    div.style.height = rect.height + \"px\";\n    div.scrollTop = element.scrollTop;\n\n    const spanRect = span.getBoundingClientRect();\n    const span2Rect = span2.getBoundingClientRect();\n    const divRect = div.getBoundingClientRect();\n    const fontSize = parseFloat(computed.fontSize) || 0;\n    let lineHeight = parseFloat(computed.lineHeight);\n    if (!lineHeight || Number.isNaN(lineHeight)) {\n      lineHeight = fontSize ? fontSize * 1.2 : 0;\n    }\n    const fallbackHeight = lineHeight || fontSize || divRect.height;\n    const glyphRect =\n      span2.textContent && span2Rect.height ? span2Rect : spanRect;\n    const glyphHeight = glyphRect.height || fallbackHeight;\n    const lineBoxHeight = Math.max(glyphHeight, fallbackHeight);\n    const extraLeading = Math.max(0, lineBoxHeight - glyphHeight);\n    const lineBoxTop = glyphRect.top - extraLeading / 2;\n    this.getDocument().body.removeChild(div);\n    const clamp = function (number, min, max) {\n      return Math.max(min, Math.min(number, max));\n    };\n    const finalRect = {\n      height: Math.min(divRect.height, lineBoxHeight),\n      left: clamp(spanRect.left, divRect.left, divRect.left + divRect.width),\n      top: clamp(lineBoxTop, divRect.top, divRect.top + divRect.height),\n    };\n    return this.getFixedCoordinatesRelativeToRect(finalRect);\n  }\n\n  getContentEditableCaretPosition(_selectedNodePosition) {\n    const { sel, range, direction } =\n      this.getContentEditableSelectionStart(false);\n    const newRange = sel.getRangeAt(0);\n    // restore selection\n    this.restoreSelection(sel, range, direction);\n    let rect = newRange.getBoundingClientRect();\n    if (sel.anchorNode.parentNode) {\n      const parentNodeRect = sel.anchorNode.parentNode.getBoundingClientRect();\n      const clamp = function (number, min, max) {\n        return Math.max(min, Math.min(number, max));\n      };\n      rect = {\n        height: Math.min(parentNodeRect.height, rect.height),\n        left: clamp(\n          rect.left,\n          parentNodeRect.left,\n          parentNodeRect.left + parentNodeRect.width\n        ),\n        top: clamp(\n          rect.top,\n          parentNodeRect.top,\n          parentNodeRect.top + parentNodeRect.height\n        ),\n      };\n    }\n    return this.getFixedCoordinatesRelativeToRect(rect);\n  }\n\n\n  getFixedCoordinatesRelativeToRect(rect) {\n    const coordinates = {\n      position: \"fixed\",\n      left: rect.left,\n      top: rect.top + rect.height,\n      height: rect.height,\n      width: rect.width,\n    };\n\n    const menuDimensions = this.getMenuDimensions();\n\n    const availableSpaceOnTop = rect.top;\n    const availableSpaceOnBottom =\n      window.innerHeight - (rect.top + rect.height);\n\n    //check to see where's the right place to put the menu vertically\n    if (availableSpaceOnBottom < menuDimensions.height) {\n      if (\n        availableSpaceOnTop >= menuDimensions.height ||\n        availableSpaceOnTop > availableSpaceOnBottom\n      ) {\n        coordinates.top = \"auto\";\n        coordinates.bottom = window.innerHeight - rect.top;\n        if (availableSpaceOnBottom < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnTop;\n        }\n      } else {\n        if (availableSpaceOnTop < menuDimensions.height) {\n          coordinates.maxHeight = availableSpaceOnBottom;\n        }\n      }\n    }\n\n    const availableSpaceOnLeft = rect.left;\n    const availableSpaceOnRight = window.innerWidth - rect.left;\n\n    //check to see where's the right place to put the menu horizontally\n    if (availableSpaceOnRight < menuDimensions.width) {\n      if (\n        availableSpaceOnLeft >= menuDimensions.width ||\n        availableSpaceOnLeft > availableSpaceOnRight\n      ) {\n        coordinates.left = \"auto\";\n        coordinates.right = window.innerWidth - rect.left;\n        if (availableSpaceOnRight < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnLeft;\n        }\n      } else {\n        if (availableSpaceOnLeft < menuDimensions.width) {\n          coordinates.maxWidth = availableSpaceOnRight;\n        }\n      }\n    }\n\n    return coordinates;\n  }\n\n  scrollIntoView(_elem) {\n    const reasonableBuffer = 20;\n    const maxScrollDisplacement = 100;\n    let clientRect;\n    let e = this.menu;\n\n    if (typeof e === \"undefined\") return;\n\n    while (clientRect === undefined || clientRect.height === 0) {\n      clientRect = e.getBoundingClientRect();\n\n      if (clientRect.height === 0) {\n        e = e.childNodes[0];\n        if (e === undefined || !e.getBoundingClientRect) {\n          return;\n        }\n      }\n    }\n\n    const elemTop = clientRect.top;\n    const elemBottom = elemTop + clientRect.height;\n\n    if (elemTop < 0) {\n      window.scrollTo(\n        0,\n        window.pageYOffset + clientRect.top - reasonableBuffer\n      );\n    } else if (elemBottom > window.innerHeight) {\n      let maxY = window.pageYOffset + clientRect.top - reasonableBuffer;\n\n      if (maxY - window.pageYOffset > maxScrollDisplacement) {\n        maxY = window.pageYOffset + maxScrollDisplacement;\n      }\n\n      let targetY = window.pageYOffset - (window.innerHeight - elemBottom);\n\n      if (targetY > maxY) {\n        targetY = maxY;\n      }\n\n      window.scrollTo(0, targetY);\n    }\n  }\n\n  restoreSelection(sel, range, directionFwd = true) {\n    sel.removeAllRanges();\n\n    if (directionFwd) {\n      sel.addRange(range);\n    } else {\n      const endRange = range.cloneRange();\n      endRange.collapse(false);\n      sel.addRange(endRange);\n      sel.extend(range.startContainer, range.startOffset);\n    }\n  }\n}\n\nexport default TributeRange;\n","/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\n// Thanks to https://github.com/mattyork/fuzzy\nclass TributeSearch {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.search = this;\n  }\n\n  match(pattern, string, opts) {\n    opts = opts || {};\n    const pre = opts.pre || \"\",\n      post = opts.post || \"\",\n      compareString = (opts.caseSensitive && string) || string.toLowerCase();\n\n    if (opts.skip) {\n      return { rendered: string, score: 0 };\n    }\n\n    pattern = (opts.caseSensitive && pattern) || pattern.toLowerCase();\n\n    const patternCache = this.traverse(compareString, pattern, 0, 0, []);\n    if (!patternCache) {\n      return null;\n    }\n    return {\n      rendered: this.render(string, patternCache.cache, pre, post),\n      score: patternCache.score,\n    };\n  }\n\n  traverse(string, pattern, stringIndex, patternIndex, patternCache) {\n    if (this.tribute.autocompleteMode && this.tribute.autocompleteSeparator) {\n      // if the pattern search at end\n      pattern = pattern.split(this.tribute.autocompleteSeparator).splice(-1)[0];\n    }\n\n    if (pattern.length === patternIndex) {\n      // calculate score and copy the cache containing the indices where it's found\n      return {\n        score: this.calculateScore(patternCache),\n        cache: patternCache.slice(),\n      };\n    }\n\n    // if string at end or remaining pattern > remaining string\n    if (\n      string.length === stringIndex ||\n      pattern.length - patternIndex > string.length - stringIndex\n    ) {\n      return undefined;\n    }\n\n    const c = pattern[patternIndex];\n    let index = string.indexOf(c, stringIndex);\n    let best;\n    let temp;\n\n    while (index > -1) {\n      patternCache.push(index);\n      temp = this.traverse(\n        string,\n        pattern,\n        index + 1,\n        patternIndex + 1,\n        patternCache\n      );\n      patternCache.pop();\n\n      // if downstream traversal failed, return best answer so far\n      if (!temp) {\n        return best;\n      }\n\n      if (!best || best.score < temp.score) {\n        best = temp;\n      }\n\n      index = string.indexOf(c, index + 1);\n    }\n\n    return best;\n  }\n\n  calculateScore(patternCache) {\n    let score = 0;\n    let temp = 1;\n\n    patternCache.forEach((index, i) => {\n      if (i > 0) {\n        if (patternCache[i - 1] + 1 === index) {\n          temp += temp + 1;\n        } else {\n          temp = 1;\n        }\n      }\n\n      score += temp;\n    });\n\n    return score;\n  }\n\n  render(string, indices, pre, post) {\n    let rendered = string.substring(0, indices[0]);\n\n    indices.forEach((index, i) => {\n      rendered +=\n        pre +\n        string[index] +\n        post +\n        string.substring(\n          index + 1,\n          indices[i + 1] ? indices[i + 1] : string.length\n        );\n    });\n\n    return rendered;\n  }\n\n  filter(pattern, arr, opts) {\n    opts = opts || {};\n    return arr\n      .reduce((prev, element, idx, _arr) => {\n        let str = element;\n\n        if (opts.extract) {\n          str = opts.extract(element);\n\n          if (!str) {\n            // take care of undefineds / nulls / etc.\n            str = \"\";\n          }\n        }\n\n        const rendered = this.match(pattern, str, opts);\n\n        if (rendered !== null) {\n          prev[prev.length] = {\n            string: rendered.rendered,\n            score: rendered.score,\n            index: idx,\n            original: element,\n          };\n        }\n\n        return prev;\n      }, [])\n\n      .sort((a, b) => {\n        const compare = b.score - a.score;\n        if (compare) return compare;\n        return a.index - b.index;\n      });\n  }\n}\n\nexport default TributeSearch;\n","import TributeEvents from \"./TributeEvents\";\nimport TributeMenuEvents from \"./TributeMenuEvents\";\nimport TributeRange from \"./TributeRange\";\nimport TributeSearch from \"./TributeSearch\";\n\nclass Tribute {\n  constructor({\n    values = null,\n    loadingItemTemplate = null,\n    iframe = null,\n    selectClass = \"highlight\",\n    containerClass = \"tribute-container\",\n    itemClass = \"\",\n    trigger = \"@\",\n    autocompleteMode = false,\n    autocompleteSeparator = RegExp(/\\s+/),\n    selectTemplate = null,\n    menuItemTemplate = null,\n    lookup = \"key\",\n    fillAttr = \"value\",\n    collection = null,\n    menuContainer = null,\n    noMatchTemplate = null,\n    requireLeadingSpace = true,\n    allowSpaces = false,\n    replaceTextSuffix = null,\n    positionMenu = true,\n    spaceSelectsMatch = false,\n    searchOpts = {},\n    menuItemLimit = undefined,\n    menuShowMinLength = 0,\n    keys = null,\n    numberOfWordsInContextText = 5,\n    supportRevert = false,\n    selectByDigit = false,\n    inline = false,\n  }) {\n    this.autocompleteMode = autocompleteMode;\n    this.autocompleteSeparator = autocompleteSeparator;\n    this.menuSelected = 0;\n    this.current = {};\n    this.lastReplacement = null;\n    this.isActive = false;\n    this.activationPending = false;\n    this.menuContainer = menuContainer;\n    this.allowSpaces = allowSpaces;\n    this.replaceTextSuffix = replaceTextSuffix;\n    this.positionMenu = positionMenu;\n    this.spaceSelectsMatch = spaceSelectsMatch;\n    this.numberOfWordsInContextText = numberOfWordsInContextText;\n    this.supportRevert = supportRevert;\n    this.selectByDigit = selectByDigit;\n    this.inline = inline;\n    if (keys) {\n      TributeEvents.keys = keys;\n    }\n\n    if (this.autocompleteMode) {\n      trigger = \"\";\n      allowSpaces = false;\n    }\n\n    if (values) {\n      this.collection = [\n        {\n          // symbol that starts the lookup\n          trigger: trigger,\n\n          // is it wrapped in an iframe\n          iframe: iframe,\n\n          // class applied to selected item\n          selectClass: selectClass,\n\n          // class applied to the Container\n          containerClass: containerClass,\n\n          // class applied to each item\n          itemClass: itemClass,\n\n          // function called on select that retuns the content to insert\n          selectTemplate: (\n            selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n\n          // function called that returns content for an item\n          menuItemTemplate: (\n            menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n\n          // column to search against in the object\n          lookup: lookup,\n\n          // column that contains the content to insert by default\n          fillAttr: fillAttr,\n\n          // array of objects or a function returning an array of objects\n          values: values,\n\n          // useful for when values is an async function\n          loadingItemTemplate: loadingItemTemplate,\n\n          requireLeadingSpace: requireLeadingSpace,\n\n          searchOpts: searchOpts,\n\n          menuItemLimit: menuItemLimit,\n\n          menuShowMinLength: menuShowMinLength,\n          inline: inline,\n        },\n      ];\n    } else if (collection) {\n      if (this.autocompleteMode)\n        console.warn(\n          \"Tribute in autocomplete mode does not work for collections\"\n        );\n      this.collection = collection.map((item) => {\n        return {\n          trigger: item.trigger || trigger,\n          iframe: item.iframe || iframe,\n          selectClass: item.selectClass || selectClass,\n          containerClass: item.containerClass || containerClass,\n          itemClass: item.itemClass || itemClass,\n          selectTemplate: (\n            item.selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n          menuItemTemplate: (\n            item.menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: ((t) => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function () {\n                return \"<li>No Match Found!</li>\";\n              }\n            );\n          })(noMatchTemplate),\n          lookup: item.lookup || lookup,\n          fillAttr: item.fillAttr || fillAttr,\n          values: item.values,\n          loadingItemTemplate: item.loadingItemTemplate,\n          requireLeadingSpace: item.requireLeadingSpace,\n          searchOpts: item.searchOpts || searchOpts,\n          menuItemLimit: item.menuItemLimit || menuItemLimit,\n          menuShowMinLength: item.menuShowMinLength || menuShowMinLength,\n          inline: item.inline !== undefined ? item.inline : inline,\n        };\n      });\n    } else {\n      throw new Error(\"[Tribute] No collection specified.\");\n    }\n\n    new TributeRange(this);\n    new TributeEvents(this);\n    new TributeMenuEvents(this);\n    new TributeSearch(this);\n  }\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  set isActive(val) {\n    if (this._isActive !== val) {\n      this._isActive = val;\n      if (this.current && this.current.element) {\n        const activeEvent = new CustomEvent(`tribute-active-${val}`);\n        this.current.element.dispatchEvent(activeEvent);\n      }\n    }\n  }\n\n  static defaultSelectTemplate(item) {\n    if (typeof item === \"undefined\")\n      return `${this.current.collection.trigger}${this.current.mentionText}`;\n    if (this.range.isContentEditable(this.current.element)) {\n      return (\n        '<span class=\"tribute-mention\">' +\n        (this.current.collection.trigger +\n          item.original[this.current.collection.fillAttr]) +\n        \"</span>\"\n      );\n    }\n\n    return (\n      this.current.collection.trigger +\n      item.original[this.current.collection.fillAttr]\n    );\n  }\n\n  static defaultMenuItemTemplate(matchItem) {\n    return matchItem.string;\n  }\n\n  static inputTypes() {\n    return [\"TEXTAREA\", \"INPUT\"];\n  }\n\n  triggers() {\n    return this.collection.map((config) => {\n      return config.trigger;\n    });\n  }\n\n  attach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    /* global jQuery */\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._attach(el[i]);\n      }\n    } else {\n      this._attach(el);\n    }\n  }\n\n  _attach(el) {\n    if (el.hasAttribute(\"data-tribute\")) {\n      console.warn(\"Tribute was already bound to \" + el.nodeName);\n    }\n\n    this.ensureEditable(el);\n    this.events.bind(el);\n    el.setAttribute(\"data-tribute\", true);\n  }\n\n  ensureEditable(element) {\n    if (Tribute.inputTypes().indexOf(element.nodeName) === -1) {\n      if (element.contentEditable) {\n        element.contentEditable = true;\n      } else {\n        throw new Error(\"[Tribute] Cannot bind to \" + element.nodeName);\n      }\n    }\n  }\n\n  createMenu(containerClass, element) {\n    const properties = [\n      \"fontStyle\",\n      \"fontVariant\",\n      \"fontWeight\",\n      \"fontStretch\",\n      \"fontSizeAdjust\",\n      \"fontFamily\",\n    ];\n    const computed = window.getComputedStyle\n      ? getComputedStyle(element)\n      : element.currentStyle;\n    const wrapper = this.range.getDocument().createElement(\"div\"),\n      ul = this.range.getDocument().createElement(\"ul\");\n    wrapper.className = containerClass;\n    wrapper.setAttribute(\"tabindex\", \"0\");\n    wrapper.appendChild(ul);\n    wrapper.style.fontSize =\n      Math.round(parseInt(computed.fontSize) * 0.9) + \"px\";\n    wrapper.style.display = \"none\";\n\n    properties.forEach((prop) => {\n      wrapper.style[prop] = computed[prop];\n    });\n\n    if (this.menuContainer) {\n      return this.menuContainer.appendChild(wrapper);\n    }\n\n    return this.range.getDocument().body.appendChild(wrapper);\n  }\n\n  showMenuFor(element, scrollTo) {\n    if (\n      this.isActive &&\n      this.current.element === element &&\n      this.current.mentionText === this.currentMentionTextSnapshot\n    ) {\n      return;\n    }\n    this.current.element = element;\n    this.currentMentionTextSnapshot = this.current.mentionText;\n\n    // create the menu if it doesn't exist.\n    if (!this.menu) {\n      this.menu = this.createMenu(\n        this.current.collection.containerClass,\n        element\n      );\n      element.tributeMenu = this.menu;\n      this.menuEvents.bind(this.menu);\n    }\n\n    this.activationPending = true;\n    this.menuSelected = 0;\n\n    if (!this.current.mentionText) {\n      this.current.mentionText = \"\";\n    }\n\n    const processValues = (values, forceReplace, header = null) => {\n      // Tribute may not be active any more by the time the value callback returns\n      if (!this.activationPending) {\n        return;\n      }\n      this.activationPending = false;\n      // Element is no longer in focus - don't show menu\n      if (this.range.getDocument().activeElement !== this.current.element) {\n        return;\n      }\n\n      if (forceReplace) {\n        // Do force replace - don't show menu\n        this.current.mentionPosition -= forceReplace.length;\n        this.current.mentionText = this.current.fullText.slice(-forceReplace.length);\n        this.replaceText(forceReplace.text, null, null);\n        return;\n      }\n\n      let items = this.search.filter(this.current.mentionText, values, {\n        pre: this.current.collection.searchOpts.pre || \"<span>\",\n        post: this.current.collection.searchOpts.post || \"</span>\",\n        skip: this.current.collection.searchOpts.skip || false,\n        caseSensitive:\n          this.current.collection.searchOpts.caseSensitive || false,\n        extract: (el) => {\n          if (typeof this.current.collection.lookup === \"string\") {\n            return el[this.current.collection.lookup];\n          } else if (typeof this.current.collection.lookup === \"function\") {\n            return this.current.collection.lookup(el, this.current.mentionText);\n          } else {\n            throw new Error(\n              \"Invalid lookup attribute, lookup must be string or function.\"\n            );\n          }\n        },\n      });\n\n      items = items.slice(0, this.current.collection.menuItemLimit);\n\n      this.current.filteredItems = items;\n\n      const inlineConfig = this.current.collection.inline;\n      const inlineEnabled = inlineConfig === true;\n      let inlineShown = false;\n\n      const ul = this.menu.querySelector(\"ul\");\n      let showMenu = false;\n\n      if (!items.length) {\n        this.range.hideInlineSuggestion();\n        this.current.inlineSuggestionItem = null;\n        this.current.inlineSuggestionText = null;\n        const noMatchEvent = new CustomEvent(\"tribute-no-match\", {\n          detail: this.menu,\n        });\n        this.current.element.dispatchEvent(noMatchEvent);\n        if (inlineEnabled) {\n          showMenu = false;\n        } else {\n          if (\n            (typeof this.current.collection.noMatchTemplate === \"function\" &&\n              !this.current.collection.noMatchTemplate()) ||\n            !this.current.collection.noMatchTemplate\n          ) {\n            showMenu = false;\n          } else {\n            typeof this.current.collection.noMatchTemplate === \"function\"\n              ? (ul.innerHTML = this.current.collection.noMatchTemplate())\n              : (ul.innerHTML = this.current.collection.noMatchTemplate);\n            showMenu = true;\n          }\n        }\n      } else {\n        if (inlineEnabled) {\n          this.range.hideInlineSuggestion();\n          if (this.current.element) {\n            this.events.updateSelection(this.current.element);\n          }\n          let mentionTextForMatch = this.current.mentionText || \"\";\n          const triggerForMatch =\n            this.current.mentionTriggerChar ||\n            (this.current.collection && this.current.collection.trigger) ||\n            \"\";\n          if (this.current.element) {\n            let fullTextForMatch = null;\n            if (!this.range.isContentEditable(this.current.element)) {\n              const elementValue = this.current.element.value || \"\";\n              const selectionStart = this.current.element.selectionStart;\n              fullTextForMatch =\n                typeof selectionStart === \"number\"\n                  ? elementValue.substring(0, selectionStart)\n                  : elementValue;\n            } else {\n              const selection = this.range.getContentEditableSelectionStart(false);\n              if (selection && selection.range) {\n                const preRange = selection.range.cloneRange();\n                preRange.selectNodeContents(this.current.element);\n                preRange.setEnd(\n                  selection.range.startContainer,\n                  selection.range.startOffset\n                );\n                fullTextForMatch = preRange.toString();\n              } else {\n                fullTextForMatch =\n                  this.current.element.textContent ||\n                  this.current.fullText ||\n                  \"\";\n              }\n            }\n            let matchedTrigger = triggerForMatch;\n            let start =\n              matchedTrigger && fullTextForMatch\n                ? fullTextForMatch.lastIndexOf(matchedTrigger)\n                : -1;\n            if (start < 0) {\n              let lastTriggerIndex = -1;\n              let lastTrigger = \"\";\n              this.collection.forEach((config) => {\n                if (!config.trigger) return;\n                const idx =\n                  fullTextForMatch && config.trigger\n                    ? fullTextForMatch.lastIndexOf(config.trigger)\n                    : -1;\n                if (idx > lastTriggerIndex) {\n                  lastTriggerIndex = idx;\n                  lastTrigger = config.trigger;\n                }\n              });\n              if (lastTriggerIndex >= 0) {\n                matchedTrigger = lastTrigger;\n                start = lastTriggerIndex;\n              }\n            }\n            if (start >= 0 && matchedTrigger) {\n              const candidate = fullTextForMatch.substring(\n                start + matchedTrigger.length\n              );\n              if (candidate.length || !mentionTextForMatch) {\n                mentionTextForMatch = candidate;\n                this.current.mentionPosition = start;\n                this.current.mentionTriggerChar = matchedTrigger;\n              }\n            }\n          }\n          if (mentionTextForMatch !== this.current.mentionText) {\n            this.current.mentionText = mentionTextForMatch;\n          }\n          const firstMatch = items[0];\n          if (firstMatch) {\n            let text =\n              firstMatch.original[this.current.collection.fillAttr || \"value\"];\n            if (!text) {\n              text = this.current.collection.menuItemTemplate(firstMatch);\n            }\n            if (\n              text\n                .toLowerCase()\n                .startsWith(mentionTextForMatch.toLowerCase())\n            ) {\n              const suffix = text.substring(mentionTextForMatch.length);\n              if (suffix) {\n                this.range.showInlineSuggestion(suffix);\n                inlineShown = true;\n                this.current.inlineSuggestionText = text;\n                this.current.inlineSuggestionItem = firstMatch;\n              } else {\n                this.range.hideInlineSuggestion();\n              }\n            } else {\n              this.range.hideInlineSuggestion();\n            }\n          } else {\n            this.range.hideInlineSuggestion();\n          }\n\n          if (!inlineShown) {\n            this.current.inlineSuggestionItem = null;\n            this.current.inlineSuggestionText = null;\n          }\n          if (this.menu) {\n            this.menu.style.display = \"none\";\n          }\n          this.isActive = inlineShown;\n          return;\n        } else {\n          this.range.hideInlineSuggestion();\n          this.current.inlineSuggestionItem = null;\n          this.current.inlineSuggestionText = null;\n        }\n\n        const fragment = this.range.getDocument().createDocumentFragment();\n        ul.innerHTML = \"\";\n        if (header) {\n          const lh = this.range.getDocument().createElement(\"lh\");\n          lh.innerHTML = header;\n          ul.appendChild(lh)\n        }\n\n        items.forEach((item, index) => {\n          const li = this.range.getDocument().createElement(\"li\");\n          li.setAttribute(\"data-index\", index);\n          li.className = this.current.collection.itemClass;\n          li.addEventListener(\n            \"mouseover\",\n            function (index) {\n              this.events.setActiveLi(index);\n            }.bind(this, index)\n          );\n\n          if (this.menuSelected === index) {\n            li.classList.add(this.current.collection.selectClass);\n          }\n          li.innerHTML = this.current.collection.menuItemTemplate(item);\n          if (this.selectByDigit) {\n            li.innerHTML = ((index + 1) % 10).toString() + '. ' + li.innerHTML;\n          }\n          fragment.appendChild(li);\n        });\n        ul.appendChild(fragment);\n        showMenu = true;\n      }\n      if (showMenu) {\n        this.isActive = true;\n        this.range.positionMenuAtCaret(scrollTo);\n      } else if (this.isActive) {\n        this.isActive = false;\n        this.hideMenu();\n      }\n    };\n\n    if (typeof this.current.collection.values === \"function\") {\n      if (this.current.collection.loadingItemTemplate) {\n        this.menu.querySelector(\"ul\").innerHTML =\n          this.current.collection.loadingItemTemplate;\n        this.range.positionMenuAtCaret(scrollTo);\n      }\n\n      this.current.collection.values(\n        this.current.mentionText,\n        processValues,\n        this.current.fullText,\n        this.current.nextChar\n      );\n    } else {\n      processValues(this.current.collection.values);\n    }\n  }\n\n  showMenuForCollection(element, collectionIndex) {\n    if (!this.events.updateSelection(element)) return;\n    if (element !== this.range.getDocument().activeElement) {\n      this.placeCaretAtEnd(element);\n      if (element.isContentEditable)\n        this.insertTextAtCursor(this.current.collection.trigger);\n      else this.insertAtCaret(element, this.current.collection.trigger);\n    }\n\n    this.current.collection = this.collection[collectionIndex || 0];\n\n    this.showMenuFor(element);\n  }\n\n  // TODO: make sure this works for inputs/textareas\n  placeCaretAtEnd(el) {\n    el.focus();\n    if (\n      typeof window.getSelection !== \"undefined\" &&\n      typeof this.range.getDocument().createRange !== \"undefined\"\n    ) {\n      const range = this.range.getDocument().createRange();\n      range.selectNodeContents(el);\n      range.collapse(false);\n      const sel = window.getSelection();\n      sel.removeAllRanges();\n      sel.addRange(range);\n    } else if (\n      typeof this.range.getDocument().body.createTextRange !== \"undefined\"\n    ) {\n      const textRange = this.range.getDocument().body.createTextRange();\n      textRange.moveToElementText(el);\n      textRange.collapse(false);\n      textRange.select();\n    }\n  }\n\n  // for contenteditable\n  insertTextAtCursor(text) {\n    const sel = window.getSelection();\n    const range = sel.getRangeAt(0);\n    range.deleteContents();\n    const textNode = this.range.getDocument().createTextNode(text);\n    range.insertNode(textNode);\n    range.selectNodeContents(textNode);\n    range.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n\n  // for regular inputs\n  insertAtCaret(textarea, text) {\n    const scrollPos = textarea.scrollTop;\n    let caretPos = textarea.selectionStart;\n\n    const front = textarea.value.substring(0, caretPos);\n    const back = textarea.value.substring(\n      textarea.selectionEnd,\n      textarea.value.length\n    );\n    textarea.value = front + text + back;\n    caretPos = caretPos + text.length;\n    textarea.selectionStart = caretPos;\n    textarea.selectionEnd = caretPos;\n    textarea.focus();\n    textarea.scrollTop = scrollPos;\n  }\n\n  hideMenu() {\n    if (this.menu) {\n      this.menu.remove();\n      this.menu = null;\n    }\n    this.range.hideInlineSuggestion();\n    this.isActive = false;\n    this.activationPending = false;\n    this.current = {};\n  }\n\n  selectItemAtIndex(index, originalEvent) {\n    index = parseInt(index);\n    if (!(typeof index !== \"number\" || isNaN(index) || !originalEvent.target)) {\n      const item = this.current.filteredItems[index];\n      const content = this.current.collection.selectTemplate(item);\n      if (content !== null) this.replaceText(content, originalEvent, item);\n    }\n    this.hideMenu();\n  }\n\n  replaceText(content, originalEvent, item) {\n    if (this.supportRevert) {\n      this.lastReplacement = { ...this.current };\n      this.lastReplacement.content = content;\n    }\n\n    this.range.replaceTriggerText(content, originalEvent, item);\n  }\n\n  _append(collection, newValues, replace) {\n    if (typeof collection.values === \"function\") {\n      throw new Error(\"Unable to append to values, as it is a function.\");\n    } else if (!replace) {\n      collection.values = collection.values.concat(newValues);\n    } else {\n      collection.values = newValues;\n    }\n  }\n\n  append(collectionIndex, newValues, replace) {\n    const index = parseInt(collectionIndex);\n    if (typeof index !== \"number\")\n      throw new Error(\"please provide an index for the collection to update.\");\n\n    const collection = this.collection[index];\n\n    this._append(collection, newValues, replace);\n  }\n\n  appendCurrent(newValues, replace) {\n    if (this.isActive) {\n      this._append(this.current.collection, newValues, replace);\n    } else {\n      throw new Error(\n        \"No active state. Please use append instead and pass an index.\"\n      );\n    }\n  }\n\n  detach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      const length = el.length;\n      for (let i = 0; i < length; ++i) {\n        this._detach(el[i]);\n      }\n    } else {\n      this._detach(el);\n    }\n  }\n\n  _detach(el) {\n    this.events.unbind(el);\n    if (el.tributeMenu) {\n      this.menuEvents.unbind(el.tributeMenu);\n    }\n\n    setTimeout(() => {\n      el.removeAttribute(\"data-tribute\");\n      this.isActive = false;\n      if (el.tributeMenu) {\n        el.tributeMenu.remove();\n      }\n    });\n  }\n\n  debounce(func, wait, option = { leading: true, trailing: true }) {\n    let timer = null;\n    return (...args) => {\n      const timerExpired = (callFunc) => {\n        timer = null;\n        if (callFunc) func.apply(this, args);\n      };\n      const callNow = option.leading && timer === null;\n      const timeoutFn = timerExpired.bind(this, !callNow && option.trailing);\n      clearTimeout(timer);\n      timer = setTimeout(timeoutFn, wait);\n      if (callNow) func.apply(this, args);\n    };\n  }\n}\n\nexport default Tribute;\n"],"names":["TributeEvents","constructor","tribute","this","events","keys","digits","modifiers","isSpaceKey","event","code","key","isTextInputKey","length","bind","element","boundKeyDown","keydown","boundKeyUpInput","debounce","input","inputDebounce","addEventListener","unbind","removeEventListener","instance","controlKeyPressed","keyProcessed","lastKeydownEvent","keyCode","which","handled","defaultPrevented","isTab","inlineElement","current","inlineSuggestion","range","getDocument","querySelector","preventDefault","stopImmediatePropagation","hideInlineSuggestion","mentionTriggerChar","collection","trigger","item","inlineSuggestionItem","content","selectTemplate","replaceText","hideMenu","KeyboardEvent","forEach","o","getModifierState","isActive","callbacks","selectByDigit","index","filteredItems","lastReplacement","cEvent","CustomEvent","iEvent","InputEvent","iEventHandle","inputType","startsWith","keyup","call","click","menu","contains","target","li","nodeName","toLowerCase","parentNode","Error","selectItemAtIndex","getAttribute","keydownPrevented","autocompleteMode","updateSelection","getKeyCode","isNaN","triggers","find","charCodeAt","minLength","menuShowMinLength","mentionText","showMenuFor","data","NaN","el","info","getTriggerInfo","allowSpaces","mentionPosition","fullText","nextChar","Backspace","e","_el","Digit","digit","setActiveLi","Enter","menuSelected","Escape","Tab","Space","spaceSelectsMatch","ArrowUp","count","selected","scrollTop","scrollHeight","ArrowDown","lis","querySelectorAll","i","classList","add","selectClass","liClientRect","getBoundingClientRect","menuClientRect","bottom","scrollDistance","top","remove","TributeMenuEvents","menuEvents","_menu","menuClickEvent","menuContainerScrollEvent","windowResizeEvent","windowBlurEvent","window","menuContainer","TributeRange","iframe","contentWindow","document","positionMenuAtCaret","scrollTo","context","coordinates","positionMenu","isContentEditable","getContentEditableCaretPosition","getTextAreaOrInputUnderlinePosition","style","left","right","maxHeight","maxWidth","position","display","scrollIntoView","showInlineSuggestion","text","getContentEditableInlinePosition","div","createElement","className","innerText","targetElement","getContentEditableTargetElement","computedStyle","getComputedStyle","color","opacity","inlineTop","height","pointerEvents","whiteSpace","zIndex","font","fontFamily","fontSize","fontWeight","fontStyle","fontVariant","letterSpacing","wordSpacing","textTransform","lineHeight","direction","fontFeatureSettings","fontKerning","textAlign","WebkitFontSmoothing","MozOsxFontSmoothing","body","appendChild","selection","getWindowSelection","rangeCount","originalRange","getRangeAt","cloneRange","rect","marker","createTextNode","insertNode","removeChild","removeAllRanges","addRange","parseFloat","Number","Math","max","elementRect","node","startContainer","nodeType","replaceTriggerText","originalEvent","detail","replaceEvent","sel","getContentEditableSelectionStart","staticRange","StaticRange","anchorNode","startOffset","anchorOffset","endContainer","endOffset","replaceTextSuffix","dispatchEvent","bubbles","cancelable","targetRanges","pasteContentEditable","myField","textSuffix","stripHtml","startPos","endPos","value","substring","selectionStart","selectionEnd","html","numOfCharsToRemove","strippedText","isHTML","anchorNodeValue","nodeValue","pasteText","pasteHtml","pre","post","setStart","collapse","collapseToEnd","_range","newRange","deleteContents","modify","innerHTML","frag","createDocumentFragment","lastNode","firstChild","setEnd","tmp","textContent","getSelection","rootNode","getRootNode","moveToEndOfWord","isCollapsed","focusOffset","selectedElem","childNodes","textNode","min","workingNodeContent","selectStartOffset","nextSibling","nextNodeText","nextCharIsSeparator","autocompleteSeparator","match","getWholeWordsUpToCharIndex","str","minLen","searchPos","arr","split","filter","trim","len","idx","indexOf","getTextForCurrentSelection","effectiveRange","toString","numberOfWordsInContextText","newText","endsWith","restoreSelection","textComponent","result","getLastWordInText","wordsArray","escapeRegExp","string","replace","isAutocomplete","requireLeadingSpace","lastWordOfEffectiveRange","triggerChar","mostRecentTriggerCharPos","config","c","regExpStr","searchRes","RegExp","test","currentTriggerSnippet","firstSnippetChar","leadingSpace","trailingSpace","trimEnd","isMenuOffScreen","menuDimensions","windowWidth","innerWidth","windowHeight","innerHeight","doc","documentElement","windowLeft","pageXOffset","scrollLeft","clientLeft","windowTop","pageYOffset","clientTop","menuTop","menuRight","width","menuBottom","menuLeft","floor","ceil","getMenuDimensions","dimensions","visibility","offsetWidth","offsetHeight","_flipped","id","computed","currentStyle","wordWrap","prop","span0","span","span2","spanRect","span2Rect","divRect","fallbackHeight","glyphRect","glyphHeight","lineBoxHeight","extraLeading","lineBoxTop","clamp","number","finalRect","getFixedCoordinatesRelativeToRect","_selectedNodePosition","parentNodeRect","availableSpaceOnTop","availableSpaceOnBottom","availableSpaceOnLeft","availableSpaceOnRight","_elem","clientRect","undefined","elemTop","elemBottom","maxY","targetY","directionFwd","endRange","extend","TributeSearch","search","pattern","opts","compareString","caseSensitive","skip","rendered","score","patternCache","traverse","render","cache","stringIndex","patternIndex","splice","calculateScore","slice","best","temp","push","pop","indices","reduce","prev","_arr","extract","original","sort","a","b","compare","Tribute","values","loadingItemTemplate","containerClass","itemClass","menuItemTemplate","lookup","fillAttr","noMatchTemplate","searchOpts","menuItemLimit","supportRevert","inline","activationPending","defaultSelectTemplate","defaultMenuItemTemplate","t","console","warn","map","_isActive","val","activeEvent","matchItem","inputTypes","attach","jQuery","get","NodeList","HTMLCollection","Array","_attach","hasAttribute","ensureEditable","setAttribute","contentEditable","createMenu","wrapper","ul","round","parseInt","currentMentionTextSnapshot","tributeMenu","processValues","forceReplace","header","activeElement","items","inlineEnabled","inlineShown","showMenu","mentionTextForMatch","triggerForMatch","fullTextForMatch","preRange","selectNodeContents","elementValue","matchedTrigger","start","lastIndexOf","lastTriggerIndex","lastTrigger","candidate","firstMatch","suffix","inlineSuggestionText","fragment","lh","noMatchEvent","showMenuForCollection","collectionIndex","placeCaretAtEnd","insertTextAtCursor","insertAtCaret","focus","createRange","createTextRange","textRange","moveToElementText","select","textarea","scrollPos","caretPos","front","back","_append","newValues","concat","append","appendCurrent","detach","_detach","setTimeout","removeAttribute","func","wait","option","leading","trailing","timer","args","callNow","timeoutFn","callFunc","apply","clearTimeout"],"mappings":"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"}